# Copyright 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/board.gni")
import("//build/compiled_action.gni")
import("//build/config/build_api_module.gni")
import("//build/config/compiler.gni")
import("//build/drivers/check_included_drivers.gni")
import("//build/drivers/create_all_drivers_doc.gni")
import("//build/fidl/args.gni")
import("//build/images/args.gni")
import("//build/info/info.gni")
import("//build/product.gni")
import("//build/rust/config.gni")
import("//build/security.gni")
import("//build/testing/platforms.gni")
import("//build/toolchain/goma.gni")
import("//build/toolchain/zircon/clang.gni")
import("//build/zbi/zbi.gni")

declare_args() {
  # If you add fuchsia_driver_package labels to this variable, any drivers in these packages will
  # be visible to Driver Manager. These package labels are also considered to be in the
  # 'base' package set (for more info see 'base_package_labels').
  base_driver_package_labels = []

  # If you add package labels to this variable, the packages will be included in
  # the 'base' package set, which represents the set of packages that are part
  # of an OTA. These packages are updated as an atomic unit during an OTA
  # process and are immutable and are a superset of the TCB (Trusted Computing
  # Base) for a product. These packages are never evicted by the system.
  base_package_labels = []

  # If you add package labels to this variable, the packages will be included
  # in the 'cache' package set, which represents an additional set of software
  # that is made available on disk immediately after paving and in factory
  # flows. These packages are updated with an OTA, and can also be updated
  # ephemerally. This cache of software can be evicted by the system if storage
  # pressure arises or other policies indicate.
  cache_package_labels = []

  # A file in containing historical test duration data for this build
  # configuration, used used by testsharder to evenly split tests across
  # shards. It should be set for any builds where testsharder will be run
  # afterwards.
  test_durations_file = ""

  # If you add package labels to this variable, the packages will be included
  # in the 'universe' package set, which represents all software that is
  # produced that is to be published to a package repository or to the SDK by
  # the build. The build system ensures that the universe package set includes
  # the base and cache package sets, which means you do not need to redundantly
  # include those labels in this variable.
  universe_package_labels = []

  # If you add labels to this variable, these will be included in the 'host'
  # artifact set, which represents an additional set of host-only software that
  # is produced by the build.
  host_labels = []

  # Extra sdk() archive labels to be uploaded to the artifacts store. This is
  # an extension mechanism for SDK bits outside of the main repository.
  sdk_archive_labels = []
}

if (host_os == "mac") {
  import("//build/config/mac/mac_sdk.gni")
}

###
### fx integration.
###

# Write a file that can be sourced by `fx`.  This file is produced
# by `gn gen` and is not known to Ninja at all, so it has nothing to
# do with the build itself.  Its sole purpose is to leave bread
# crumbs about the settings `gn gen` used for `fx` to use later.
_relative_build_dir = rebase_path(root_build_dir, "//", "//")
_host_out_dir = rebase_path(host_out_dir, root_build_dir)
_fx_config_lines = [
  "# Generated by `gn gen`.",
  "FUCHSIA_BUILD_DIR='${_relative_build_dir}'",
  "FUCHSIA_ARCH='${target_cpu}'",
  "FUCHSIA_BOARD_NAME=${board_name}",
  "FUCHSIA_ZBI_COMPRESSION=$zbi_compression",
  "HOST_OUT_DIR='${_host_out_dir}'",
  "USE_GOMA=$use_goma",
]
if (use_goma && goma_dir != prebuilt_goma_dir) {
  _fx_config_lines += [ "GOMA_DIR=" + rebase_path(goma_dir) ]
}
write_file("$root_build_dir/fx.config", _fx_config_lines)

###
### Build API modules.
###

# This is the top-level build API module that just lists all the others.
# Each element of the list is the simple name of the API module; the
# module's contents are found at "$root_build_dir/$target_name.json".
#
# Type: list(string)
#
build_api_module("api") {
  testonly = true
  data_keys = [ "build_api_modules" ]
  deps = [
    ":all_package_manifest_paths",
    ":archives",
    ":args",
    ":assembly_input_archives",
    ":binaries",
    ":build_info",
    ":checkout_artifacts",
    ":cipd_assembly_artifacts",
    ":clippy_target_mapping",
    ":fuzzers",
    ":generated_sources",
    ":images",
    ":package-repositories",
    ":platforms",
    ":prebuilt_binaries",
    ":prebuilt_package_flavors",
    ":rbe_config",
    ":sdk_archives",
    ":test_durations",
    ":tests",
    ":tool_paths",
    ":triage_sources",
    ":zbi_tests",
  ]
}

# This describes the location of the package repository, in:
#  "$root_build_dir/package-repositories.json"
#
# Type: list(scope)
#
#   path
#     Required: Path to the package repository, relative to $root_build_dir.
#     Type: path relative to $root_build_dir
#
#   targets
#     Required: Path to the targets.json file with the contents in this
#       package repository, relative to $root_build_dir.
#     Type: path relative to $root_build_dir
#
#   blobs
#     Required: Path to the blobs directory in this package repository,
#       relative to $root_build_dir.
#     Type: path relative to $root_build_dir
#
build_api_module("package-repositories") {
  testonly = true
  data_keys = [ "package_repository" ]
  deps = [ "//build/images:updates" ]
}

# This describes all the archives the build can produce, in:
# "$root_build_dir/archives.json"
#
# TODO(fxbug.dev/43568): Delete me ASAP. Archives are targets that necessarily
# depend on 'everything'; targets like this should be migrated away from.
#
# Type: list(scope)
#
#   name
#     Required: The primary way that this archive is known to consumers.
#     The tuple of ($name, $type) should be unique.
#     Type: string
#
#   path
#     Required: Path to where the archive is found, relative to $root_build_dir.
#     Type: path relative to $root_build_dir
#
#   type
#     Required: "zip" or "tgz".
#     Type: string
#
build_api_module("archives") {
  testonly = true
  data_keys = [ "archives" ]
  deps = [
    "//build/gn:archives",
    "//build/images:archives",
  ]
}

# TODO(crbug.com/gn/132): Remove when GN emits the equivalent information
# itself.
#
# in file: "$root_build_dir/args.json"
#
# This just regurgitates the build arguments specified to `gn gen`.  This is
# the exact JSON representation of the settings in "$root_build_dir/args.gn".
# It does not include build arguments left to their default values.  So to
# reproduce the settings of this build, one could put in `args.gn`:
# ```
#   forward_variables_from(read_file("args.json", "json"), "*")
# ```
# Type: scope
#
build_api_module("args") {
  contents = read_file("$root_build_dir/args.gn", "scope")
}

# This describes all the binaries linked by the build.
#
# This enumerates each linked binary (executable, shared library, or
# loadable/"plug-in" module) used by the build, or produced by the build.
#
# This includes host tools, kernels, boot loaders, drivers, as well as
# normal executables. This also includes prebuilt toolchain runtime
# libraries that end up in image files. It does not yet include any
# non-native binary formats.
#
# For non-prebuilts, this is meant to reach the entire dependency graph
# of all binaries that the build would ever produce.  Not every binary
# described is necessarily actually produced by any given Ninja run.  Either
# the $debug or the $dist file for any individual binary can be passed to
# Ninja as a specific target argument to ensure it's built and
# up to date before making use of that binary.  Like all build_api_module()
# targets, the top-level "binaries" target serves as a Ninja target to
# request that every binary described be built.
#
# Note that in certain cases, the paths in `debug` and `dist` will
# point out of the build tree, and thus cannot be used as Ninja targets.
# This happens for prebuilts or binaries produced by the Zircon build.
#
# Type: list(scope)
#
#   cpu
#     Required: CPU architecture the binary is for, e.g. "arm64" or "x64".
#     Type: string
#
#   os
#     Required: OS the binary is for, e.g. "fuchsia", "linux", or "mac".
#     Type: string
#
#   environment
#     Required: The ${toolchain_environment} name of what specific
#     execution this was built for, e.g. "user", "host", "guest".  The
#     tuple of ($cpu, $os, $environment) should indicate what hardware and
#     software environment this binary is compatible with.
#     Type: string
#
#   label
#     Required: The GN label of the binary target.
#     Type: label_with_toolchain
#
#   type
#     Required: The type of binary.
#     Type: "executable" or "shared_library" or "loadable_module"
#
#   debug
#     Required: Path to where the unstripped or separate debug file is
#     found, relative to $root_build_dir.  If $dist is omitted, this
#     is also the file that is used at runtime.
#     Type: path relative to $root_build_dir
#
#   dist
#     Optional: Path to where the stripped binary for deployment/execution is
#     found, relative to $root_build_dir.  This binary may be required for
#     some debugging tasks if $debug is a separate debug file rather than
#     an unstripped file.  It should exactly match the binary that will be
#     seen on devices or run directly on hosts.
#     Type: path relative to $root_build_dir
#
#   elf_build_id
#     Optional: Path to a file containing the lowercase ASCII hexadecimal
#     representation of the ELF build ID in this binary.  This is omitted
#     for OS environments that don't use ELF.  For an ELF binary that
#     doesn't have a build ID note, this key will be present but point to
#     an empty file.
#     Type: path relative to $root_build_dir
#
#   breakpad
#     Optional: Path to the breakpad symbol file for the debug binary.  This
#     will only be present if $output_breakpad_syms was set.
#     Type: path relative to $root_build_dir
build_api_module("binaries") {
  testonly = true
  data_keys = [ "binaries" ]
  deps = [ ":default" ]
}

# Describes the configuration of the build in the file:
#  "$root_build_dir/build_info.json"
#
# Type: list(scope)
#
#   version
#     Optional: The version of the build. Present during official builds.
#     Type: string
#
#   configurations
#     Required: The list of product/board configurations within the build.
#     Each `configurations` entry is a scope that contains both a product
#     and board specification.
#     Type: list(scope)
#
build_api_module("build_info") {
  testonly = true
  contents = {
    version = build_info_version

    # A list to accommodate the future of a build that support building multiple
    # (board, product) pairs.
    configurations = [
      {
        board = build_info_board
        product = build_info_product
      },
    ]
  }
}

# Artifacts from the checkout. Though a priori unrelated to the build, they are
# useful to track here.
#
# in file: "$root_build_dir/checkout_artifacts.json"
#
# Type: list(scope)
#
#   name
#     Required: The primary way that this file is known to consumers.
#     The name should be unique among other entries.
#     Type: string
#
#   path
#     Required: Path to where the file is found, relative to $root_build_dir.
#     Type: path relative to $root_build_dir
#
#   type
#     Required: The file format (e.g., "txt" or "xml").
#     Type: string
#
build_api_module("checkout_artifacts") {
  testonly = true
  data_keys = [ "checkout_artifacts" ]
  deps = [ ":checkout_artifacts.metadata" ]
}

group("checkout_artifacts.metadata") {
  testonly = true
  visibility = [ ":checkout_artifacts" ]
  metadata = {
    checkout_artifacts = [
      {
        # TODO(fxbug.dev/43568): Remove `archive` field. This is a signal to
        # include the this file in the archive.
        archive = true
        name = "jiri_snapshot"
        path = rebase_path("//.jiri_root/update_history/latest", root_build_dir)
        type = "xml"
      },
      {
        name = "ssh_authorized_key"
        path = rebase_path("//.ssh/authorized_keys", root_build_dir)
        type = "txt"
      },
      {
        name = "ssh_private_key"
        path = rebase_path("//.ssh/pkey", root_build_dir)
        type = "txt"
      },
    ]
  }
}

# This describes all the generated source files in the build.
#
# The intent is that telling Ninja to build all these individual files
# will be the minimal work sufficient for source code analysis of all
# the files described in the compilation database to be viable.
#
# Type: list(path relative to $root_build_dir)
#
build_api_module("generated_sources") {
  testonly = true
  data_keys = [ "generated_sources" ]
  deps = [
    "//build/images:packages",
    "//sdk",
  ]
}

# Describes the "fuzzers" in the build, in the file:
#  "$root_build_dir/fuzzers.json"
#
# See //build/fuzzing/fuzzer.gni for more details.
#
#
# Type: list(scope)
#
#  fuzzers_package
#    Required: Name of a package containing fuzzers.
#    Type: string
#
#  fuzzers
#    Required: The fuzzer binaries included in the associated package.
#    Type: list of labels
#
#  fuzz_host
#    Required: Indicates whether the associated fuzzer binaries were built for
#    the host.
#    Type: boolean
#
build_api_module("fuzzers") {
  testonly = true
  data_keys = [ "fuzz_spec" ]
  deps = [ "//build/images:packages" ]
}

# This describes all the "image" files the build can produce, in the file:
#  "$root_build_dir/images.json"
#
# An "image file" is a binary file that typically ends up on a device
# partition (e.g. kernel, boot loader, partition image, etc).
#
# Consumers of the build should look here for the images to be built.
# The $cpu, $name, and $type fields identify the purpose of each image.
# Consumers are expected to ignore extra images they have no use for or
# whose fields they don't understand.
#
# The $path field indicates where the file is found in the build
# directory.  The presence of an image in the list means that the build
# *can* produce it, not that the build *will* produce it.  Hence,
# consumers should use $path as an explicit argument to Ninja to ensure
# that each needed image gets built.
#
# Type: list(scope)
#
#   cpu
#     Required: CPU architecture the image is for, e.g. "arm64" or "x64".
#     Type: string
#
#   name
#     Required: The primary way that this image is known to consumers.
#     Note that the name need not be unique within the images list.
#     The tuple of ($name, $type, $cpu) should be unique.
#     Type: string
#
#   fastboot_flash
#     Optional: the partition(s) to fastboot flash this image to. As a special
#     case, this can be an empty list to indicate a file that may be needed for
#     flashing but doesn't necessarily get flashed to a partition, for example
#     bootloader unlock credentials.
#     Type: list(string)
#
#   label
#     Required: The GN label of the image target.
#     Type: label_with_toolchain
#
#   path
#     Required: Path to where the file is found, relative to $root_build_dir.
#     This is also the argument to Ninja that ensures this image will be built.
#     Type: path relative to $root_build_dir
#
#   testonly
#     Optional: This image includes test code/data not meant for production.
#     Type: bool
#     Default: false
#
#   tags
#     Optional: Tags associated with the image.  Certain tags may indicate
#     to the build API consumer what should be done with the image.
#     Type: list(string)
#
#   type
#     Required: Type of file, e.g. "zbi".  This often corresponds to the
#     extension used on the image file name, but not always.  For many
#     miscellaneous formats, this is just "bin" and the consumer is
#     expected to understand what the particular format is for particular
#     $name, $cpu combinations.  Other types include:
#      * "zbi": the ZBI (<zircon/boot/image.h>) format
#      * "efi": an EFI executable that an EFI boot loader can load
#      * "kernel": some other format loaded by a boot loader or emulator
#      * "blk": contents to be written to a storage device or partition
#     Type: string
#
#   bootserver_pave, bootserver_pave_zedboot, bootserver_netboot
#     Optional: flag names under which the associated image should be passed to
#     the bootserver when paving, paving zedboot, or netbooting, respectively.
#     Type: list(string)
#
build_api_module("images") {
  testonly = true
  data_keys = [ "images" ]
  deps = [
    # XXX(46415): as the build is specialized by board (bootfs_only)
    # for bringup, it is not possible for this to be complete. As this
    # is used in the formation of the build API with infrastructure,
    # and infrastructure assumes that the board configuration modulates
    # the definition of `zircon-a` between bringup/non-bringup, we can
    # not in fact have a complete description. See the associated
    # conditional at this group also.
    "build/images",

    # This has the images referred to by $qemu_kernel_label entries.
    "//build/zircon/zbi_tests",
  ]
}

# Describes the SDK archives that can be built, in the file:
# "$root_build_dir/sdk_archives.json"
#
#   * name
#     - Required: Name of the SDK.
#     - Type: string
#
#   * label
#     - Required: GN label of the associated `sdk` target.
#     - Type: label_with_toolchain
#
#   * path
#     - Required: Path to the built archive.
#     - Type: path relative to $root_build_dir
#
#   * os
#     - Required: OS is the operating system which the SDK is built for. A value
#       of "fuchsia" indicates the SDK is host OS agnostic.
#     - Type: string
#
#   * cpu
#     - Required: CPU architecture which the SDK is built for.
#     - Type: string
#
build_api_module("sdk_archives") {
  testonly = true
  data_keys = [ "sdk_archives" ]
  deps = [ "//sdk:archives" ] + sdk_archive_labels
}

# Describes the platforms available for testing, in the file:
#  "$root_build_dir/platforms.json"
#
# TODO(fxbug.dev/10429): the fuchsia platform should not know about such things.
#
# Type: list(scope)
#
build_api_module("platforms") {
  testonly = true
  contents = []
  foreach(platform, test_platforms) {
    if (!defined(platform.cpu) || platform.cpu == current_cpu) {
      contents += [ platform ]
    }
  }
}

# This describes where to find all prebuilt binaries, in the file:
#  "$root_build_dir/prebuilt_binaries.json"
#
# The `manifest` field will point to another JSON file that is almost a subset
# of the :binaries build API module: the only fields present are `cpu`,
# `debug`, `os`, and `elf_build_id`, which in this case is not a file pointer
# but instead the actual build ID.
#
#
# Type: list(scope)
#
#   name
#     Required: The name of the collection of prebuilt binaries.
#     Type: string
#
#   manifest
#     Required: The path to the manifest of prebuilt binaires. See note above
#     for its schema.
#     Type: string
#
build_api_module("prebuilt_binaries") {
  testonly = true
  data_keys = [ "prebuilt_binaries" ]
  deps = [
    "//build/images:packages",
    "//build/prebuilt",
    "//sdk",
  ]
}

# This describes which flavor was used for each of the prebuilt packages
# which provide multiple flavors to choose from.
#
# in file:
#  "$root_build_dir/images.json"
#
# For more information, see:  //build/packages/prebuilt_package_with_flavors.gni
#
# Type: list(scope)
#
#   package
#     Required: The name of the package.
#
#   name
#     Required: The name of the flavor that is being used.
#
#   archive
#     Required: The path to the archive that was used.
#
#   production_safe
#     Required:  if 'true' then this flavor is valid for use in production
#     contexts.
#
build_api_module("prebuilt_package_flavors") {
  testonly = true
  data_keys = [ "prebuilt_package_with_flavors" ]
  deps = [ "//build/images:packages" ]
}

# Tests in the build.
#
#  Below, the "testing root" refers to $root_build_dir on host, and the full
#  filesystem path from the root on device.
#
# Type: list(scope)
#
#   * name
#     - Required: Name of test.
#     - Type: string
#
#   * label
#     - Required: GN label associated with the test
#     - Type: label_with_toolchain
#
#   * path
#     - Required: Path to the test's executable.
#     - Type: path relative to the testing root.
#
#   * cpu, os
#     - Required: $current_cpu and $current_os values, respectively, for
#       which this test is intended.
#     - Type: string
#
#   * disabled
#     - Optional: a free-form string indicating a reason for the test being
#       disabled.
#     - Type: string
#
#   * runtime_deps
#     - Optional: a JSON file containing a list of root_build_dir-relative
#       paths defining ascribed runtime dependencies of the test. These
#       dependencies are aggregated via the metadata graph of the associated
#       test target under a data key of "test_runtime_deps.
#     - Type: path relative to root_build_dir
#
build_api_module("tests") {
  testonly = true
  data_keys = [ "tests" ]
  deps = [
    # Pull in tests from host_labels.
    "//:host",

    # Pull in tests from *_package_labels.
    "//build/images:packages",
  ]
}

# test-list.json contains the set of tests in the build along with arbitrary
# test metadata attached to each test.
compiled_action("test-list") {
  testonly = true
  tool = "//tools/test_list_tool"
  tool_output_name = "test_list_tool"

  inputs = [ "$root_build_dir/tests.json" ]
  outputs = [ "$root_build_dir/test-list.json" ]
  depfile = "$root_build_dir/test-list.json.d"

  deps = [ ":tests" ]

  args = [
    "--build-dir",
    ".",
    "--input",
    "tests.json",
    "--output",
    "test-list.json",
    "--depfile",
    "test-list.json.d",
  ]
}

# test_durations.json contains historical test durations data to be used for
# scheduling tests.
#
# It contains a list of JSON objects with the following fields:
#
#   name
#     Required: The name of the test. For Fuchsia tests, this will correspond to
#     the test package URL; for host-side tests, the installation path.
#     Type: string
#
#   median_duration_ms
#     Required: The median historical duration for this test over some period of
#     time, in milliseconds.
#     Type: int
#
build_api_module("test_durations") {
  testonly = true
  contents = []
  if (test_durations_file != "") {
    contents = read_file(test_durations_file, "json")
  }
}

# Tools provided by the build or as prebuilts, to be used outside the build.
#
# Type: list(scope)
#
#   * name
#     - Required: Name of a host tool.
#     - Type: string
#
#   * label
#     - Required: GN label associated with the tool.
#     - Type: label_with_toolchain
#
#   * path
#     - Required: Path to the tool's executable for the build host.
#     - Type: path relative to $root_build_dir
#
#   * cpu, os
#     - Required: $current_cpu and $current_os values, respectively, for
#       which this tool is intended.
#     - Type: string
#
build_api_module("tool_paths") {
  testonly = true
  data_keys = [ "tool_paths" ]
  walk_keys = [ "tool_barrier" ]
  deps = [
    ":tool_paths.llvm-tools",
    ":tool_paths.metadata",
    "//build/images:packages",
    "//src/storage/bin/fvm($host_toolchain)",
    "//third_party/cobalt/src/bin/config_change_validator/src:bin($host_toolchain)",
    "//third_party/cobalt/src/bin/config_parser/src:bin($host_toolchain)",
    "//tools/doc_checker($host_toolchain)",
    "//tools/fidl:fidl-lint($host_toolchain)",
    "//tools/fidl:fidlfmt($host_toolchain)",
    "//tools/fidl/fidlc:host($host_toolchain)",
    "//zircon/third_party/uapp/mkfs-msdosfs($host_toolchain)",
    "//zircon/tools/blobfs($host_toolchain)",
    "//zircon/tools/kazoo($host_toolchain)",
    "//zircon/tools/ktrace-dump($host_toolchain)",
    "//zircon/tools/lz4($host_toolchain)",
    "//zircon/tools/merkleroot($host_toolchain)",
    "//zircon/tools/minfs($host_toolchain)",
    "//zircon/tools/xdc-server($host_toolchain)",
    "//zircon/tools/zbi($host_toolchain)",
  ]
  if (host_os == "linux") {
    deps += [ "//zircon/tools/mtd-redundant-storage($host_toolchain)" ]
  }
}

group("tool_paths.metadata") {
  visibility = [ ":tool_paths" ]
  prebuilt_tools = [
    "$rustc_prefix/cargo",
    "$rustc_prefix/rustc",
    "$rustc_prefix/rustdoc",
    "$rustc_prefix/rustfmt",
    "//src/testing/perfcompare",

    # reclient is using fairly generic names (bootstrap, dumpstats). We may
    # need to move these into their own group() at some point to namespace
    # them.
    "//prebuilt/proprietary/third_party/reclient/$host_platform/bootstrap",
    "//prebuilt/proprietary/third_party/reclient/$host_platform/dumpstats",
    "//prebuilt/proprietary/third_party/reclient/$host_platform/reproxy",
    "//prebuilt/proprietary/third_party/reclient/$host_platform/rewrapper",
    "//prebuilt/sdk/bazel/bazel",
    "//prebuilt/third_party/clang/$host_platform/share/clang/clang-format-diff.py",
    "//prebuilt/third_party/clang/$host_platform/share/clang/clang-tidy-diff.py",
    "//prebuilt/third_party/dart/$host_platform/bin/dart",
    "//prebuilt/third_party/gn/$host_platform/gn",
    "//prebuilt/third_party/go/$host_platform/bin/go",
    "//prebuilt/third_party/go/$host_platform/bin/gofmt",
    "//prebuilt/third_party/goma/$host_platform/goma_ctl.py",
    "//prebuilt/third_party/ninja/$host_platform/ninja",
    "//prebuilt/third_party/python3/$host_platform/bin/python3",
    "//prebuilt/third_party/yapf/yapf",
    "//third_party/catapult/tracing/bin/trace2html",
  ]
  metadata = {
    tool_paths = []
    foreach(tool, prebuilt_tools) {
      tool_paths += [
        {
          cpu = host_cpu
          label = get_label_info(":$target_name", "label_with_toolchain")
          name = get_path_info(tool, "name")
          os = host_os
          path = rebase_path(tool, root_build_dir)
        },
      ]
    }
  }
}

group("tool_paths.llvm-tools") {
  visibility = [ ":tool_paths" ]
  _llvm_tools = [
    "clang",
    "clang++",
    "clang-doc",
    "clang-format",
    "clang-include-fixer",
    "clang-refactor",
    "clang-tidy",
    "clangd",
    "llvm-cov",
    "llvm-cxxfilt",
    "llvm-dwp",
    "llvm-objcopy",
    "llvm-profdata",
    "llvm-readelf",
    "llvm-size",
    "llvm-strip",
    "llvm-symbolizer",
    "llvm-xray",
    "sancov",
  ]
  metadata = {
    tool_paths = []
    foreach(tool, _llvm_tools) {
      tool_paths += [
        {
          cpu = host_cpu
          label = get_label_info(":$target_name", "label_with_toolchain")
          name = tool
          os = host_os
          path = rebase_path("$clang_tool_dir/$tool", root_build_dir)
        },
      ]
    }
  }
}

# The "triage_sources.json" build API file contains a list of paths to
# `<foo>.triage` configuration files that are used by the
# `fx triage` command. These paths are relative to the $root_build_dir.
# in file: "$root_build_dir/triage_sources.json".
#
# Type: list(string)
#
build_api_module("triage_sources") {
  testonly = true
  data_keys = [ "triage_sources" ]
  deps = [
    "//build/images:packages",
    "//src/diagnostics/config/triage",
  ]
}

# This describes all the "ZBI tests" the build can produce.
# in file: "$root_build_dir/zbi_tests.json"
#
# This tells the infra recipes how to run ZBI tests, defined with zbi_test(),
# which is a class of tests that are 'run' by booting an associated ZBI and
# listening on serial for a particular string indicating success.
#
# The schema produced here matches //:images with the addition of the
# `success_string` key.
#
# Type: list(scope)
#
#   * cpu
#     - Required: CPU architecture the image is for, e.g. "arm64" or "x64".
#     - Type: string
#
#   * name
#     - Required: The primary way that this ZBI is known to consumers.
#     Note that the name need not be unique within the images list.
#     The tuple of ($name, $cpu) should be unique.
#     - Type: string
#
#   * label
#     - Required: The GN label of the image target.
#     - Type: label_with_toolchain
#
#   * path
#     - Required: Path to where the file is found, relative to $root_build_dir.
#     This is also the argument to Ninja that ensures this image will be built.
#     - Type: path relative to $root_build_dir
#
#   * bootserver_netboot
#     - Required: bootserver commandline option for booting the ZBI.
#     - Type: string
#
#   * success_string
#     - Required: The string that the ZBI test outputs to indicate success.
#     - Type: string
#
#   * device_types
#     - Required: The list of device types that this test should be run on.
#     //build/testing/platforms.gni lists the allowed values; others will
#     be ignored.
#     - Type: list(string)
#
#   * qemu_kernel_label
#     - Optional: Label appearing in $label of an //:images entry.
#     That image should be used in place of the usual `qemu-kernel` image.
#     - Type: label_with_toolchain
#
#   * timeout
#     - Optional: Timeout for running the test, in seconds.
#     - Type: seconds
#
build_api_module("zbi_tests") {
  testonly = true
  data_keys = [ "zbi_tests" ]
  deps = [
    "build/images",
    "build/zircon/zbi_tests",
  ]
}

# Describes the paths to all the package manifests for packages in universe.
# This should be the same set of packages that are used in the pm_publish step.
# These paths are relative to the $root_build_dir.
# in file: "$root_build_dir/all_package_manifest_paths.json".
#
# Type: list(string)
#
build_api_module("all_package_manifest_paths") {
  testonly = true
  data_keys = [ "package_output_manifests" ]
  rebase = root_build_dir
  deps = [ "//build/images:all_package_manifests.list" ]

  # This prevents us from leaking packages that aren't actually being pm published
  # (e.g. packages in the ZBI).
  walk_keys = [ "package_barrier" ]
}

# Describes the path to the Fuchsia RBE config file.
# in file: "$root_build_dir/rbe_config.json"
#
# Paths are relative to $root_build_dir.
#
# Type: list(scope)
#
#   * path
#     - Required: Path to where the file is found, relative to $root_build_dir.
#     - Type: path relative to $root_build_dir
#
build_api_module("rbe_config") {
  testonly = true
  data_keys = [ "rbe_config" ]
  rebase = root_build_dir
  deps = [ ":rbe_config.metadata" ]
}

group("rbe_config.metadata") {
  testonly = true
  visibility = [ ":rbe_config" ]
  metadata = {
    rbe_config = [
      {
        path = "//build/rbe/fuchsia-re-client.cfg"
      },
    ]
  }
}

# Provides a mapping from rust source files to their corresponding clippy targets.
# See `//build/rust/clippy.gni` and `//tools/devshell/contrib/lib/rust/clippy.py`
# for more details.
#
# Type: list(scope)
#
#   clippy
#     - Required: The label of a clippy target.
#     - Type: label_with_toolchain
#
#   output
#     - Required: The path to the clippy output relative to $root_build_dir
#     - Type: path
#
#   src
#     - Required: The list of rust source files for that target.
#     - Type: List[path] (all relative to $root_build_dir)
#
build_api_module("clippy_target_mapping") {
  testonly = true
  data_keys = [ "rust_source_map" ]
  deps = [ "//:default" ]
}

# Check that all of the drivers included in the image and packages.
# are components and in the all-drivers-list
check_included_drivers("drivers-check") {
  testonly = true
  deps = [
    "//build/images:default-images",
    "//build/images:packages",
  ]
}

# Generates a global documentation file from driver provided documentation.
create_all_drivers_doc("create-all-drivers-doc") {
  testonly = true
  deps = [
    "//build/images:default-images",
    "//build/images:packages",
  ]
}

# Provides a flat list of the artifacts needed for assembly, which should be
# uploaded to CIPD.
#
# Type: list(scope)
#
#   * path
#     - Required: Path to the artifacts file
#     - Type: path relative to $root_build_dir
#
# An artifacts file has the JSON format:
#
# [
#   {
#     "source": "/path/on/host/file.txt",
#     "destination": "path/in/cipd/package/file.txt"
#   },
# ]
#
build_api_module("cipd_assembly_artifacts") {
  testonly = true
  data_keys = [ "assembly_inputs" ]
  walk_keys = [ "assembly_inputs_barrier" ]
  deps = [ "//build/images/fuchsia:fuchsia_assembly" ]
}

# This describes the locations of archives for the out-of-tree assembly inputs
#
# Type: list(scope)
#
#   path
#     Required: Path to the archive file
#     Type: path relative to $root_build_dir
#
#   label
#     Required: label that created the archive
#     Type: GN Label
#
build_api_module("assembly_input_archives") {
  testonly = true
  data_keys = [ "assembly_input_archives" ]
  deps = [ "//build/assembly" ]
}

###
### Top-level targets.
###
group("default") {
  testonly = true
  deps = [
    "//:create-all-drivers-doc",
    "//:host",
    "//build/images:packages",
    "//build/input:build_only",
    "//build/zircon/zbi_tests",
    "//sdk",
  ]

  # SDK-only builds must not attempt to build images.
  if (bootfs_only || base_package_labels + cache_package_labels +
                     universe_package_labels != []) {
    deps += [ "//build/images:default-images" ]
    deps += [ "//:drivers-check" ]
  }
}

# These groups exist at the root of the build so relative labels specified
# through GN args are interpreted as if they were absolute.
group("additional_base_driver_packages") {
  testonly = base_cache_packages_testonly
  visibility = [ "//build/images/*" ]
  public_deps = base_driver_package_labels + board_driver_package_labels
}

group("additional_base_packages") {
  testonly = base_cache_packages_testonly
  visibility = [ "//build/images/*" ]
  public_deps = base_package_labels + board_package_labels
}

group("additional_cache_packages") {
  testonly = base_cache_packages_testonly
  visibility = [ "//build/images/*" ]
  public_deps = cache_package_labels
}

group("additional_universe_packages") {
  testonly = fuchsia_zbi_testonly
  visibility = [ "//build/images/*" ]
  public_deps = universe_package_labels
}

group("host") {
  # TODO(fxbug.dev/80548) investigate removing testonly here
  testonly = true
  public_deps = []
  foreach(label, host_labels) {
    public_deps += [ "$label($host_toolchain)" ]
  }
}

group("recovery_image") {
  # TODO(fxbug.dev/37792): Investigate use of testonly here.
  testonly = true
  deps = [ "build/images/recovery" ]
}

group("package_archive") {
  testonly = true
  public_deps = [ "//build/gn:package_archive" ]
}
