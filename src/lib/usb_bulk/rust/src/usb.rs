// Copyright 2020 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Generated by src/lib/usb_bulk/bindgen.sh using bindgen 0.57.0

// Allow non-conventional naming for imports from C/C++.
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
// TODO(fxbug.dev/74605): Remove once toolchain rolls and deref_nulptr is known.
#![cfg_attr(test, allow(unknown_lints))]
// TODO(fxbug.dev/74605): Remove once bindgen is fixed.
#![cfg_attr(test, allow(deref_nullptr))]

// This attribute ensures proper linkage. Applying it to an empty block to satisfy
// linking requirements for later blocks is explicitly suggested by
// https://doc.rust-lang.org/reference/items/external-blocks.html#the-link-attribute.
#[link(name = "usb_bulk", kind = "static")]
extern "C" {}

// Configure linkage for MacOS.
#[cfg(target_os = "macos")]
#[link(name = "IOKit", kind = "framework")]
#[link(name = "CoreFoundation", kind = "framework")]
extern "C" {}

pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __ssize_t = ::std::os::raw::c_long;
pub type ssize_t = __ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct usb_ifc_info {
    pub dev_vendor: ::std::os::raw::c_ushort,
    pub dev_product: ::std::os::raw::c_ushort,
    pub dev_class: ::std::os::raw::c_uchar,
    pub dev_subclass: ::std::os::raw::c_uchar,
    pub dev_protocol: ::std::os::raw::c_uchar,
    pub ifc_class: ::std::os::raw::c_uchar,
    pub ifc_subclass: ::std::os::raw::c_uchar,
    pub ifc_protocol: ::std::os::raw::c_uchar,
    pub has_bulk_in: ::std::os::raw::c_uchar,
    pub has_bulk_out: ::std::os::raw::c_uchar,
    pub writable: ::std::os::raw::c_uchar,
    pub serial_number: [u8; 256usize],
    pub device_path: [u8; 256usize],
}
#[test]
fn bindgen_test_layout_usb_ifc_info() {
    assert_eq!(
        ::std::mem::size_of::<usb_ifc_info>(),
        526usize,
        concat!("Size of: ", stringify!(usb_ifc_info))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_ifc_info>(),
        2usize,
        concat!("Alignment of ", stringify!(usb_ifc_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ifc_info>())).dev_vendor as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(dev_vendor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ifc_info>())).dev_product as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(dev_product))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ifc_info>())).dev_class as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(dev_class))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ifc_info>())).dev_subclass as *const _ as usize },
        5usize,
        concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(dev_subclass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ifc_info>())).dev_protocol as *const _ as usize },
        6usize,
        concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(dev_protocol))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ifc_info>())).ifc_class as *const _ as usize },
        7usize,
        concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(ifc_class))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ifc_info>())).ifc_subclass as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(ifc_subclass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ifc_info>())).ifc_protocol as *const _ as usize },
        9usize,
        concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(ifc_protocol))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ifc_info>())).has_bulk_in as *const _ as usize },
        10usize,
        concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(has_bulk_in))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ifc_info>())).has_bulk_out as *const _ as usize },
        11usize,
        concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(has_bulk_out))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ifc_info>())).writable as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(writable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ifc_info>())).serial_number as *const _ as usize },
        13usize,
        concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(serial_number))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ifc_info>())).device_path as *const _ as usize },
        269usize,
        concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(device_path))
    );
}
impl Default for usb_ifc_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for usb_ifc_info {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "usb_ifc_info {{ dev_vendor: {:?}, dev_product: {:?}, dev_class: {:?}, dev_subclass: {:?}, dev_protocol: {:?}, ifc_class: {:?}, ifc_subclass: {:?}, ifc_protocol: {:?}, has_bulk_in: {:?}, has_bulk_out: {:?}, writable: {:?}, serial_number: [{}], device_path: [{}] }}" , self . dev_vendor , self . dev_product , self . dev_class , self . dev_subclass , self . dev_protocol , self . ifc_class , self . ifc_subclass , self . ifc_protocol , self . has_bulk_in , self . has_bulk_out , self . writable , self . serial_number . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > () , self . device_path . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > ())
    }
}
pub type ifc_match_func = ::std::option::Option<
    unsafe extern "C" fn(ifc: *mut usb_ifc_info, data: *mut ::std::os::raw::c_void) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UsbInterface {
    _unused: [u8; 0],
}
extern "C" {
    pub fn interface_open(
        callback: ifc_match_func,
        callback_data: *mut ::std::os::raw::c_void,
        timeout_ms: u32,
    ) -> *mut UsbInterface;
}
extern "C" {
    pub fn interface_read(
        interface: *mut UsbInterface,
        data: *mut ::std::os::raw::c_void,
        len: ssize_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn interface_write(
        interface: *mut UsbInterface,
        data: *const ::std::os::raw::c_void,
        len: ssize_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn interface_close(interface: *mut UsbInterface);
}
