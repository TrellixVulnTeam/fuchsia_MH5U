diff --git a/src/boringssl/abort.rs b/src/boringssl/abort.rs
index d422c91..9e2d541 100644
--- a/src/boringssl/abort.rs
+++ b/src/boringssl/abort.rs
@@ -1,8 +1,6 @@
-// Copyright 2018 Google LLC
-//
-// Use of this source code is governed by an MIT-style
-// license that can be found in the LICENSE file or at
-// https://opensource.org/licenses/MIT.
+// Copyright 2019 The Fuchsia Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
 
 //! Macros and functions that abort instead of unwinding.
 //!
diff --git a/src/boringssl/mod.rs b/src/boringssl/mod.rs
index b51a979..186107e 100644
--- a/src/boringssl/mod.rs
+++ b/src/boringssl/mod.rs
@@ -1,8 +1,6 @@
-// Copyright 2018 Google LLC
-//
-// Use of this source code is governed by an MIT-style
-// license that can be found in the LICENSE file or at
-// https://opensource.org/licenses/MIT.
+// Copyright 2019 The Fuchsia Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
 
 //! The BoringSSL API.
 //!
@@ -71,8 +69,6 @@
 // NOTE(joshlf): It's important to define this module before the abort module,
 // or else all of the assertions that are auto-generated by bindgen would result
 // in compilation errors.
-#[path = "../../boringssl/boringssl.rs"]
-mod ffi;
 #[macro_use]
 mod abort;
 #[macro_use]
@@ -80,12 +76,12 @@ mod wrapper;
 mod raw;
 
 // C types
-pub use boringssl::ffi::{
+pub use boringssl_sys::{
     BIGNUM, CBB, CBS, EC_GROUP, EC_KEY, EVP_MD, EVP_PKEY, HMAC_CTX, RSA, RSA_F4, SHA256_CTX,
     SHA512_CTX, SHA_CTX,
 };
 // C constants
-pub use boringssl::ffi::{
+pub use boringssl_sys::{
     NID_X9_62_prime256v1, NID_secp384r1, NID_secp521r1, NID_sha1, NID_sha256, NID_sha384,
     NID_sha512, ED25519_PRIVATE_KEY_LEN, ED25519_PUBLIC_KEY_LEN, ED25519_SIGNATURE_LEN,
     SHA256_DIGEST_LENGTH, SHA384_DIGEST_LENGTH, SHA512_DIGEST_LENGTH, SHA_DIGEST_LENGTH,
@@ -93,12 +89,12 @@ pub use boringssl::ffi::{
 // wrapper types
 pub use boringssl::wrapper::{CHeapWrapper, CRef, CStackWrapper};
 
-use std::convert::TryInto;
 use std::ffi::CStr;
+use std::convert::TryInto;
 use std::fmt::{self, Debug, Display, Formatter};
+use std::mem::MaybeUninit;
 use std::num::NonZeroUsize;
 use std::os::raw::{c_char, c_int, c_uint, c_void};
-use std::mem::MaybeUninit;
 use std::{ptr, slice};
 
 use boringssl::abort::UnwrapAbort;
@@ -530,7 +526,12 @@ impl CStackWrapper<HMAC_CTX> {
         unsafe {
             let mut ctx = MaybeUninit::uninit();
             HMAC_CTX_init(ctx.as_mut_ptr());
-            HMAC_Init_ex(ctx.as_mut_ptr(), key.as_ptr() as *const c_void, key.len(), md.as_const())?;
+            HMAC_Init_ex(
+                ctx.as_mut_ptr(),
+                key.as_ptr() as *const c_void,
+                key.len(),
+                md.as_const(),
+            )?;
             Ok(CStackWrapper::new(ctx.assume_init()))
         }
     }
@@ -761,9 +762,9 @@ macro_rules! impl_hash {
             #[must_use]
             pub fn $final(
                 &mut self,
-            ) -> [u8; ::boringssl::ffi::$digest_len as usize] {
+            ) -> [u8; ::boringssl_sys::$digest_len as usize] {
                 unsafe {
-                    let mut md = MaybeUninit::<[u8; ::boringssl::ffi::$digest_len as usize]>::uninit();
+                    let mut md = MaybeUninit::<[u8; ::boringssl_sys::$digest_len as usize]>::uninit();
                     // SHA1_Final promises to return 1. SHA256_Final,
                     // SHA384_Final, and SHA512_Final all document that they
                     // only fail due to programmer error. The only input to the
diff --git a/src/boringssl/raw.rs b/src/boringssl/raw.rs
index 9ac8fd7..935b97a 100644
--- a/src/boringssl/raw.rs
+++ b/src/boringssl/raw.rs
@@ -1,8 +1,6 @@
-// Copyright 2018 Google LLC
-//
-// Use of this source code is governed by an MIT-style
-// license that can be found in the LICENSE file or at
-// https://opensource.org/licenses/MIT.
+// Copyright 2019 The Fuchsia Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
 
 //! Almost-raw bindings to the BoringSSL API.
 //!
@@ -15,7 +13,7 @@
 //! (e.g., `void` functions).
 
 // infallible functions
-pub use boringssl::ffi::{
+pub use boringssl_sys::{
     CBB_cleanup, CBB_len, CBS_init, CBS_len, CRYPTO_memcmp, EC_GROUP_get_curve_name,
     ED25519_keypair, ED25519_keypair_from_seed, ERR_print_errors_cb, HMAC_CTX_init, HMAC_size,
     RSA_bits,
@@ -26,7 +24,7 @@ use std::num::NonZeroUsize;
 use std::os::raw::{c_char, c_int, c_uint, c_void};
 use std::ptr::{self, NonNull};
 
-use boringssl::ffi::{
+use boringssl_sys::{
     self, BIGNUM, BN_GENCB, CBB, CBS, EC_GROUP, EC_KEY, EVP_MD, EVP_PKEY, HMAC_CTX, RSA, SHA512_CTX,
 };
 
@@ -44,7 +42,7 @@ impl_traits!(BIGNUM, CInit => BN_init, CDestruct => BN_free);
 #[allow(non_snake_case)]
 #[must_use]
 pub unsafe fn BN_set_u64(bn: *mut BIGNUM, value: u64) -> Result<(), BoringError> {
-    one_or_err("BN_set_u64", ffi::BN_set_u64(bn, value))
+    one_or_err("BN_set_u64", boringssl_sys::BN_set_u64(bn, value))
 }
 
 // bytestring.h
@@ -55,13 +53,13 @@ impl_traits!(CBS, CDestruct => _);
 #[allow(non_snake_case)]
 #[must_use]
 pub unsafe fn CBB_init(cbb: *mut CBB, initial_capacity: usize) -> Result<(), BoringError> {
-    one_or_err("CBB_init", ffi::CBB_init(cbb, initial_capacity))
+    one_or_err("CBB_init", boringssl_sys::CBB_init(cbb, initial_capacity))
 }
 
 #[allow(non_snake_case)]
 #[must_use]
 pub unsafe fn CBB_data(cbb: *const CBB) -> Result<NonNull<u8>, BoringError> {
-    ptr_or_err("CBB_init", ffi::CBB_data(cbb) as *mut _)
+    ptr_or_err("CBB_init", boringssl_sys::CBB_data(cbb) as *mut _)
 }
 
 // curve25519.h
@@ -76,7 +74,7 @@ pub unsafe fn ED25519_sign(
 ) -> Result<(), BoringError> {
     one_or_err(
         "ED25519_sign",
-        ffi::ED25519_sign(out as *mut u8, message, message_len, private_key as *const u8),
+        boringssl_sys::ED25519_sign(out as *mut u8, message, message_len, private_key as *const u8),
     )
 }
 
@@ -88,8 +86,12 @@ pub unsafe fn ED25519_verify(
     signature: *const [u8; 64],
     public_key: *const [u8; 32],
 ) -> bool {
-    match ffi::ED25519_verify(message, message_len, signature as *const u8, public_key as *const u8)
-    {
+    match boringssl_sys::ED25519_verify(
+        message,
+        message_len,
+        signature as *const u8,
+        public_key as *const u8,
+    ) {
         0 => false,
         1 => true,
         // ED25519_verify promises to only return 0 or 1
@@ -107,7 +109,7 @@ macro_rules! evp_digest {
             // These return pointers to statically-allocated objects, so should
             // never fail.
             use boringssl::abort::UnwrapAbort;
-            ptr_or_err(stringify!($name), ffi::$name() as *mut _).unwrap_abort()
+            ptr_or_err(stringify!($name), boringssl_sys::$name() as *mut _).unwrap_abort()
         }
     };
 }
@@ -122,7 +124,7 @@ evp_digest!(EVP_sha512);
 #[allow(non_snake_case)]
 #[must_use]
 pub unsafe fn EC_GROUP_new_by_curve_name(nid: c_int) -> Result<NonNull<EC_GROUP>, BoringError> {
-    ptr_or_err("EC_GROUP_new_by_curve_name", ffi::EC_GROUP_new_by_curve_name(nid))
+    ptr_or_err("EC_GROUP_new_by_curve_name", boringssl_sys::EC_GROUP_new_by_curve_name(nid))
 }
 
 // ec_key.h
@@ -133,19 +135,19 @@ impl_traits!(EVP_PKEY, CNew => EVP_PKEY_new, CUpRef => EVP_PKEY_up_ref, CFree =>
 #[allow(non_snake_case)]
 #[must_use]
 pub unsafe fn EC_curve_nid2nist(nid: c_int) -> Result<NonNull<c_char>, BoringError> {
-    ptr_or_err("EC_curve_nid2nist", ffi::EC_curve_nid2nist(nid) as *mut _)
+    ptr_or_err("EC_curve_nid2nist", boringssl_sys::EC_curve_nid2nist(nid) as *mut _)
 }
 
 #[allow(non_snake_case)]
 #[must_use]
 pub unsafe fn EC_KEY_generate_key(key: *mut EC_KEY) -> Result<(), BoringError> {
-    one_or_err("EC_KEY_generate_key", ffi::EC_KEY_generate_key(key))
+    one_or_err("EC_KEY_generate_key", boringssl_sys::EC_KEY_generate_key(key))
 }
 
 #[allow(non_snake_case)]
 #[must_use]
 pub unsafe fn EC_KEY_get0_group(key: *const EC_KEY) -> Result<NonNull<EC_GROUP>, BoringError> {
-    ptr_or_err("EC_KEY_get0_group", ffi::EC_KEY_get0_group(key) as *mut _)
+    ptr_or_err("EC_KEY_get0_group", boringssl_sys::EC_KEY_get0_group(key) as *mut _)
 }
 
 #[allow(non_snake_case)]
@@ -155,7 +157,10 @@ pub unsafe fn EC_KEY_marshal_private_key(
     key: *const EC_KEY,
     enc_flags: c_uint,
 ) -> Result<(), BoringError> {
-    one_or_err("EC_KEY_marshal_private_key", ffi::EC_KEY_marshal_private_key(cbb, key, enc_flags))
+    one_or_err(
+        "EC_KEY_marshal_private_key",
+        boringssl_sys::EC_KEY_marshal_private_key(cbb, key, enc_flags),
+    )
 }
 
 #[allow(non_snake_case)]
@@ -164,7 +169,7 @@ pub unsafe fn EC_KEY_parse_private_key(
     cbs: *mut CBS,
     group: *const EC_GROUP,
 ) -> Result<NonNull<EC_KEY>, BoringError> {
-    ptr_or_err("EC_KEY_parse_private_key", ffi::EC_KEY_parse_private_key(cbs, group))
+    ptr_or_err("EC_KEY_parse_private_key", boringssl_sys::EC_KEY_parse_private_key(cbs, group))
 }
 
 #[allow(non_snake_case)]
@@ -173,7 +178,7 @@ pub unsafe fn EC_KEY_set_group(
     key: *mut EC_KEY,
     group: *const EC_GROUP,
 ) -> Result<(), BoringError> {
-    one_or_err("EC_KEY_set_group", ffi::EC_KEY_set_group(key, group))
+    one_or_err("EC_KEY_set_group", boringssl_sys::EC_KEY_set_group(key, group))
 }
 
 // ecdsa.h
@@ -188,13 +193,17 @@ pub unsafe fn ECDSA_sign(
     sig_len: *mut c_uint,
     key: *const EC_KEY,
 ) -> Result<(), BoringError> {
-    one_or_err("ECDSA_sign", ffi::ECDSA_sign(type_, digest, digest_len, sig, sig_len, key))
+    one_or_err(
+        "ECDSA_sign",
+        boringssl_sys::ECDSA_sign(type_, digest, digest_len, sig, sig_len, key),
+    )
 }
 
 #[allow(non_snake_case)]
 #[must_use]
 pub unsafe fn ECDSA_size(key: *const EC_KEY) -> Result<NonZeroUsize, BoringError> {
-    NonZeroUsize::new(ffi::ECDSA_size(key)).ok_or_else(|| BoringError::consume_stack("ECDSA_size"))
+    NonZeroUsize::new(boringssl_sys::ECDSA_size(key))
+        .ok_or_else(|| BoringError::consume_stack("ECDSA_size"))
 }
 
 #[allow(non_snake_case)]
@@ -207,7 +216,7 @@ pub unsafe fn ECDSA_verify(
     sig_len: usize,
     key: *const EC_KEY,
 ) -> bool {
-    match ffi::ECDSA_verify(type_, digest, digest_len, sig, sig_len, key) {
+    match boringssl_sys::ECDSA_verify(type_, digest, digest_len, sig, sig_len, key) {
         1 => true,
         0 => false,
         // ECDSA_verify promises to only return 0 or 1
@@ -223,13 +232,13 @@ pub unsafe fn EVP_marshal_public_key(
     cbb: *mut CBB,
     key: *const EVP_PKEY,
 ) -> Result<(), BoringError> {
-    one_or_err("EVP_marshal_public_key", ffi::EVP_marshal_public_key(cbb, key))
+    one_or_err("EVP_marshal_public_key", boringssl_sys::EVP_marshal_public_key(cbb, key))
 }
 
 #[allow(non_snake_case)]
 #[must_use]
 pub unsafe fn EVP_parse_public_key(cbs: *mut CBS) -> Result<NonNull<EVP_PKEY>, BoringError> {
-    ptr_or_err("EVP_parse_public_key", ffi::EVP_parse_public_key(cbs))
+    ptr_or_err("EVP_parse_public_key", boringssl_sys::EVP_parse_public_key(cbs))
 }
 
 #[allow(non_snake_case)]
@@ -238,25 +247,25 @@ pub unsafe fn EVP_PKEY_assign_EC_KEY(
     pkey: *mut EVP_PKEY,
     key: *mut EC_KEY,
 ) -> Result<(), BoringError> {
-    one_or_err("EVP_PKEY_assign_EC_KEY", ffi::EVP_PKEY_assign_EC_KEY(pkey, key))
+    one_or_err("EVP_PKEY_assign_EC_KEY", boringssl_sys::EVP_PKEY_assign_EC_KEY(pkey, key))
 }
 
 #[allow(non_snake_case)]
 #[must_use]
 pub unsafe fn EVP_PKEY_assign_RSA(pkey: *mut EVP_PKEY, key: *mut RSA) -> Result<(), BoringError> {
-    one_or_err("EVP_PKEY_assign_RSA", ffi::EVP_PKEY_assign_RSA(pkey, key))
+    one_or_err("EVP_PKEY_assign_RSA", boringssl_sys::EVP_PKEY_assign_RSA(pkey, key))
 }
 
 #[allow(non_snake_case)]
 #[must_use]
 pub unsafe fn EVP_PKEY_get1_EC_KEY(pkey: *mut EVP_PKEY) -> Result<NonNull<EC_KEY>, BoringError> {
-    ptr_or_err("EVP_PKEY_get1_EC_KEY", ffi::EVP_PKEY_get1_EC_KEY(pkey))
+    ptr_or_err("EVP_PKEY_get1_EC_KEY", boringssl_sys::EVP_PKEY_get1_EC_KEY(pkey))
 }
 
 #[allow(non_snake_case)]
 #[must_use]
 pub unsafe fn EVP_PKEY_get1_RSA(pkey: *mut EVP_PKEY) -> Result<NonNull<RSA>, BoringError> {
-    ptr_or_err("EVP_PKEY_get1_RSA", ffi::EVP_PKEY_get1_RSA(pkey))
+    ptr_or_err("EVP_PKEY_get1_RSA", boringssl_sys::EVP_PKEY_get1_RSA(pkey))
 }
 
 #[allow(non_snake_case)]
@@ -276,7 +285,7 @@ pub unsafe fn EVP_PBE_scrypt(
 ) -> Result<(), BoringError> {
     one_or_err(
         "EVP_PBE_scrypt",
-        ffi::EVP_PBE_scrypt(
+        boringssl_sys::EVP_PBE_scrypt(
             password,
             password_len,
             salt,
@@ -307,7 +316,7 @@ pub unsafe fn PKCS5_PBKDF2_HMAC(
 ) -> Result<(), BoringError> {
     one_or_err(
         "PKCS5_PBKDF2_HMAC",
-        ffi::PKCS5_PBKDF2_HMAC(
+        boringssl_sys::PKCS5_PBKDF2_HMAC(
             password,
             password_len,
             salt,
@@ -338,13 +347,13 @@ pub unsafe fn HMAC_Init_ex(
     key_len: usize,
     md: *const EVP_MD,
 ) -> Result<(), BoringError> {
-    one_or_err("HMAC_Init_ex", ffi::HMAC_Init_ex(ctx, key, key_len, md, ptr::null_mut()))
+    one_or_err("HMAC_Init_ex", boringssl_sys::HMAC_Init_ex(ctx, key, key_len, md, ptr::null_mut()))
 }
 
 #[allow(non_snake_case)]
 pub unsafe fn HMAC_Update(ctx: *mut HMAC_CTX, data: *const u8, data_len: usize) {
     // HMAC_Update promises to return 1.
-    assert_abort_eq!(ffi::HMAC_Update(ctx, data, data_len), 1);
+    assert_abort_eq!(boringssl_sys::HMAC_Update(ctx, data, data_len), 1);
 }
 
 #[allow(non_snake_case)]
@@ -354,7 +363,7 @@ pub unsafe fn HMAC_Final(
     out: *mut u8,
     out_len: *mut c_uint,
 ) -> Result<(), BoringError> {
-    one_or_err("HMAC_Final", ffi::HMAC_Final(ctx, out, out_len))
+    one_or_err("HMAC_Final", boringssl_sys::HMAC_Final(ctx, out, out_len))
 }
 
 // rand.h
@@ -362,7 +371,7 @@ pub unsafe fn HMAC_Final(
 #[allow(non_snake_case)]
 pub unsafe fn RAND_bytes(buf: *mut u8, len: usize) {
     // RAND_bytes promises to return 1.
-    assert_abort_eq!(ffi::RAND_bytes(buf, len), 1);
+    assert_abort_eq!(boringssl_sys::RAND_bytes(buf, len), 1);
 }
 
 // rsa.h
@@ -377,19 +386,19 @@ pub unsafe fn RSA_generate_key_ex(
     e: *const BIGNUM,
     cb: *mut BN_GENCB,
 ) -> Result<(), BoringError> {
-    one_or_err("RSA_generate_key_ex", ffi::RSA_generate_key_ex(rsa, bits, e, cb))
+    one_or_err("RSA_generate_key_ex", boringssl_sys::RSA_generate_key_ex(rsa, bits, e, cb))
 }
 
 #[allow(non_snake_case)]
 #[must_use]
 pub unsafe fn RSA_marshal_private_key(cbb: *mut CBB, rsa: *const RSA) -> Result<(), BoringError> {
-    one_or_err("RSA_marshal_private_key", ffi::RSA_marshal_private_key(cbb, rsa))
+    one_or_err("RSA_marshal_private_key", boringssl_sys::RSA_marshal_private_key(cbb, rsa))
 }
 
 #[allow(non_snake_case)]
 #[must_use]
 pub unsafe fn RSA_parse_private_key(cbs: *mut CBS) -> Result<NonNull<RSA>, BoringError> {
-    ptr_or_err("RSA_parse_private_key", ffi::RSA_parse_private_key(cbs))
+    ptr_or_err("RSA_parse_private_key", boringssl_sys::RSA_parse_private_key(cbs))
 }
 
 #[cfg(feature = "rsa-pkcs1v15")]
@@ -403,7 +412,7 @@ pub unsafe fn RSA_sign(
     out_len: *mut c_uint,
     key: *mut RSA,
 ) -> Result<(), BoringError> {
-    one_or_err("RSA_sign", ffi::RSA_sign(hash_nid, in_, in_len, out, out_len, key))
+    one_or_err("RSA_sign", boringssl_sys::RSA_sign(hash_nid, in_, in_len, out, out_len, key))
 }
 
 #[allow(non_snake_case)]
@@ -421,14 +430,16 @@ pub unsafe fn RSA_sign_pss_mgf1(
 ) -> Result<(), BoringError> {
     one_or_err(
         "RSA_sign_pss_mgf1",
-        ffi::RSA_sign_pss_mgf1(rsa, out_len, out, max_out, in_, in_len, md, mgf1_md, salt_len),
+        boringssl_sys::RSA_sign_pss_mgf1(
+            rsa, out_len, out, max_out, in_, in_len, md, mgf1_md, salt_len,
+        ),
     )
 }
 
 #[allow(non_snake_case)]
 #[must_use]
 pub unsafe fn RSA_size(key: *const RSA) -> Result<NonZeroUsize, BoringError> {
-    NonZeroUsize::new(ffi::RSA_size(key).try_into().unwrap_abort())
+    NonZeroUsize::new(boringssl_sys::RSA_size(key).try_into().unwrap_abort())
         .ok_or_else(|| BoringError::consume_stack("RSA_size"))
 }
 
@@ -443,7 +454,7 @@ pub unsafe fn RSA_verify(
     sig_len: usize,
     rsa: *mut RSA,
 ) -> bool {
-    match ffi::RSA_verify(hash_nid, msg, msg_len, sig, sig_len, rsa) {
+    match boringssl_sys::RSA_verify(hash_nid, msg, msg_len, sig, sig_len, rsa) {
         0 => false,
         1 => true,
         // RSA_verify promises to only return 0 or 1
@@ -463,7 +474,8 @@ pub unsafe fn RSA_verify_pss_mgf1(
     sig: *const u8,
     sig_len: usize,
 ) -> bool {
-    match ffi::RSA_verify_pss_mgf1(rsa, msg, msg_len, md, mgf1_md, salt_len, sig, sig_len) {
+    match boringssl_sys::RSA_verify_pss_mgf1(rsa, msg, msg_len, md, mgf1_md, salt_len, sig, sig_len)
+    {
         0 => false,
         1 => true,
         // RSA_verify_pss_mgf1 promises to only return 0 or 1
@@ -476,27 +488,27 @@ pub unsafe fn RSA_verify_pss_mgf1(
 #[allow(non_snake_case)]
 pub unsafe fn SHA384_Init(ctx: *mut SHA512_CTX) {
     // SHA384_Init promises to return 1.
-    assert_abort_eq!(ffi::SHA384_Init(ctx), 1);
+    assert_abort_eq!(boringssl_sys::SHA384_Init(ctx), 1);
 }
 
 // Implemented manually (rather than via impl_traits! or c_init!) so that we can
 // assert_abort_eq! that the return value is 1.
-unsafe impl CInit for ffi::SHA_CTX {
+unsafe impl CInit for boringssl_sys::SHA_CTX {
     unsafe fn init(ctx: *mut Self) {
         // SHA1_Init promises to return 1.
-        assert_abort_eq!(ffi::SHA1_Init(ctx), 1);
+        assert_abort_eq!(boringssl_sys::SHA1_Init(ctx), 1);
     }
 }
-unsafe impl CInit for ffi::SHA256_CTX {
+unsafe impl CInit for boringssl_sys::SHA256_CTX {
     unsafe fn init(ctx: *mut Self) {
         // SHA256_Init promises to return 1.
-        assert_abort_eq!(ffi::SHA256_Init(ctx), 1);
+        assert_abort_eq!(boringssl_sys::SHA256_Init(ctx), 1);
     }
 }
-unsafe impl CInit for ffi::SHA512_CTX {
+unsafe impl CInit for boringssl_sys::SHA512_CTX {
     unsafe fn init(ctx: *mut Self) {
         // SHA512_Init promises to return 1.
-        assert_abort_eq!(ffi::SHA512_Init(ctx), 1);
+        assert_abort_eq!(boringssl_sys::SHA512_Init(ctx), 1);
     }
 }
 
@@ -508,13 +520,16 @@ impl_traits!(SHA512_CTX, CDestruct => _);
 macro_rules! sha {
     ($ctx:ident, $update:ident, $final:ident) => {
         #[allow(non_snake_case)]
-        pub unsafe fn $update(ctx: *mut ffi::$ctx, data: *const c_void, len: usize) {
+        pub unsafe fn $update(ctx: *mut boringssl_sys::$ctx, data: *const c_void, len: usize) {
             // All XXX_Update functions promise to return 1.
-            assert_abort_eq!(ffi::$update(ctx, data, len), 1);
+            assert_abort_eq!(boringssl_sys::$update(ctx, data, len), 1);
         }
         #[allow(non_snake_case)]
-        pub unsafe fn $final(md: *mut u8, ctx: *mut ffi::$ctx) -> Result<(), BoringError> {
-            one_or_err(stringify!($final), ffi::$final(md, ctx))
+        pub unsafe fn $final(
+            md: *mut u8,
+            ctx: *mut boringssl_sys::$ctx,
+        ) -> Result<(), BoringError> {
+            one_or_err(stringify!($final), boringssl_sys::$final(md, ctx))
         }
     };
 }
diff --git a/src/boringssl/wrapper.rs b/src/boringssl/wrapper.rs
index a6953b9..99d8799 100644
--- a/src/boringssl/wrapper.rs
+++ b/src/boringssl/wrapper.rs
@@ -1,8 +1,6 @@
-// Copyright 2018 Google LLC
-//
-// Use of this source code is governed by an MIT-style
-// license that can be found in the LICENSE file or at
-// https://opensource.org/licenses/MIT.
+// Copyright 2019 The Fuchsia Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
 
 use std::marker::PhantomData;
 use std::mem::{self, MaybeUninit};
@@ -18,7 +16,7 @@ pub trait Sealed {}
 
 macro_rules! sealed {
     ($name:ident) => {
-        impl ::boringssl::wrapper::Sealed for ::boringssl::raw::ffi::$name {}
+        impl ::boringssl::wrapper::Sealed for ::boringssl::raw::boringssl_sys::$name {}
     };
 }
 
@@ -65,9 +63,9 @@ pub unsafe trait CNew: Sealed {
 
 macro_rules! c_new {
     ($name:ident, $new:ident) => {
-        unsafe impl ::boringssl::wrapper::CNew for ::boringssl::raw::ffi::$name {
+        unsafe impl ::boringssl::wrapper::CNew for ::boringssl::raw::boringssl_sys::$name {
             unsafe fn new_raw() -> *mut Self {
-                ::boringssl::raw::ffi::$new()
+                ::boringssl::raw::boringssl_sys::$new()
             }
         }
     };
@@ -82,12 +80,12 @@ pub unsafe trait CUpRef: Sealed {
 
 macro_rules! c_up_ref {
     ($name:ident, $up_ref:ident) => {
-        unsafe impl ::boringssl::wrapper::CUpRef for ::boringssl::raw::ffi::$name {
+        unsafe impl ::boringssl::wrapper::CUpRef for ::boringssl::raw::boringssl_sys::$name {
             unsafe fn up_ref(slf: *mut Self) {
                 use boringssl::abort::UnwrapAbort;
                 ::boringssl::raw::one_or_err(
                     stringify!($up_ref),
-                    ::boringssl::raw::ffi::$up_ref(slf),
+                    ::boringssl::raw::boringssl_sys::$up_ref(slf),
                 )
                 .unwrap_abort()
             }
@@ -107,9 +105,9 @@ pub unsafe trait CFree: Sealed {
 
 macro_rules! c_free {
     ($name:ident, $free:ident) => {
-        unsafe impl ::boringssl::wrapper::CFree for ::boringssl::raw::ffi::$name {
+        unsafe impl ::boringssl::wrapper::CFree for ::boringssl::raw::boringssl_sys::$name {
             unsafe fn free(slf: *mut Self) {
-                ::boringssl::raw::ffi::$free(slf)
+                ::boringssl::raw::boringssl_sys::$free(slf)
             }
         }
     };
@@ -128,9 +126,9 @@ pub unsafe trait CInit: Sealed {
 #[allow(unused)] // TODO: Remove once it's used in the 'raw' module
 macro_rules! c_init {
     ($name:ident, $init:ident) => {
-        unsafe impl ::boringssl::wrapper::CInit for ::boringssl::raw::ffi::$name {
+        unsafe impl ::boringssl::wrapper::CInit for ::boringssl::raw::boringssl_sys::$name {
             unsafe fn init(slf: *mut Self) {
-                ::boringssl::raw::ffi::$init(slf)
+                ::boringssl::raw::boringssl_sys::$init(slf)
             }
         }
     };
@@ -149,14 +147,14 @@ pub unsafe trait CDestruct: Sealed {
 
 macro_rules! c_destruct {
     ($name:ident, _) => {
-        unsafe impl ::boringssl::wrapper::CDestruct for ::boringssl::raw::ffi::$name {
+        unsafe impl ::boringssl::wrapper::CDestruct for ::boringssl::raw::boringssl_sys::$name {
             unsafe fn destruct(_slf: *mut Self) {}
         }
     };
     ($name:ident, $destruct:tt) => {
-        unsafe impl ::boringssl::wrapper::CDestruct for ::boringssl::raw::ffi::$name {
+        unsafe impl ::boringssl::wrapper::CDestruct for ::boringssl::raw::boringssl_sys::$name {
             unsafe fn destruct(slf: *mut Self) {
-                ::boringssl::raw::ffi::$destruct(slf)
+                ::boringssl::raw::boringssl_sys::$destruct(slf)
             }
         }
     };
diff --git a/src/bytes.rs b/src/bytes.rs
index f2ef7e0..d46ae16 100644
--- a/src/bytes.rs
+++ b/src/bytes.rs
@@ -1,3 +1,7 @@
+// Copyright 2019 The Fuchsia Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
 //! Byte manipulation.
 
 use boringssl;
diff --git a/src/hash.rs b/src/hash.rs
index 4f2ca68..4cbec1f 100644
--- a/src/hash.rs
+++ b/src/hash.rs
@@ -1,8 +1,6 @@
-// Copyright 2018 Google LLC
-//
-// Use of this source code is governed by an MIT-style
-// license that can be found in the LICENSE file or at
-// https://opensource.org/licenses/MIT.
+// Copyright 2019 The Fuchsia Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
 
 //! Cryptographic hash functions.
 
diff --git a/src/hmac.rs b/src/hmac.rs
index 7db7949..ad4f6b0 100644
--- a/src/hmac.rs
+++ b/src/hmac.rs
@@ -1,8 +1,6 @@
-// Copyright 2018 Google LLC
-//
-// Use of this source code is governed by an MIT-style
-// license that can be found in the LICENSE file or at
-// https://opensource.org/licenses/MIT.
+// Copyright 2019 The Fuchsia Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
 
 //! Hash-based Message Authentication Codes (HMACs).
 
diff --git a/src/insecure.rs b/src/insecure.rs
index e4384ef..2731efd 100644
--- a/src/insecure.rs
+++ b/src/insecure.rs
@@ -1,8 +1,6 @@
-// Copyright 2018 Google LLC
-//
-// Use of this source code is governed by an MIT-style
-// license that can be found in the LICENSE file or at
-// https://opensource.org/licenses/MIT.
+// Copyright 2019 The Fuchsia Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
 
 //! WARNING: INSECURE CRYPTOGRAPHIC OPERATIONS.
 //!
diff --git a/src/kdf.rs b/src/kdf.rs
index 3ed0fb3..098dec9 100644
--- a/src/kdf.rs
+++ b/src/kdf.rs
@@ -1,8 +1,6 @@
-// Copyright 2018 Google LLC
-//
-// Use of this source code is governed by an MIT-style
-// license that can be found in the LICENSE file or at
-// https://opensource.org/licenses/MIT.
+// Copyright 2019 The Fuchsia Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
 
 //! Key Derivation Functions (KDFs).
 //!
diff --git a/src/lib.rs b/src/lib.rs
index 15c4006..ec733da 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,8 +1,6 @@
-// Copyright 2018 Google LLC
-//
-// Use of this source code is governed by an MIT-style
-// license that can be found in the LICENSE file or at
-// https://opensource.org/licenses/MIT.
+// Copyright 2019 The Fuchsia Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
 
 //! Cryptography in Rust.
 //!
@@ -51,6 +49,8 @@
 #[macro_use]
 mod macros;
 
+extern crate boringssl_sys;
+
 // Forbid unsafe code except in the boringssl module.
 #[allow(unsafe_code)]
 mod boringssl;
diff --git a/src/macros.rs b/src/macros.rs
index 4c98d13..9a36be7 100644
--- a/src/macros.rs
+++ b/src/macros.rs
@@ -1,8 +1,6 @@
-// Copyright 2018 Google LLC
-//
-// Use of this source code is governed by an MIT-style
-// license that can be found in the LICENSE file or at
-// https://opensource.org/licenses/MIT.
+// Copyright 2019 The Fuchsia Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
 
 macro_rules! impl_debug {
     ($type:ty, $str:expr) => {
diff --git a/src/password.rs b/src/password.rs
index 1cb32a0..f77bd16 100644
--- a/src/password.rs
+++ b/src/password.rs
@@ -1,8 +1,6 @@
-// Copyright 2018 Google LLC
-//
-// Use of this source code is governed by an MIT-style
-// license that can be found in the LICENSE file or at
-// https://opensource.org/licenses/MIT.
+// Copyright 2019 The Fuchsia Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
 
 //! Password verification.
 
diff --git a/src/public/ec/curve.rs b/src/public/ec/curve.rs
index 8e33e78..2e04f88 100644
--- a/src/public/ec/curve.rs
+++ b/src/public/ec/curve.rs
@@ -1,8 +1,6 @@
-// Copyright 2018 Google LLC
-//
-// Use of this source code is governed by an MIT-style
-// license that can be found in the LICENSE file or at
-// https://opensource.org/licenses/MIT.
+// Copyright 2019 The Fuchsia Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
 
 use std::borrow::Cow;
 use std::fmt::{self, Debug, Display, Formatter};
diff --git a/src/public/ec/mod.rs b/src/public/ec/mod.rs
index 3b8f120..7251445 100644
--- a/src/public/ec/mod.rs
+++ b/src/public/ec/mod.rs
@@ -1,8 +1,6 @@
-// Copyright 2018 Google LLC
-//
-// Use of this source code is governed by an MIT-style
-// license that can be found in the LICENSE file or at
-// https://opensource.org/licenses/MIT.
+// Copyright 2019 The Fuchsia Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
 
 //! Elliptic Curve-based cryptographic algorithms over NIST P curves.
 //!
diff --git a/src/public/ed25519.rs b/src/public/ed25519.rs
index ce253dd..e304b62 100644
--- a/src/public/ed25519.rs
+++ b/src/public/ed25519.rs
@@ -1,8 +1,6 @@
-// Copyright 2018 Google LLC
-//
-// Use of this source code is governed by an MIT-style
-// license that can be found in the LICENSE file or at
-// https://opensource.org/licenses/MIT.
+// Copyright 2019 The Fuchsia Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
 
 //! The Ed25519 signature algorithm.
 
diff --git a/src/public/mod.rs b/src/public/mod.rs
index 574afeb..6445fe9 100644
--- a/src/public/mod.rs
+++ b/src/public/mod.rs
@@ -1,8 +1,6 @@
-// Copyright 2018 Google LLC
-//
-// Use of this source code is governed by an MIT-style
-// license that can be found in the LICENSE file or at
-// https://opensource.org/licenses/MIT.
+// Copyright 2019 The Fuchsia Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
 
 //! Public key cryptography.
 
diff --git a/src/public/rsa/bits.rs b/src/public/rsa/bits.rs
index e0a8d7c..e210aa4 100644
--- a/src/public/rsa/bits.rs
+++ b/src/public/rsa/bits.rs
@@ -1,8 +1,6 @@
-// Copyright 2018 Google LLC
-//
-// Use of this source code is governed by an MIT-style
-// license that can be found in the LICENSE file or at
-// https://opensource.org/licenses/MIT.
+// Copyright 2019 The Fuchsia Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
 
 use std::fmt::{self, Debug, Display, Formatter};
 
diff --git a/src/public/rsa/mod.rs b/src/public/rsa/mod.rs
index bd4b50a..a6ad2c5 100644
--- a/src/public/rsa/mod.rs
+++ b/src/public/rsa/mod.rs
@@ -1,8 +1,6 @@
-// Copyright 2018 Google LLC
-//
-// Use of this source code is governed by an MIT-style
-// license that can be found in the LICENSE file or at
-// https://opensource.org/licenses/MIT.
+// Copyright 2019 The Fuchsia Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
 
 //! The RSA public-key cryptosystem.
 
diff --git a/src/util.rs b/src/util.rs
index 256251c..395ee90 100644
--- a/src/util.rs
+++ b/src/util.rs
@@ -1,8 +1,6 @@
-// Copyright 2018 Google LLC
-//
-// Use of this source code is governed by an MIT-style
-// license that can be found in the LICENSE file or at
-// https://opensource.org/licenses/MIT.
+// Copyright 2019 The Fuchsia Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
 
 /// A trait that can be used to ensure that users of this crate can't implement
 /// a trait.
