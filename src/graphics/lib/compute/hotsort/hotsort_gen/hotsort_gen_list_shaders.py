#!/usr/bin/python
# Copyright 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
"""Generate the list of compute shaders generated by hotsort_gen

The arguments passed to the 'hotsort_gen' code generator determine
the compute shaders that are emitted.

GN requires the list of compute shaders that *will* be generated by
'hotsort_gen' before running or even building it.
"""

from __future__ import print_function

import argparse
import sys

# Note that the inputs to these two functions are the number of
# warps/waves/subgroups supported by a GPU block.
#
# Currently, the largest GPU only supports 2^6 warps per block.


def msb(n):
    """Given an integer >= 0, return the most significant bit position."""
    assert n < 2**32
    c = 0
    while n > 0:
        n >>= 1
        c += 1
    return c


def pow2_ru(n):
    """Given an integer >= 1, return the next power of 2 >= to n."""
    assert n <= 2**31
    n -= 1
    n |= n >> 1
    n |= n >> 2
    n |= n >> 4
    n |= n >> 8
    n |= n >> 16
    n += 1
    return n


#
# Duplicate the shader file generation logic of 'hotsort_gen' for a
# glsl platform target.
#

parser = argparse.ArgumentParser(description=__doc__)

parser.add_argument(
    '-a',
    '--shader-lang',
    choices=('cuda', 'glsl', 'opencl'),
    default='glsl',
    help='Target shader language.')
parser.add_argument(
    '-t',
    '--type-dwords',
    default=1,
    type=int,
    help='Number of 32-bit dwords per sort entry.')
parser.add_argument(
    '-b',
    '--warps-per-group',
    default=1,
    type=int,
    help='Maximum warps in a worgroup/cta/thread block.')
parser.add_argument(
    '-f', '--fm-lo', default=1, type=int, help='Flip merge low scale factor.')
parser.add_argument(
    '-F', '--fm-hi', default=1, type=int, help='Flip merge high scale factor.')
parser.add_argument(
    '-c', '--hm-lo', default=1, type=int, help='Half merge low scale factor.')
parser.add_argument(
    '-C', '--hm-hi', default=1, type=int, help='Half merge high scale factor.')

args = parser.parse_args(sys.argv[1:])

if args.shader_lang == 'cuda':
    # Cuda is easy, there is only one output file.
    print('hs_cuda_u%d.cu' % (32 * args.type_dwords))
    sys.exit(0)

if args.shader_lang == 'opencl':
    # Same for OpenCL
    print('hs_kernel.cl')
    sys.exit(0)

assert (args.shader_lang == 'glsl')

# Now do the GLSL outputs.
warps_per_group = args.warps_per_group
fm_lo = args.fm_lo
fm_hi = args.fm_hi
hm_lo = args.hm_lo
hm_hi = args.hm_hi

#
# BS
#

bs_lo_log = 0
while 1 << bs_lo_log <= warps_per_group:
    print('hs_bs_%d.comp' % bs_lo_log)
    bs_lo_log += 1

#
# BC
#

for nn in range(msb(warps_per_group)):
    print('hs_bc_%d.comp' % nn)

#
# FM
#

for fm_scale in range(fm_lo, fm_hi + 1):
    span_left = (warps_per_group << fm_scale) // 2
    span_left_ru = pow2_ru(span_left)
    span_right = 1
    while span_right <= span_left_ru:
        fm_log = msb(pow2_ru(min(span_left, span_right))) - 1
        print('hs_fm_%d_%d.comp' % (fm_scale, fm_log))
        span_right *= 2

#
# HM
#

for hm_scale in range(hm_lo, hm_hi + 1):
    print('hs_hm_%d.comp' % hm_scale)

#
# EXTRAS
#

print('hs_fill_in.comp')
print('hs_fill_out.comp')
print('hs_transpose.comp')
