// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SRC_DEVELOPER_DEBUG_ZXDB_EXPR_TEMPLATE_TYPE_EXTRACTOR_H_
#define SRC_DEVELOPER_DEBUG_ZXDB_EXPR_TEMPLATE_TYPE_EXTRACTOR_H_

#include <string>
#include <vector>

#include "src/developer/debug/zxdb/common/err.h"

namespace zxdb {

class ExprToken;

// C++ template types are mostly opaque to the debugger and we can't do many transformations on
// them. We don't attempt to fully parse or understand types and require the user to input things
// according to how the symbols represent the names.
//
// But one thing we do need to do is find where the end of a type is for certain expressions such as
// template parameters, and to perform limited canonicalization of those types.
//
// For example, to do a cast:
//   static_cast<Foo::Bar<Something*>>(a)
// We need only understand what the type is enough to look it up in the symbols, and would prefer to
// allow the user flexibility in exactly matching the whitespace generated by the compiler.
//
// There are two parts:
//
//  1. Finding the end of a template type. This tracks things like brackets, parens, and quotes so
//      we know where the end token of the type is. In the above example, this means knowing the
//      second '>' is the terminator.
//
//  2. Canonicalization. The only canonicalization we do is whitespace canonicalization. This comes
//     up most often in spaces after commas in type lists, and whether the ">>" at the end of the
//     above example needs a space separating them or not.

struct TemplateTypeResult {
  bool success = false;

  // When success = false, this is the index of the token for which a terminator was not found. So
  // if there was a '[" with no ']', this will reference the '[' token.
  size_t unmatched_error_token = 0;

  // Token immediately following the extracted type on success. Will be one past the end of the
  // input tokens if everything was consumed.
  size_t end_token = 0;

  // Valid on success.
  std::string canonical_name;
};

TemplateTypeResult ExtractTemplateType(const std::vector<ExprToken>& tokens, size_t begin_token);

}  // namespace zxdb

#endif  // SRC_DEVELOPER_DEBUG_ZXDB_EXPR_TEMPLATE_TYPE_EXTRACTOR_H_
