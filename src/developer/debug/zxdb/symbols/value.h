// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SRC_DEVELOPER_DEBUG_ZXDB_SYMBOLS_VALUE_H_
#define SRC_DEVELOPER_DEBUG_ZXDB_SYMBOLS_VALUE_H_

#include <string>

#include "src/developer/debug/zxdb/symbols/const_value.h"
#include "src/developer/debug/zxdb/symbols/symbol.h"

namespace zxdb {

// A value is the base class for data with names:
//  - Variable: Globals, stack variables, and function parameters.
//  - DataMember: Struct, class, and union members, including static members.
class Value : public Symbol {
 public:
  // Don't construct by itself, used as a base class for Variable and DataMember.

  // Symbol overrides.
  const std::string& GetAssignedName() const final { return assigned_name_; }

  // The name of the variable, parameter, or member name. See
  // Symbol::GetAssignedName().
  void set_assigned_name(const std::string& n) { assigned_name_ = n; }

  // May be incomplete for is_external() values.
  const LazySymbol& type() const { return type_; }
  void set_type(const LazySymbol& t) { type_ = t; }

  // External (DW_AT_external) data members are for static struct data members and extern global
  // variables. They don't have a location. To find these members, look up the full name in the
  // symbol index to get the actual non-external definition.
  //
  // External values might also have different type information. An example is external arrays which
  // won't have a length, but the real definition will have the length. When dealing with external
  // data members, always use the type from the real definition.
  bool is_external() const { return is_external_; }
  void set_is_external(bool e) { is_external_ = e; }

  // Artificial values are ones generated by the compiler that don't appear in the source. The most
  // common example is "this" parameters to functions.  Other examples are GCC-generated "__func__"
  // variables and the discriminant data member in a rust enum.
  bool artificial() const { return artificial_; }
  void set_artificial(bool a) { artificial_ = a; }

  // The variable may have a constant value. If so, const_value().has_value() will be set and the
  // value will be contained within this ConstValue object.
  const ConstValue& const_value() const { return const_value_; }
  void set_const_value(ConstValue cv) { const_value_ = cv; }

  // This could add the decl_file/line if we need it since normally such entries have this
  // information.

 protected:
  explicit Value(DwarfTag tag);
  Value(DwarfTag tag, const std::string& assigned_name, LazySymbol type);
  ~Value();

  // Symbol protected overrides.
  const Value* AsValue() const override;

 private:
  std::string assigned_name_;
  LazySymbol type_;

  bool is_external_ = false;
  bool artificial_ = false;

  ConstValue const_value_;
};

}  // namespace zxdb

#endif  // SRC_DEVELOPER_DEBUG_ZXDB_SYMBOLS_VALUE_H_
