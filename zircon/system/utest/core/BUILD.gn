# Copyright 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/components/fuchsia_unittest_package.gni")
import("//build/test.gni")
import("//build/testing/bootfs_test.gni")
import("//build/testing/zbi_test.gni")

# Each subdirectory just provides an eponymous source_set().
core_tests = [
  "bad-segsel",
  "c11-condvar",
  "c11-mutex",
  "c11-thread",
  "channel-call-etc",
  "channel-iovec",
  "channel-write-etc",
  "clock",
  "event-pair",
  "exceptions",
  "fifo",
  "fpu",
  "futex",
  "handle-close",
  "handle-dup",
  "handle-info",
  "handle-transfer",
  "handle-wait",
  "object-child",
  "object-wait",
  "page-size",
  "pager",
  "port",
  "property",
  "pthread",
  "pthread-barrier",
  "pthread-tls",
  "socket",
  "stack",
  "stream",
  "sync-completion",
  "sync-condition",
  "sync-mutex",
  "syscall-generation",
  "time",
  "version",
]

# Requires use_next_vdso in the manifest. Build as a package and unified bootfs test, but not a
# standalone bootfs test.
# TODO(fxbug.dev/89597): Remove this once standalone bootfs tests can access the next vDSO.
requires_next_vdso = [ "pager-writeback" ]

# zxtest test shuffling breaks these tests. They must be able to pass when the tests are run
# out of order.
# TODO(fxbug.dev/92567): Remove this after fixing the test.
doesnt_work_with_shuffle = [ "elf-tls" ]

# These tests require custom component manifests to execute as components.
core_tests_with_custom_manifests =
    [
      # Some tests require ZX_POL_NEW_PROCESS.
      "channel",
      "memory-mapping",

      # Some tests require ZX_POL_AMBIENT_MARK_VMO_EXEC.
      "vmo",
    ] + requires_next_vdso + doesnt_work_with_shuffle

# These tests need to run in a bootfs environment and can't run as a Fuchsia
# component even with additional configuration.
bootfs_only = [
  # These tests require ZX_POL_NEW_PROCESS for many tests.
  "job",
  "object-info",
  "process",
  "vmar",

  # Some tests new ZX_POL_NEW_PROCESS, and the DebugRegisterState tests on
  # x86_64 fail when run as a component due to DR6 containing unexpected values.
  "threads",
]

# These tests need to run in the unified core-tests binary because
# they either call get_root_resource() or they need to run in a job
# tree without any exception handler.
unified_only = [
  "kernel-unittests",
  "bad-syscall",
  "bti",
  "default-exception-handler",  # needs job tree w/o exception handler.
  "debuglog:unified-only",
  "interrupt",
  "next-vdso",
  "pager-writeback",
  "profile",
  "resource",
  "system-event",
  "system-cpu",

  # These build their own separate test binaries in their own BUILD.gn files,
  # but are also included in the unified standalone test binary.
  "//zircon/system/ulib/c:unittests",
  "//src/lib/elfldltl:unittests",
]
assert(core_tests + core_tests_with_custom_manifests -
           core_tests_with_custom_manifests == core_tests,
       "core_tests and core_tests_with_custom_manifests must be disjoint")
assert(core_tests + bootfs_only - bootfs_only == core_tests,
       "core_tests and bootfs_only must be disjoint")
assert(bootfs_only + core_tests_with_custom_manifests -
           core_tests_with_custom_manifests == bootfs_only,
       "bootfs_only and core_tests_with_custom_manifests must be disjoint")
assert(core_tests + unified_only - unified_only == core_tests,
       "core_tests and unified_only must be disjoint")

all_bootfs_tests = core_tests + core_tests_with_custom_manifests + bootfs_only

# Build each test as a standalone binary meant to be run by runtests.
foreach(test_name, all_bootfs_tests) {
  test(test_name) {
    output_name = "core-$test_name"

    if (is_fuchsia) {
      fdio_config = [ "//build/config/fuchsia:fdio_config" ]
      if (configs + fdio_config - fdio_config != configs) {
        configs -= fdio_config
      }
    }
    deps = [ test_name ]
  }

  bootfs_test("core-$test_name-bootfs-test") {
    name = "core-$test_name"
    deps = [ ":$test_name" ]
  }
}

# Build Fuchsia components and packages for tests that can run by
# fx test.
core_test_packages = []

# These tests can use an autogenerated manifest.
foreach(test_name, core_tests) {
  fuchsia_test_package_name = "core-${test_name}-test-package"
  core_test_packages += [ ":${fuchsia_test_package_name}" ]

  fuchsia_unittest_package(fuchsia_test_package_name) {
    deps = [ ":${test_name}" ]
  }
}

# These tests specify a custom component manifest.
foreach(test_name, core_tests_with_custom_manifests) {
  fuchsia_test_package_name = "core-${test_name}-test-package"
  core_test_packages += [ ":${fuchsia_test_package_name}" ]

  fuchsia_unittest_package(fuchsia_test_package_name) {
    deps = [ ":${test_name}" ]
    manifest = "${test_name}/meta/${test_name}_test.cml"
  }
}

group("tests") {
  testonly = true
  deps = core_test_packages
}

# Now build all of those (and more) together into the core-tests
# binary.  This can and must be run directly from userboot because
# some of the tests require the root resource handle or no system
# services whatsoever.
test("standalone") {
  output_name = "core-standalone-test"

  if (is_fuchsia) {
    configs += [ "//build/config:all_source" ]
  }
  if (is_fuchsia) {
    fdio_config = [ "//build/config/fuchsia:fdio_config" ]
    if (configs + fdio_config - fdio_config != configs) {
      configs -= fdio_config
    }
  }
  deps = all_bootfs_tests + unified_only
  sources = [
    "standalone-init.cc",
    "standalone-io.cc",
    "standalone-options.cc",
    "test-main-with-filter.cc",
  ]
  deps += [
    ":maybe-standalone",
    "//sdk/lib/stdcompat",
    "//zircon/kernel/lib/boot-options",
    "//zircon/system/ulib/lazy_init",
    "//zircon/system/ulib/zbitl",
    "//zircon/system/ulib/zx",
    "//zircon/system/ulib/zxtest",
  ]
}

source_set("maybe-standalone") {
  visibility = [ "./*" ]
  testonly = true
  public = [ "standalone.h" ]
  public_deps = [
    "//zircon/kernel/lib/boot-options",
    "//zircon/system/ulib/zx",
  ]
}

# Make that into a bootable ZBI with just the kernel.
template("core_tests") {
  zbi_test(target_name) {
    assert(current_cpu != "")

    args = [
             "userboot.next=test/core-standalone-test",
             "userboot.shutdown",
             "kernel.vdso.always_use_next=true",
             "kernel.enable-debugging-syscalls=true",
             "kernel.test.ram.reserve=0x8000",
           ] + invoker.args

    deps = [
      ":standalone",
      "//zircon/kernel",
    ]
    assert_no_deps = [
      "//zircon/system/core/*",
      "//zircon/system/dev/*",
    ]

    device_types = invoker.device_types
  }
}

core_tests("core-tests") {
  args = []
  device_types = [
    "AEMU",
    "Astro",
    "QEMU",
    "Intel NUC Kit NUC7i5DNHE",
    "Sherlock",
  ]
}

# If we are building for x64, make sure to run the core tests on a system which
# has been configured to force selection of HPET as the timing source instead
# of choosing TSC if possible.
if (current_cpu == "x64") {
  core_tests("core-tests-hpet") {
    args = [ "kernel.wallclock=hpet" ]
    device_types = [ "Intel NUC Kit NUC7i5DNHE" ]
  }
}
