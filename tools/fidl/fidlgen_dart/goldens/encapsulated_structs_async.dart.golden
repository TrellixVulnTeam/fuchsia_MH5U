// WARNING: This file is machine generated by fidlgen_dart.
// @dart = 2.12

library fidl_test_encapsulatedstructs_async;

import 'dart:async' as $async;
import 'dart:core' hide Set;
import 'dart:developer';
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart' as $zircon;

import 'package:fidl_zx/fidl_async.dart' as lib$zx;
// ignore_for_file: always_specify_types
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: avoid_returning_null
// ignore_for_file: cascade_invocations
// ignore_for_file: constant_identifier_names
// ignore_for_file: directives_ordering
// ignore_for_file: one_member_abstracts
// ignore_for_file: prefer_constructors_over_static_methods
// ignore_for_file: prefer_single_quotes
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: library_prefixes
// ignore_for_file: prefer_typing_uninitialized_variables
// ignore_for_file: avoid_js_rounded_ints
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: prefer_generic_function_type_aliases
// ignore_for_file: prefer_equal_for_default_values
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: unused_shown_name
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: comment_references
// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: prefer_interpolation_to_compose_strings

class Int8Int32 extends $fidl.Struct {
  const Int8Int32({
    required this.a,
    required this.b,
  });
  Int8Int32.clone(
    Int8Int32 $orig, {
    int? a,
    int? b,
  }) : this(
          a: a ?? $orig.a,
          b: b ?? $orig.b,
        );

  final int a;
  final int b;

  @override
  List<Object?> get $fields {
    return <Object?>[
      a,
      b,
    ];
  }

  static const $fieldType0 = $fidl.Int8Type();
  static const $fieldType1 = $fidl.Int32Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    switch ($encoder.wireFormat) {
      case $fidl.WireFormat.v1:
        $fieldType0.encode($encoder, a, $offset + 0, $depth);
        $fieldType1.encode($encoder, b, $offset + 4, $depth);
        break;
      case $fidl.WireFormat.v2:
        $fieldType0.encode($encoder, a, $offset + 0, $depth);
        $fieldType1.encode($encoder, b, $offset + 4, $depth);
        break;
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }

  static Int8Int32 _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v1:
        $decoder.checkPadding($offset + 1, 3);
        return Int8Int32(
            a: $fieldType0.decode($decoder, $offset + 0, $depth),
            b: $fieldType1.decode($decoder, $offset + 4, $depth));
      case $fidl.WireFormat.v2:
        $decoder.checkPadding($offset + 1, 3);
        return Int8Int32(
            a: $fieldType0.decode($decoder, $offset + 0, $depth),
            b: $fieldType1.decode($decoder, $offset + 4, $depth));
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<Int8Int32> kInt8Int32_Type = $fidl.StructType<Int8Int32>(
    inlineSizeV1: 8, inlineSizeV2: 8, structDecode: Int8Int32._structDecode);

class Int16Int8 extends $fidl.Struct {
  const Int16Int8({
    required this.a,
    required this.b,
  });
  Int16Int8.clone(
    Int16Int8 $orig, {
    int? a,
    int? b,
  }) : this(
          a: a ?? $orig.a,
          b: b ?? $orig.b,
        );

  final int a;
  final int b;

  @override
  List<Object?> get $fields {
    return <Object?>[
      a,
      b,
    ];
  }

  static const $fieldType0 = $fidl.Int16Type();
  static const $fieldType1 = $fidl.Int8Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    switch ($encoder.wireFormat) {
      case $fidl.WireFormat.v1:
        $fieldType0.encode($encoder, a, $offset + 0, $depth);
        $fieldType1.encode($encoder, b, $offset + 2, $depth);
        break;
      case $fidl.WireFormat.v2:
        $fieldType0.encode($encoder, a, $offset + 0, $depth);
        $fieldType1.encode($encoder, b, $offset + 2, $depth);
        break;
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }

  static Int16Int8 _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v1:
        $decoder.checkPadding($offset + 3, 1);
        return Int16Int8(
            a: $fieldType0.decode($decoder, $offset + 0, $depth),
            b: $fieldType1.decode($decoder, $offset + 2, $depth));
      case $fidl.WireFormat.v2:
        $decoder.checkPadding($offset + 3, 1);
        return Int16Int8(
            a: $fieldType0.decode($decoder, $offset + 0, $depth),
            b: $fieldType1.decode($decoder, $offset + 2, $depth));
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<Int16Int8> kInt16Int8_Type = $fidl.StructType<Int16Int8>(
    inlineSizeV1: 4, inlineSizeV2: 4, structDecode: Int16Int8._structDecode);

class ArrayInt16Int8 extends $fidl.Struct {
  const ArrayInt16Int8({
    required this.arr,
  });
  ArrayInt16Int8.clone(
    ArrayInt16Int8 $orig, {
    List<Int16Int8>? arr,
  }) : this(
          arr: arr ?? $orig.arr,
        );

  final List<Int16Int8> arr;

  @override
  List<Object?> get $fields {
    return <Object?>[
      arr,
    ];
  }

  static const $fieldType0 = $fidl.ArrayType<Int16Int8, List<Int16Int8>>(
      element: kInt16Int8_Type, elementCount: 3);

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    switch ($encoder.wireFormat) {
      case $fidl.WireFormat.v1:
        $fieldType0.encode($encoder, arr, $offset + 0, $depth);
        break;
      case $fidl.WireFormat.v2:
        $fieldType0.encode($encoder, arr, $offset + 0, $depth);
        break;
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }

  static ArrayInt16Int8 _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v1:
        return ArrayInt16Int8(
            arr: $fieldType0.decode($decoder, $offset + 0, $depth));
      case $fidl.WireFormat.v2:
        return ArrayInt16Int8(
            arr: $fieldType0.decode($decoder, $offset + 0, $depth));
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<ArrayInt16Int8> kArrayInt16Int8_Type =
    $fidl.StructType<ArrayInt16Int8>(
        inlineSizeV1: 12,
        inlineSizeV2: 12,
        structDecode: ArrayInt16Int8._structDecode);

class StructPaddingTestStruct extends $fidl.Struct {
  const StructPaddingTestStruct({
    required this.trailing,
    required this.inner,
    required this.array,
  });
  StructPaddingTestStruct.clone(
    StructPaddingTestStruct $orig, {
    Int16Int8? trailing,
    Int8Int32? inner,
    ArrayInt16Int8? array,
  }) : this(
          trailing: trailing ?? $orig.trailing,
          inner: inner ?? $orig.inner,
          array: array ?? $orig.array,
        );

  final Int16Int8 trailing;
  final Int8Int32 inner;
  final ArrayInt16Int8 array;

  @override
  List<Object?> get $fields {
    return <Object?>[
      trailing,
      inner,
      array,
    ];
  }

  static const $fieldType0 = kInt16Int8_Type;
  static const $fieldType1 = kInt8Int32_Type;
  static const $fieldType2 = kArrayInt16Int8_Type;

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    switch ($encoder.wireFormat) {
      case $fidl.WireFormat.v1:
        $fieldType0.encode($encoder, trailing, $offset + 0, $depth);
        $fieldType1.encode($encoder, inner, $offset + 4, $depth);
        $fieldType2.encode($encoder, array, $offset + 12, $depth);
        break;
      case $fidl.WireFormat.v2:
        $fieldType0.encode($encoder, trailing, $offset + 0, $depth);
        $fieldType1.encode($encoder, inner, $offset + 4, $depth);
        $fieldType2.encode($encoder, array, $offset + 12, $depth);
        break;
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }

  static StructPaddingTestStruct _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v1:
        return StructPaddingTestStruct(
            trailing: $fieldType0.decode($decoder, $offset + 0, $depth),
            inner: $fieldType1.decode($decoder, $offset + 4, $depth),
            array: $fieldType2.decode($decoder, $offset + 12, $depth));
      case $fidl.WireFormat.v2:
        return StructPaddingTestStruct(
            trailing: $fieldType0.decode($decoder, $offset + 0, $depth),
            inner: $fieldType1.decode($decoder, $offset + 4, $depth),
            array: $fieldType2.decode($decoder, $offset + 12, $depth));
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<StructPaddingTestStruct> kStructPaddingTestStruct_Type =
    $fidl.StructType<StructPaddingTestStruct>(
        inlineSizeV1: 24,
        inlineSizeV2: 24,
        structDecode: StructPaddingTestStruct._structDecode);

class NonInlineStructTestStruct extends $fidl.Struct {
  const NonInlineStructTestStruct({
    this.element,
    required this.h,
  });
  NonInlineStructTestStruct.clone(
    NonInlineStructTestStruct $orig, {
    Int16Int8? element,
    $zircon.Handle? h,
  }) : this(
          element: element ?? $orig.element,
          h: h ?? $orig.h,
        );

  NonInlineStructTestStruct.cloneWithout(
    NonInlineStructTestStruct $orig, {
    bool element = false,
  }) : this(
          element: element ? null : $orig.element,
          h: $orig.h,
        );

  final Int16Int8? element;
  final $zircon.Handle h;

  @override
  List<Object?> get $fields {
    return <Object?>[
      element,
      h,
    ];
  }

  static const $fieldType0 =
      $fidl.PointerType<Int16Int8>(element: kInt16Int8_Type);
  static const $fieldType1 =
      $fidl.HandleType(objectType: 0, rights: 2147483648);

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    switch ($encoder.wireFormat) {
      case $fidl.WireFormat.v1:
        $fieldType0.encode($encoder, element, $offset + 0, $depth);
        $fieldType1.encode($encoder, h, $offset + 8, $depth);
        break;
      case $fidl.WireFormat.v2:
        $fieldType0.encode($encoder, element, $offset + 0, $depth);
        $fieldType1.encode($encoder, h, $offset + 8, $depth);
        break;
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }

  static NonInlineStructTestStruct _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v1:
        $decoder.checkPadding($offset + 12, 4);
        return NonInlineStructTestStruct(
            element: $fieldType0.decode($decoder, $offset + 0, $depth),
            h: $fieldType1.decode($decoder, $offset + 8, $depth));
      case $fidl.WireFormat.v2:
        $decoder.checkPadding($offset + 12, 4);
        return NonInlineStructTestStruct(
            element: $fieldType0.decode($decoder, $offset + 0, $depth),
            h: $fieldType1.decode($decoder, $offset + 8, $depth));
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<NonInlineStructTestStruct>
    kNonInlineStructTestStruct_Type =
    $fidl.StructType<NonInlineStructTestStruct>(
        inlineSizeV1: 16,
        inlineSizeV2: 16,
        structDecode: NonInlineStructTestStruct._structDecode);

class TopLevelStruct extends $fidl.Struct {
  const TopLevelStruct({
    required this.a,
    required this.b,
  });
  TopLevelStruct.clone(
    TopLevelStruct $orig, {
    StructPaddingTestStruct? a,
    NonInlineStructTestStruct? b,
  }) : this(
          a: a ?? $orig.a,
          b: b ?? $orig.b,
        );

  final StructPaddingTestStruct a;
  final NonInlineStructTestStruct b;

  @override
  List<Object?> get $fields {
    return <Object?>[
      a,
      b,
    ];
  }

  static const $fieldType0 = kStructPaddingTestStruct_Type;
  static const $fieldType1 = kNonInlineStructTestStruct_Type;

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    switch ($encoder.wireFormat) {
      case $fidl.WireFormat.v1:
        $fieldType0.encode($encoder, a, $offset + 0, $depth);
        $fieldType1.encode($encoder, b, $offset + 24, $depth);
        break;
      case $fidl.WireFormat.v2:
        $fieldType0.encode($encoder, a, $offset + 0, $depth);
        $fieldType1.encode($encoder, b, $offset + 24, $depth);
        break;
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }

  static TopLevelStruct _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v1:
        return TopLevelStruct(
            a: $fieldType0.decode($decoder, $offset + 0, $depth),
            b: $fieldType1.decode($decoder, $offset + 24, $depth));
      case $fidl.WireFormat.v2:
        return TopLevelStruct(
            a: $fieldType0.decode($decoder, $offset + 0, $depth),
            b: $fieldType1.decode($decoder, $offset + 24, $depth));
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<TopLevelStruct> kTopLevelStruct_Type =
    $fidl.StructType<TopLevelStruct>(
        inlineSizeV1: 40,
        inlineSizeV2: 40,
        structDecode: TopLevelStruct._structDecode);
