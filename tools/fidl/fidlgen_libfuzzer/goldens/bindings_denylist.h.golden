// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <test/bindingsdenylist/cpp/fidl.h>
#include <test/dependent/cpp/libfuzzer.h>

#include "lib/fidl/cpp/fuzzing/traits.h"
#include "lib/fidl/cpp/internal/header.h"
// For ::std::max_element().
#include <algorithm>
// For uint64_t.
#include <stdint.h>

namespace fuzzing {

using MemberOnlyAppearsInImportingLibrary =
    ::test::bindingsdenylist::MemberOnlyAppearsInImportingLibrary;
using OnlyAppearsInImportingLibrary =
    ::test::bindingsdenylist::OnlyAppearsInImportingLibrary;
using DenyEachBinding_OnlyDenySyzkaller_Response =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Response;
using DenyEachBinding_OnlyDenySyzkaller_Result =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result;
using DenyEachBinding_OnlyDenyRust_Response =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenyRust_Response;
using DenyEachBinding_OnlyDenyRust_Result =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result;
using DenyEachBinding_OnlyDenyGo_Response =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenyGo_Response;
using DenyEachBinding_OnlyDenyGo_Result =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result;
using DenyEachBinding_OnlyDenyDart_Response =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenyDart_Response;
using DenyEachBinding_OnlyDenyDart_Result =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result;
using DenyEachBinding_OnlyDenyCpp_Response =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenyCpp_Response;
using DenyEachBinding_OnlyDenyCpp_Result =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenyCpp_Result;

template <>
struct MinSize<MemberOnlyAppearsInImportingLibrary> {
  operator size_t() { return MinSize<bool>(); }
};
template <>
struct Allocate<MemberOnlyAppearsInImportingLibrary> {
  MemberOnlyAppearsInImportingLibrary operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<MemberOnlyAppearsInImportingLibrary>());
    MemberOnlyAppearsInImportingLibrary out;
    const size_t slack_per_member =
        (*size - MinSize<MemberOnlyAppearsInImportingLibrary>()) / 1;
    size_t out_size;
    out_size = MinSize<bool>() + slack_per_member;
    out.a = Allocate<bool>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<OnlyAppearsInImportingLibrary> {
  operator size_t() {
    return MinSize<
        ::test::bindingsdenylist::MemberOnlyAppearsInImportingLibrary>();
  }
};
template <>
struct Allocate<OnlyAppearsInImportingLibrary> {
  OnlyAppearsInImportingLibrary operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<OnlyAppearsInImportingLibrary>());
    OnlyAppearsInImportingLibrary out;
    const size_t slack_per_member =
        (*size - MinSize<OnlyAppearsInImportingLibrary>()) / 1;
    size_t out_size;
    out_size =
        MinSize<
            ::test::bindingsdenylist::MemberOnlyAppearsInImportingLibrary>() +
        slack_per_member;
    out.member_only_appears_in_importing_library = Allocate<
        ::test::bindingsdenylist::MemberOnlyAppearsInImportingLibrary>{}(
        src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenySyzkaller_Response> {
  operator size_t() { return MinSize<int32_t>(); }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenySyzkaller_Response> {
  DenyEachBinding_OnlyDenySyzkaller_Response operator()(FuzzInput* src,
                                                        size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenySyzkaller_Response>());
    DenyEachBinding_OnlyDenySyzkaller_Response out;
    const size_t slack_per_member =
        (*size - MinSize<DenyEachBinding_OnlyDenySyzkaller_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.b = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenySyzkaller_Result> {
  operator size_t() {
    size_t sizes[] = {0,
                      MinSize<::test::bindingsdenylist::
                                  DenyEachBinding_OnlyDenySyzkaller_Response>(),
                      MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenySyzkaller_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  DenyEachBinding_OnlyDenySyzkaller_Result operator()(FuzzInput* src,
                                                      size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenySyzkaller_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    DenyEachBinding_OnlyDenySyzkaller_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(
            Allocate<::test::bindingsdenylist::
                         DenyEachBinding_OnlyDenySyzkaller_Response>{}(src,
                                                                       size));
        break;
      }
      case 1: {
        out.set_err(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyRust_Response> {
  operator size_t() { return MinSize<int32_t>(); }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyRust_Response> {
  DenyEachBinding_OnlyDenyRust_Response operator()(FuzzInput* src,
                                                   size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyRust_Response>());
    DenyEachBinding_OnlyDenyRust_Response out;
    const size_t slack_per_member =
        (*size - MinSize<DenyEachBinding_OnlyDenyRust_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.b = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyRust_Result> {
  operator size_t() {
    size_t sizes[] = {
        0,
        MinSize<
            ::test::bindingsdenylist::DenyEachBinding_OnlyDenyRust_Response>(),
        MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyRust_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  DenyEachBinding_OnlyDenyRust_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyRust_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    DenyEachBinding_OnlyDenyRust_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(
            Allocate<::test::bindingsdenylist::
                         DenyEachBinding_OnlyDenyRust_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyGo_Response> {
  operator size_t() { return MinSize<int32_t>(); }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyGo_Response> {
  DenyEachBinding_OnlyDenyGo_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyGo_Response>());
    DenyEachBinding_OnlyDenyGo_Response out;
    const size_t slack_per_member =
        (*size - MinSize<DenyEachBinding_OnlyDenyGo_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.b = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyGo_Result> {
  operator size_t() {
    size_t sizes[] = {
        0,
        MinSize<
            ::test::bindingsdenylist::DenyEachBinding_OnlyDenyGo_Response>(),
        MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyGo_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  DenyEachBinding_OnlyDenyGo_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyGo_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    DenyEachBinding_OnlyDenyGo_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(
            Allocate<::test::bindingsdenylist::
                         DenyEachBinding_OnlyDenyGo_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyDart_Response> {
  operator size_t() { return MinSize<int32_t>(); }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyDart_Response> {
  DenyEachBinding_OnlyDenyDart_Response operator()(FuzzInput* src,
                                                   size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyDart_Response>());
    DenyEachBinding_OnlyDenyDart_Response out;
    const size_t slack_per_member =
        (*size - MinSize<DenyEachBinding_OnlyDenyDart_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.b = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyDart_Result> {
  operator size_t() {
    size_t sizes[] = {
        0,
        MinSize<
            ::test::bindingsdenylist::DenyEachBinding_OnlyDenyDart_Response>(),
        MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyDart_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  DenyEachBinding_OnlyDenyDart_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyDart_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    DenyEachBinding_OnlyDenyDart_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(
            Allocate<::test::bindingsdenylist::
                         DenyEachBinding_OnlyDenyDart_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyCpp_Response> {
  operator size_t() { return MinSize<int32_t>(); }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyCpp_Response> {
  DenyEachBinding_OnlyDenyCpp_Response operator()(FuzzInput* src,
                                                  size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyCpp_Response>());
    DenyEachBinding_OnlyDenyCpp_Response out;
    const size_t slack_per_member =
        (*size - MinSize<DenyEachBinding_OnlyDenyCpp_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.b = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyCpp_Result> {
  operator size_t() {
    size_t sizes[] = {
        0,
        MinSize<
            ::test::bindingsdenylist::DenyEachBinding_OnlyDenyCpp_Response>(),
        MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyCpp_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  DenyEachBinding_OnlyDenyCpp_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyCpp_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    DenyEachBinding_OnlyDenyCpp_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(
            Allocate<::test::bindingsdenylist::
                         DenyEachBinding_OnlyDenyCpp_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};

}  // namespace fuzzing
