// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/envelope.h>
#include <lib/fidl/llcpp/message.h>
#include <lib/fidl/llcpp/message_storage.h>
#include <lib/fidl/llcpp/object_view.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/wire_types.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>
#ifdef __Fuchsia__
#include <lib/zx/channel.h>

#endif  // __Fuchsia__

#include <fidl/test.bindingsdenylist/cpp/common_types.h>
#include <fidl/test.bindingsdenylist/cpp/markers.h>
#include <fidl/test.dependent/cpp/wire_types.h>

namespace test_bindingsdenylist {
namespace wire {
struct MemberOnlyAppearsInImportingLibrary;

struct OnlyAppearsInImportingLibrary;

struct DenyEachBindingOnlyDenySyzkallerResponse;

struct DenyEachBindingOnlyDenyRustResponse;

struct DenyEachBindingOnlyDenyLibfuzzerResponse;

struct DenyEachBindingOnlyDenyGoResponse;

struct DenyEachBindingOnlyDenyDartResponse;

class OnlyLlcpp;

class DenyEachBindingOnlyDenySyzkallerResult;

class DenyEachBindingOnlyDenyRustResult;

class DenyEachBindingOnlyDenyLibfuzzerResult;

class DenyEachBindingOnlyDenyGoResult;

class DenyEachBindingOnlyDenyDartResult;

extern "C" const fidl_type_t
    test_bindingsdenylist_MemberOnlyAppearsInImportingLibraryTable;

struct MemberOnlyAppearsInImportingLibrary {
  bool a = {};
};

extern "C" const fidl_type_t
    test_bindingsdenylist_OnlyAppearsInImportingLibraryTable;

struct OnlyAppearsInImportingLibrary {
  using MemberOnlyAppearsInImportingLibrary =
      test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary;

  ::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary
      member_only_appears_in_importing_library = {};
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenySyzkaller_ResponseTable;

struct DenyEachBindingOnlyDenySyzkallerResponse {
  int32_t b = {};
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyRust_ResponseTable;

struct DenyEachBindingOnlyDenyRustResponse {
  int32_t b = {};
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyLibfuzzer_ResponseTable;

struct DenyEachBindingOnlyDenyLibfuzzerResponse {
  int32_t b = {};
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyGo_ResponseTable;

struct DenyEachBindingOnlyDenyGoResponse {
  int32_t b = {};
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyDart_ResponseTable;

struct DenyEachBindingOnlyDenyDartResponse {
  int32_t b = {};
};

extern "C" const fidl_type_t test_bindingsdenylist_OnlyLlcppTable;

class OnlyLlcpp {
 public:
  OnlyLlcpp()
      : ordinal_(::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal::Invalid),
        envelope_ {}
  {}

  OnlyLlcpp(const OnlyLlcpp&) = default;
  OnlyLlcpp& operator=(const OnlyLlcpp&) = default;
  OnlyLlcpp(OnlyLlcpp&&) = default;
  OnlyLlcpp& operator=(OnlyLlcpp&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kX = 1,  // 0x1
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal::Invalid;
  }

  bool is_x() const {
    return ordinal_ == ::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal::kX;
  }
  static OnlyLlcpp WithX(uint32_t val) {
    OnlyLlcpp result;
    result.set_x(std::move(val));
    return result;
  }

  void set_x(uint32_t elem) {
    ordinal_ = ::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal::kX;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& x() {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal::kX);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& x() const {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal::kX);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_bindingsdenylist::wire::OnlyLlcpp::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_bindingsdenylist::wire::OnlyLlcpp::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kX = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenySyzkaller_ResultTable;

class DenyEachBindingOnlyDenySyzkallerResult {
 public:
  using Response =
      test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse;

  DenyEachBindingOnlyDenySyzkallerResult()
      : ordinal_(::test_bindingsdenylist::wire::
                     DenyEachBindingOnlyDenySyzkallerResult::Ordinal::Invalid),
        envelope_ {}
  {}

  DenyEachBindingOnlyDenySyzkallerResult(
      const DenyEachBindingOnlyDenySyzkallerResult&) = default;
  DenyEachBindingOnlyDenySyzkallerResult& operator=(
      const DenyEachBindingOnlyDenySyzkallerResult&) = default;
  DenyEachBindingOnlyDenySyzkallerResult(
      DenyEachBindingOnlyDenySyzkallerResult&&) = default;
  DenyEachBindingOnlyDenySyzkallerResult& operator=(
      DenyEachBindingOnlyDenySyzkallerResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::
               DenyEachBindingOnlyDenySyzkallerResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::
               DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kResponse;
  }
  static DenyEachBindingOnlyDenySyzkallerResult WithResponse(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse
          val) {
    DenyEachBindingOnlyDenySyzkallerResult result;
    result.set_response(std::move(val));
    return result;
  }

  void set_response(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse
          elem) {
    ordinal_ = ::test_bindingsdenylist::wire::
        DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kResponse;
    envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenySyzkallerResponse>()
        .set_data(std::move(elem));
  }

  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse&
  response() {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::
                  DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenySyzkallerResponse>()
        .get_data();
  }
  const ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::
                  DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenySyzkallerResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::
               DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kErr;
  }
  static DenyEachBindingOnlyDenySyzkallerResult WithErr(uint32_t val) {
    DenyEachBindingOnlyDenySyzkallerResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_bindingsdenylist::wire::
        DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::
                  DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::
                  DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Tag
  Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenySyzkallerResult::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyRust_ResultTable;

class DenyEachBindingOnlyDenyRustResult {
 public:
  using Response =
      test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse;

  DenyEachBindingOnlyDenyRustResult()
      : ordinal_(::test_bindingsdenylist::wire::
                     DenyEachBindingOnlyDenyRustResult::Ordinal::Invalid),
        envelope_ {}
  {}

  DenyEachBindingOnlyDenyRustResult(const DenyEachBindingOnlyDenyRustResult&) =
      default;
  DenyEachBindingOnlyDenyRustResult& operator=(
      const DenyEachBindingOnlyDenyRustResult&) = default;
  DenyEachBindingOnlyDenyRustResult(DenyEachBindingOnlyDenyRustResult&&) =
      default;
  DenyEachBindingOnlyDenyRustResult& operator=(
      DenyEachBindingOnlyDenyRustResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenyRustResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::
               Ordinal::kResponse;
  }
  static DenyEachBindingOnlyDenyRustResult WithResponse(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse val) {
    DenyEachBindingOnlyDenyRustResult result;
    result.set_response(std::move(val));
    return result;
  }

  void set_response(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse elem) {
    ordinal_ = ::test_bindingsdenylist::wire::
        DenyEachBindingOnlyDenyRustResult::Ordinal::kResponse;
    envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenyRustResponse>()
        .set_data(std::move(elem));
  }

  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse&
  response() {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenyRustResponse>()
        .get_data();
  }
  const ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenyRustResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenyRustResult::Ordinal::kErr;
  }
  static DenyEachBindingOnlyDenyRustResult WithErr(uint32_t val) {
    DenyEachBindingOnlyDenyRustResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_bindingsdenylist::wire::
        DenyEachBindingOnlyDenyRustResult::Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              DenyEachBindingOnlyDenyRustResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              DenyEachBindingOnlyDenyRustResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Tag Which()
      const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyLibfuzzer_ResultTable;

class DenyEachBindingOnlyDenyLibfuzzerResult {
 public:
  using Response =
      test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResponse;

  DenyEachBindingOnlyDenyLibfuzzerResult()
      : ordinal_(::test_bindingsdenylist::wire::
                     DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::Invalid),
        envelope_ {}
  {}

  DenyEachBindingOnlyDenyLibfuzzerResult(
      const DenyEachBindingOnlyDenyLibfuzzerResult&) = default;
  DenyEachBindingOnlyDenyLibfuzzerResult& operator=(
      const DenyEachBindingOnlyDenyLibfuzzerResult&) = default;
  DenyEachBindingOnlyDenyLibfuzzerResult(
      DenyEachBindingOnlyDenyLibfuzzerResult&&) = default;
  DenyEachBindingOnlyDenyLibfuzzerResult& operator=(
      DenyEachBindingOnlyDenyLibfuzzerResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::
               DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::
               DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::kResponse;
  }
  static DenyEachBindingOnlyDenyLibfuzzerResult WithResponse(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResponse
          val) {
    DenyEachBindingOnlyDenyLibfuzzerResult result;
    result.set_response(std::move(val));
    return result;
  }

  void set_response(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResponse
          elem) {
    ordinal_ = ::test_bindingsdenylist::wire::
        DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::kResponse;
    envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenyLibfuzzerResponse>()
        .set_data(std::move(elem));
  }

  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResponse&
  response() {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::
                  DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenyLibfuzzerResponse>()
        .get_data();
  }
  const ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::
                  DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenyLibfuzzerResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::
               DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::kErr;
  }
  static DenyEachBindingOnlyDenyLibfuzzerResult WithErr(uint32_t val) {
    DenyEachBindingOnlyDenyLibfuzzerResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_bindingsdenylist::wire::
        DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::
                  DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::
                  DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResult::Tag
  Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenyLibfuzzerResult::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyGo_ResultTable;

class DenyEachBindingOnlyDenyGoResult {
 public:
  using Response =
      test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse;

  DenyEachBindingOnlyDenyGoResult()
      : ordinal_(::test_bindingsdenylist::wire::
                     DenyEachBindingOnlyDenyGoResult::Ordinal::Invalid),
        envelope_ {}
  {}

  DenyEachBindingOnlyDenyGoResult(const DenyEachBindingOnlyDenyGoResult&) =
      default;
  DenyEachBindingOnlyDenyGoResult& operator=(
      const DenyEachBindingOnlyDenyGoResult&) = default;
  DenyEachBindingOnlyDenyGoResult(DenyEachBindingOnlyDenyGoResult&&) = default;
  DenyEachBindingOnlyDenyGoResult& operator=(
      DenyEachBindingOnlyDenyGoResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenyGoResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenyGoResult::Ordinal::kResponse;
  }
  static DenyEachBindingOnlyDenyGoResult WithResponse(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse val) {
    DenyEachBindingOnlyDenyGoResult result;
    result.set_response(std::move(val));
    return result;
  }

  void set_response(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse elem) {
    ordinal_ = ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::
        Ordinal::kResponse;
    envelope_
        .As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse>()
        .set_data(std::move(elem));
  }

  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse& response() {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse>()
        .get_data();
  }
  const ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenyGoResult::Ordinal::kErr;
  }
  static DenyEachBindingOnlyDenyGoResult WithErr(uint32_t val) {
    DenyEachBindingOnlyDenyGoResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::
        Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              DenyEachBindingOnlyDenyGoResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              DenyEachBindingOnlyDenyGoResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Tag Which()
      const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyDart_ResultTable;

class DenyEachBindingOnlyDenyDartResult {
 public:
  using Response =
      test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse;

  DenyEachBindingOnlyDenyDartResult()
      : ordinal_(::test_bindingsdenylist::wire::
                     DenyEachBindingOnlyDenyDartResult::Ordinal::Invalid),
        envelope_ {}
  {}

  DenyEachBindingOnlyDenyDartResult(const DenyEachBindingOnlyDenyDartResult&) =
      default;
  DenyEachBindingOnlyDenyDartResult& operator=(
      const DenyEachBindingOnlyDenyDartResult&) = default;
  DenyEachBindingOnlyDenyDartResult(DenyEachBindingOnlyDenyDartResult&&) =
      default;
  DenyEachBindingOnlyDenyDartResult& operator=(
      DenyEachBindingOnlyDenyDartResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenyDartResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::
               Ordinal::kResponse;
  }
  static DenyEachBindingOnlyDenyDartResult WithResponse(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse val) {
    DenyEachBindingOnlyDenyDartResult result;
    result.set_response(std::move(val));
    return result;
  }

  void set_response(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse elem) {
    ordinal_ = ::test_bindingsdenylist::wire::
        DenyEachBindingOnlyDenyDartResult::Ordinal::kResponse;
    envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenyDartResponse>()
        .set_data(std::move(elem));
  }

  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse&
  response() {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenyDartResponse>()
        .get_data();
  }
  const ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenyDartResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenyDartResult::Ordinal::kErr;
  }
  static DenyEachBindingOnlyDenyDartResult WithErr(uint32_t val) {
    DenyEachBindingOnlyDenyDartResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_bindingsdenylist::wire::
        DenyEachBindingOnlyDenyDartResult::Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              DenyEachBindingOnlyDenyDartResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              DenyEachBindingOnlyDenyDartResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Tag Which()
      const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

constexpr uint32_t kAllBindings = 0u;

}  // namespace wire
}  // namespace test_bindingsdenylist
namespace fidl {

template <>
struct TypeTraits<
    ::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary> {
  static constexpr const fidl_type_t* kType =
      &::test_bindingsdenylist::wire::
          test_bindingsdenylist_MemberOnlyAppearsInImportingLibraryTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary>);
static_assert(
    offsetof(::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary,
             a) == 0);
static_assert(
    sizeof(
        ::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary) ==
    TypeTraits<::test_bindingsdenylist::wire::
                   MemberOnlyAppearsInImportingLibrary>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary> {
  static constexpr const fidl_type_t* kType =
      &::test_bindingsdenylist::wire::
          test_bindingsdenylist_OnlyAppearsInImportingLibraryTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary>
    : public std::true_type {};
template <>
struct IsStruct<::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary>);
static_assert(
    offsetof(::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary,
             member_only_appears_in_importing_library) == 0);
static_assert(
    sizeof(::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary) ==
    TypeTraits<::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary>::
        kPrimarySize);

template <>
struct TypeTraits<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_bindingsdenylist::wire::
          test_bindingsdenylist_DenyEachBinding_OnlyDenySyzkaller_ResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::test_bindingsdenylist::wire::
                                  DenyEachBindingOnlyDenySyzkallerResponse>);
static_assert(
    offsetof(
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse,
        b) == 0);
static_assert(
    sizeof(::test_bindingsdenylist::wire::
               DenyEachBindingOnlyDenySyzkallerResponse) ==
    TypeTraits<::test_bindingsdenylist::wire::
                   DenyEachBindingOnlyDenySyzkallerResponse>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_bindingsdenylist::wire::
          test_bindingsdenylist_DenyEachBinding_OnlyDenyRust_ResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse>);
static_assert(
    offsetof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse,
             b) == 0);
static_assert(
    sizeof(
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse) ==
    TypeTraits<::test_bindingsdenylist::wire::
                   DenyEachBindingOnlyDenyRustResponse>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_bindingsdenylist::wire::
          test_bindingsdenylist_DenyEachBinding_OnlyDenyLibfuzzer_ResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::test_bindingsdenylist::wire::
                                  DenyEachBindingOnlyDenyLibfuzzerResponse>);
static_assert(
    offsetof(
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResponse,
        b) == 0);
static_assert(
    sizeof(::test_bindingsdenylist::wire::
               DenyEachBindingOnlyDenyLibfuzzerResponse) ==
    TypeTraits<::test_bindingsdenylist::wire::
                   DenyEachBindingOnlyDenyLibfuzzerResponse>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_bindingsdenylist::wire::
          test_bindingsdenylist_DenyEachBinding_OnlyDenyGo_ResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse>);
static_assert(
    offsetof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse,
             b) == 0);
static_assert(
    sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse) ==
    TypeTraits<::test_bindingsdenylist::wire::
                   DenyEachBindingOnlyDenyGoResponse>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_bindingsdenylist::wire::
          test_bindingsdenylist_DenyEachBinding_OnlyDenyDart_ResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse>);
static_assert(
    offsetof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse,
             b) == 0);
static_assert(
    sizeof(
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse) ==
    TypeTraits<::test_bindingsdenylist::wire::
                   DenyEachBindingOnlyDenyDartResponse>::kPrimarySize);

template <>
struct TypeTraits<::test_bindingsdenylist::wire::OnlyLlcpp> {
  static constexpr const fidl_type_t* kType =
      &::test_bindingsdenylist::wire::test_bindingsdenylist_OnlyLlcppTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_bindingsdenylist::wire::OnlyLlcpp>
    : public std::true_type {};
template <>
struct IsUnion<::test_bindingsdenylist::wire::OnlyLlcpp>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::test_bindingsdenylist::wire::OnlyLlcpp>);

template <>
struct TypeTraits<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult> {
  static constexpr const fidl_type_t* kType =
      &::test_bindingsdenylist::wire::
          test_bindingsdenylist_DenyEachBinding_OnlyDenySyzkaller_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult>
    : public std::true_type {};
template <>
struct IsUnion<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult>);

template <>
struct TypeTraits<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult> {
  static constexpr const fidl_type_t* kType =
      &::test_bindingsdenylist::wire::
          test_bindingsdenylist_DenyEachBinding_OnlyDenyRust_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult>
    : public std::true_type {};
template <>
struct IsUnion<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult>);

template <>
struct TypeTraits<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResult> {
  static constexpr const fidl_type_t* kType =
      &::test_bindingsdenylist::wire::
          test_bindingsdenylist_DenyEachBinding_OnlyDenyLibfuzzer_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResult>
    : public std::true_type {};
template <>
struct IsUnion<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResult>);

template <>
struct TypeTraits<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult> {
  static constexpr const fidl_type_t* kType =
      &::test_bindingsdenylist::wire::
          test_bindingsdenylist_DenyEachBinding_OnlyDenyGo_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult>
    : public std::true_type {};
template <>
struct IsUnion<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult>);

template <>
struct TypeTraits<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult> {
  static constexpr const fidl_type_t* kType =
      &::test_bindingsdenylist::wire::
          test_bindingsdenylist_DenyEachBinding_OnlyDenyDart_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult>
    : public std::true_type {};
template <>
struct IsUnion<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult>);

}  // namespace fidl
