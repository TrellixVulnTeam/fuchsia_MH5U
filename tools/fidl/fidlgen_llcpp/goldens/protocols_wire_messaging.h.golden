// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <fidl/test.protocols/cpp/markers.h>
#include <fidl/test.protocols/cpp/wire_types.h>
#include <lib/fidl/llcpp/wire_messaging.h>

#ifdef __Fuchsia__

#include <lib/fidl/llcpp/client.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/server.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/sync_call.h>

#endif  // __Fuchsia__

namespace test_protocols {
class HandleRightsProtocol;

class WithAndWithoutRequestResponse;

class Transitional;

class MethodWithUnion;

class WithProtocolEnds;

class ManyParameters;

class WithErrorSyntax;

class DiscoverableProtocol;

class ChannelProtocol;

__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolAnEventRequestTable;
}  // namespace test_protocols
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::HandleRightsProtocol::NoResponseMethod>
    final {
  static constexpr uint64_t value = 1155044649514904573lu;
};
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>
    final {
  static constexpr uint64_t value = 5956276128041940295lu;
};
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::HandleRightsProtocol::AnEvent>
    final {
  static constexpr uint64_t value = 476727631355490611lu;
};

namespace test_protocols {}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<
    ::test_protocols::HandleRightsProtocol> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::test_protocols::HandleRightsProtocol>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::test_protocols::HandleRightsProtocol>* impl,
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);
  static void Dispatch(
      ::fidl::WireServer<::test_protocols::HandleRightsProtocol>* impl,
      ::fidl::IncomingMessage&& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<
    ::test_protocols::HandleRightsProtocol::NoResponseMethod>
    final {
  FIDL_ALIGNDECL
  ::zx::socket h;

  explicit WireRequest(::zx::socket&& h) : h(std::move(h)) {}
  WireRequest() = default;
  void _CloseHandles();
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::HandleRightsProtocol::NoResponseMethod>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>
      body;
  explicit TransactionalRequest(::zx::socket&& h)
      : body(::fidl::WireRequest<
             ::test_protocols::HandleRightsProtocol::NoResponseMethod>(
            std::move(h))) {
    _InitHeader();
  }
  TransactionalRequest() { _InitHeader(); }
  void _CloseHandles() { body._CloseHandles(); }

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>
    final {
  FIDL_ALIGNDECL
  ::zx::socket h;

  explicit WireRequest(::zx::socket&& h) : h(std::move(h)) {}
  WireRequest() = default;
  using ResponseType = ::fidl::WireResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>;
  void _CloseHandles();
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>
      body;
  explicit TransactionalRequest(::zx::socket&& h)
      : body(::fidl::WireRequest<
             ::test_protocols::HandleRightsProtocol::ResponseMethod>(
            std::move(h))) {
    _InitHeader();
  }
  TransactionalRequest() { _InitHeader(); }
  using ResponseType = ::fidl::internal::TransactionalResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>;
  void _CloseHandles() { body._CloseHandles(); }

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>
    final {
  FIDL_ALIGNDECL
  ::zx::socket h;

  explicit WireResponse(::zx::socket&& h) : h(std::move(h)) {}
  WireResponse() = default;
  void _CloseHandles();
};

template <>
struct ::fidl::internal::TransactionalResponse<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>
      body;
  explicit TransactionalResponse(::zx::socket&& h)
      : body(::fidl::WireResponse<
             ::test_protocols::HandleRightsProtocol::ResponseMethod>(
            std::move(h))) {
    _InitHeader();
  }
  TransactionalResponse() { _InitHeader(); }
  void _CloseHandles() { body._CloseHandles(); }

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>
    final {
  FIDL_ALIGNDECL
  ::zx::socket h;

  explicit WireEvent(::zx::socket&& h) : h(std::move(h)) {}
  WireEvent() = default;
  void _CloseHandles();
};

template <>
struct ::fidl::internal::TransactionalEvent<
    ::test_protocols::HandleRightsProtocol::AnEvent>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent> body;
  explicit TransactionalEvent(::zx::socket&& h)
      : body(::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>(
            std::move(h))) {
    _InitHeader();
  }
  TransactionalEvent() { _InitHeader(); }
  void _CloseHandles() { body._CloseHandles(); }

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

namespace fidl {

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::HandleRightsProtocol::NoResponseMethod>>
    : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<
    ::test_protocols::HandleRightsProtocol::NoResponseMethod>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::HandleRightsProtocol::NoResponseMethod>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<
    ::test_protocols::HandleRightsProtocol::NoResponseMethod>>
    : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<
    ::test_protocols::HandleRightsProtocol::NoResponseMethod>>
    : public std::true_type {};
template <>
struct IsResource<::fidl::WireRequest<
    ::test_protocols::HandleRightsProtocol::NoResponseMethod>>
    : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::HandleRightsProtocol::NoResponseMethod>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(
    sizeof(::fidl::internal::TransactionalRequest<
           ::test_protocols::HandleRightsProtocol::NoResponseMethod>) ==
    TypeTraits<::fidl::internal::TransactionalRequest<
        ::test_protocols::HandleRightsProtocol::NoResponseMethod>>::
        kPrimarySize);
static_assert(
    offsetof(::fidl::internal::TransactionalRequest<
                 ::test_protocols::HandleRightsProtocol::NoResponseMethod>,
             header) == 0);
static_assert(
    offsetof(::fidl::internal::TransactionalRequest<
                 ::test_protocols::HandleRightsProtocol::NoResponseMethod>,
             body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<
    ::test_protocols::HandleRightsProtocol::NoResponseMethod>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(
    sizeof(::fidl::WireRequest<
           ::test_protocols::HandleRightsProtocol::NoResponseMethod>) ==
    TypeTraits<::fidl::WireRequest<::test_protocols::HandleRightsProtocol::
                                       NoResponseMethod>>::kPrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<
                 ::test_protocols::HandleRightsProtocol::NoResponseMethod>,
             h) == 0);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::true_type {};
template <>
struct IsResource<
    ::fidl::WireRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_HandleRightsProtocolResponseMethodRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(
    sizeof(::fidl::internal::TransactionalRequest<
           ::test_protocols::HandleRightsProtocol::ResponseMethod>) ==
    TypeTraits<::fidl::internal::TransactionalRequest<
        ::test_protocols::HandleRightsProtocol::ResponseMethod>>::kPrimarySize);
static_assert(
    offsetof(::fidl::internal::TransactionalRequest<
                 ::test_protocols::HandleRightsProtocol::ResponseMethod>,
             header) == 0);
static_assert(
    offsetof(::fidl::internal::TransactionalRequest<
                 ::test_protocols::HandleRightsProtocol::ResponseMethod>,
             body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_HandleRightsProtocolResponseMethodRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(
    sizeof(::fidl::WireRequest<
           ::test_protocols::HandleRightsProtocol::ResponseMethod>) ==
    TypeTraits<::fidl::WireRequest<
        ::test_protocols::HandleRightsProtocol::ResponseMethod>>::kPrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<
                 ::test_protocols::HandleRightsProtocol::ResponseMethod>,
             h) == 0);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalResponse<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::true_type {};
template <>
struct IsResource<::fidl::WireResponse<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(
    sizeof(::fidl::internal::TransactionalResponse<
           ::test_protocols::HandleRightsProtocol::ResponseMethod>) ==
    TypeTraits<::fidl::internal::TransactionalResponse<
        ::test_protocols::HandleRightsProtocol::ResponseMethod>>::kPrimarySize);
static_assert(
    offsetof(::fidl::internal::TransactionalResponse<
                 ::test_protocols::HandleRightsProtocol::ResponseMethod>,
             header) == 0);
static_assert(
    offsetof(::fidl::internal::TransactionalResponse<
                 ::test_protocols::HandleRightsProtocol::ResponseMethod>,
             body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireResponse<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(
    sizeof(::fidl::WireResponse<
           ::test_protocols::HandleRightsProtocol::ResponseMethod>) ==
    TypeTraits<::fidl::WireResponse<
        ::test_protocols::HandleRightsProtocol::ResponseMethod>>::kPrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::test_protocols::HandleRightsProtocol::ResponseMethod>,
             h) == 0);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<
    ::test_protocols::HandleRightsProtocol::AnEvent>> : public std::true_type {
};
template <>
struct IsFidlType<
    ::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<
    ::test_protocols::HandleRightsProtocol::AnEvent>> : public std::true_type {
};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>>
    : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalEvent<
    ::test_protocols::HandleRightsProtocol::AnEvent>> : public std::true_type {
};
template <>
struct IsResource<
    ::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>>
    : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<
    ::test_protocols::HandleRightsProtocol::AnEvent>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_HandleRightsProtocolAnEventRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(
    sizeof(::fidl::internal::TransactionalEvent<
           ::test_protocols::HandleRightsProtocol::AnEvent>) ==
    TypeTraits<::fidl::internal::TransactionalEvent<
        ::test_protocols::HandleRightsProtocol::AnEvent>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<
                           ::test_protocols::HandleRightsProtocol::AnEvent>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalEvent<
                           ::test_protocols::HandleRightsProtocol::AnEvent>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_HandleRightsProtocolAnEventRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(
    sizeof(
        ::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>) ==
    TypeTraits<::fidl::WireEvent<
        ::test_protocols::HandleRightsProtocol::AnEvent>>::kPrimarySize);
static_assert(
    offsetof(::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>,
             h) == 0);
#endif  // __Fuchsia__

}  // namespace fidl
namespace test_protocols {
#ifdef __Fuchsia__
}  // namespace test_protocols
template <>
class ::fidl::WireResult<
    ::test_protocols::HandleRightsProtocol::NoResponseMethod>
    final : public ::fidl::Result {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::NoResponseMethod>* request);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<
    ::test_protocols::HandleRightsProtocol::NoResponseMethod>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>
          client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::NoResponseMethod>* request);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};
template <>
class ::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>
    final : public ::fidl::Result {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>* request);
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>* request,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }
  ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::test_protocols::HandleRightsProtocol::ResponseMethod>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }
  const ::fidl::WireResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::test_protocols::HandleRightsProtocol::ResponseMethod>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }

  ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>
          client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>* request);
  explicit WireUnownedResult(
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>>&& decoded,
      ::fidl::internal::IncomingTransportContext context)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }
  ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return &(
        reinterpret_cast<::fidl::internal::TransactionalResponse<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>*>(bytes_)
            ->body);
  }
  const ::fidl::WireResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return &(
        reinterpret_cast<const ::fidl::internal::TransactionalResponse<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>*>(bytes_)
            ->body);
  }

  ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::test_protocols::HandleRightsProtocol> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
  virtual void AnEvent(
      ::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>*
          event) {}
};

template <>
class ::fidl::WireAsyncEventHandler<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::test_protocols::HandleRightsProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::test_protocols::HandleRightsProtocol> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>
          client_end);
};

template <>
class ::fidl::internal::WireEventDispatcher<
    ::test_protocols::HandleRightsProtocol>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::WireAsyncEventHandler<
                    ::test_protocols::HandleRightsProtocol>> {
 public:
  explicit WireEventDispatcher(
      ::fidl::WireAsyncEventHandler<::test_protocols::HandleRightsProtocol>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::IncomingTransportContext transport_context) override;
};

// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a
// |fidl::ClientEnd<::test_protocols::HandleRightsProtocol>|, avoiding setting
// up a client.
template <>
class ::fidl::internal::WireSyncClientImpl<
    ::test_protocols::HandleRightsProtocol>
    final : public ::fidl::internal::SyncEndpointManagedVeneer<
                ::fidl::internal::WireSyncClientImpl<
                    ::test_protocols::HandleRightsProtocol>> {
 public:
  // Allocates 40 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>
  NoResponseMethod(::zx::socket&& h) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::HandleRightsProtocol::NoResponseMethod>
        _request{std::move(h)};
    return ::fidl::WireResult<
        ::test_protocols::HandleRightsProtocol::NoResponseMethod>(_client_end(),
                                                                  &_request);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>
  ResponseMethod(::zx::socket&& h) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::HandleRightsProtocol::ResponseMethod>
        _request{std::move(h)};
    return ::fidl::WireResult<
        ::test_protocols::HandleRightsProtocol::ResponseMethod>(_client_end(),
                                                                &_request);
  }

 private:
  ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> _client_end()
      const {
    return ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<
    ::test_protocols::HandleRightsProtocol>
    final : public ::fidl::internal::SyncEndpointBufferVeneer<
                ::fidl::internal::WireSyncBufferClientImpl<
                    ::test_protocols::HandleRightsProtocol>> {
 public:
  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<
      ::test_protocols::HandleRightsProtocol::NoResponseMethod>
  NoResponseMethod(::zx::socket&& h) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::HandleRightsProtocol::NoResponseMethod>
        _request{std::move(h)};
    return ::fidl::WireUnownedResult<
        ::test_protocols::HandleRightsProtocol::NoResponseMethod>(
        _client_end(), _allocator(), &_request);
  }

  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>
  ResponseMethod(::zx::socket&& h) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::HandleRightsProtocol::ResponseMethod>
        _request{std::move(h)};
    return ::fidl::WireUnownedResult<
        ::test_protocols::HandleRightsProtocol::ResponseMethod>(
        _client_end(), _allocator(), &_request);
  }

 private:
  ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> _client_end()
      const {
    return ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireCompleterImpl<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>
    : public ::fidl::internal::CompleterImplBase<
          ::test_protocols::HandleRightsProtocol::ResponseMethod> {
 public:
  using CompleterImplBase::CompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(::zx::socket&& h);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>
    : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(::zx::socket&& h);
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>
    : public ::fidl::CompleterBase,
      public ::fidl::internal::WireCompleterImpl<
          ::test_protocols::HandleRightsProtocol::ResponseMethod> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned,
                    bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::test_protocols::HandleRightsProtocol::ResponseMethod> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>>;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::HandleRightsProtocol;

  using NoResponseMethodCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::HandleRightsProtocol::NoResponseMethod>;
  using NoResponseMethodRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::HandleRightsProtocol::NoResponseMethod>;

  virtual void NoResponseMethod(
      NoResponseMethodRequestView request,
      NoResponseMethodCompleter::Sync& _completer) = 0;

  using ResponseMethodCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>;
  using ResponseMethodRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>;

  virtual void ResponseMethod(ResponseMethodRequestView request,
                              ResponseMethodCompleter::Sync& _completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};
namespace test_protocols {
#endif  // __Fuchsia__

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;
}  // namespace test_protocols
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
    final {
  static constexpr uint64_t value = 5413654872775949227lu;
};
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    final {
  static constexpr uint64_t value = 1631193469798418024lu;
};
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final {
  static constexpr uint64_t value = 9037369643591427517lu;
};
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
    final {
  static constexpr uint64_t value = 7326057319832554103lu;
};
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    final {
  static constexpr uint64_t value = 2877322062572412767lu;
};
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    final {
  static constexpr uint64_t value = 6417226585456833969lu;
};
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
    final {
  static constexpr uint64_t value = 5397663296507358806lu;
};
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>
    final {
  static constexpr uint64_t value = 5811598563493228968lu;
};

namespace test_protocols {}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<
    ::test_protocols::WithAndWithoutRequestResponse> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>* impl,
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);
  static void Dispatch(
      ::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>* impl,
      ::fidl::IncomingMessage&& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
    final {
  WireRequest() = default;
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalRequest() { _InitHeader(); }

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    final {
  WireRequest() = default;
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalRequest() { _InitHeader(); }

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    final {
  WireResponse() = default;
};

template <>
struct ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalResponse() { _InitHeader(); }

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final {
  WireRequest() = default;
  using ResponseType = ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>;
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalRequest() { _InitHeader(); }
  using ResponseType = ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>;

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final {
  FIDL_ALIGNDECL
  ::fidl::StringView ret;

  explicit WireResponse(::fidl::StringView ret) : ret(ret) {}
  WireResponse() = default;
};

template <>
struct ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
      body;
  explicit TransactionalResponse(::fidl::StringView ret)
      : body(::fidl::WireResponse<
             ::test_protocols::WithAndWithoutRequestResponse::
                 NoRequestWithResponse>(ret)) {
    _InitHeader();
  }
  TransactionalResponse() { _InitHeader(); }

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
    final {
  FIDL_ALIGNDECL
  ::fidl::StringView arg;

  explicit WireRequest(::fidl::StringView arg) : arg(arg) {}
  WireRequest() = default;
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireRequest<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
      body;
  explicit TransactionalRequest(::fidl::StringView arg)
      : body(::fidl::WireRequest<
             ::test_protocols::WithAndWithoutRequestResponse::
                 WithRequestNoResponse>(arg)) {
    _InitHeader();
  }
  TransactionalRequest() { _InitHeader(); }

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    final {
  FIDL_ALIGNDECL
  ::fidl::StringView arg;

  explicit WireRequest(::fidl::StringView arg) : arg(arg) {}
  WireRequest() = default;
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireRequest<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
      body;
  explicit TransactionalRequest(::fidl::StringView arg)
      : body(::fidl::WireRequest<
             ::test_protocols::WithAndWithoutRequestResponse::
                 WithRequestEmptyResponse>(arg)) {
    _InitHeader();
  }
  TransactionalRequest() { _InitHeader(); }

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireResponse<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    final {
  WireResponse() = default;
};

template <>
struct ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalResponse() { _InitHeader(); }

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    final {
  FIDL_ALIGNDECL
  ::fidl::StringView arg;

  explicit WireRequest(::fidl::StringView arg) : arg(arg) {}
  WireRequest() = default;
  using ResponseType = ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>;
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireRequest<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
      body;
  explicit TransactionalRequest(::fidl::StringView arg)
      : body(::fidl::WireRequest<
             ::test_protocols::WithAndWithoutRequestResponse::
                 WithRequestWithResponse>(arg)) {
    _InitHeader();
  }
  TransactionalRequest() { _InitHeader(); }
  using ResponseType = ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>;

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireResponse<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    final {
  FIDL_ALIGNDECL
  ::fidl::StringView ret;

  explicit WireResponse(::fidl::StringView ret) : ret(ret) {}
  WireResponse() = default;
};

template <>
struct ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
      body;
  explicit TransactionalResponse(::fidl::StringView ret)
      : body(::fidl::WireResponse<
             ::test_protocols::WithAndWithoutRequestResponse::
                 WithRequestWithResponse>(ret)) {
    _InitHeader();
  }
  TransactionalResponse() { _InitHeader(); }

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
    final {
  WireEvent() = default;
};

template <>
struct ::fidl::internal::TransactionalEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalEvent() { _InitHeader(); }

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>
    final {
  FIDL_ALIGNDECL
  ::fidl::StringView ret;

  explicit WireEvent(::fidl::StringView ret) : ret(ret) {}
  WireEvent() = default;
};

template <>
struct ::fidl::internal::TransactionalEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireEvent<
      ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>
      body;
  explicit TransactionalEvent(::fidl::StringView ret)
      : body(::fidl::WireEvent<
             ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>(
            ret)) {
    _InitHeader();
  }
  TransactionalEvent() { _InitHeader(); }

 private:
  void _InitHeader();
};

namespace fidl {

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>>
    : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(
    sizeof(::fidl::internal::TransactionalRequest<
           ::test_protocols::WithAndWithoutRequestResponse::
               NoRequestNoResponse>) ==
    TypeTraits<::fidl::internal::TransactionalRequest<
        ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>>::
        kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestNoResponse>,
                       header) == 0);

template <>
struct TypeTraits<::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>
    : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<
                     ::test_protocols::WithAndWithoutRequestResponse::
                         NoRequestEmptyResponse>) ==
              TypeTraits<::fidl::internal::TransactionalRequest<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      NoRequestEmptyResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestEmptyResponse>,
                       header) == 0);

template <>
struct TypeTraits<::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>
    : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<
                     ::test_protocols::WithAndWithoutRequestResponse::
                         NoRequestEmptyResponse>) ==
              TypeTraits<::fidl::internal::TransactionalResponse<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      NoRequestEmptyResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestEmptyResponse>,
                       header) == 0);

template <>
struct TypeTraits<::fidl::WireResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>
    : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<
                     ::test_protocols::WithAndWithoutRequestResponse::
                         NoRequestWithResponse>) ==
              TypeTraits<::fidl::internal::TransactionalRequest<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      NoRequestWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestWithResponse>,
                       header) == 0);

template <>
struct TypeTraits<::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>
    : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<
                     ::test_protocols::WithAndWithoutRequestResponse::
                         NoRequestWithResponse>) ==
              TypeTraits<::fidl::internal::TransactionalResponse<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      NoRequestWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestWithResponse>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestWithResponse>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16);
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(
    sizeof(
        ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::
                                 NoRequestWithResponse>) ==
    TypeTraits<
        ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::
                                 NoRequestWithResponse>>::kPrimarySize);
static_assert(
    offsetof(
        ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::
                                 NoRequestWithResponse>,
        ret) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>>
    : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<
                     ::test_protocols::WithAndWithoutRequestResponse::
                         WithRequestNoResponse>) ==
              TypeTraits<::fidl::internal::TransactionalRequest<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      WithRequestNoResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestNoResponse>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestNoResponse>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16);
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(
    sizeof(::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::
                                   WithRequestNoResponse>) ==
    TypeTraits<
        ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::
                                WithRequestNoResponse>>::kPrimarySize);
static_assert(
    offsetof(
        ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::
                                WithRequestNoResponse>,
        arg) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>
    : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::
        WithRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<
                     ::test_protocols::WithAndWithoutRequestResponse::
                         WithRequestEmptyResponse>) ==
              TypeTraits<::fidl::internal::TransactionalRequest<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      WithRequestEmptyResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestEmptyResponse>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestEmptyResponse>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::
                            WithRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16);
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(
    sizeof(::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::
                                   WithRequestEmptyResponse>) ==
    TypeTraits<
        ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::
                                WithRequestEmptyResponse>>::kPrimarySize);
static_assert(
    offsetof(
        ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::
                                WithRequestEmptyResponse>,
        arg) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>
    : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::
        WithRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<
                     ::test_protocols::WithAndWithoutRequestResponse::
                         WithRequestEmptyResponse>) ==
              TypeTraits<::fidl::internal::TransactionalResponse<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      WithRequestEmptyResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestEmptyResponse>,
                       header) == 0);

template <>
struct TypeTraits<
    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::
                             WithRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>
    : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<
                     ::test_protocols::WithAndWithoutRequestResponse::
                         WithRequestWithResponse>) ==
              TypeTraits<::fidl::internal::TransactionalRequest<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      WithRequestWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestWithResponse>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestWithResponse>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16);
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(
    sizeof(::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::
                                   WithRequestWithResponse>) ==
    TypeTraits<
        ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::
                                WithRequestWithResponse>>::kPrimarySize);
static_assert(
    offsetof(
        ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::
                                WithRequestWithResponse>,
        arg) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>
    : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<
                     ::test_protocols::WithAndWithoutRequestResponse::
                         WithRequestWithResponse>) ==
              TypeTraits<::fidl::internal::TransactionalResponse<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      WithRequestWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestWithResponse>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestWithResponse>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireResponse<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16);
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(
    sizeof(
        ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::
                                 WithRequestWithResponse>) ==
    TypeTraits<
        ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::
                                 WithRequestWithResponse>>::kPrimarySize);
static_assert(
    offsetof(
        ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::
                                 WithRequestWithResponse>,
        ret) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>
    : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(
    sizeof(::fidl::internal::TransactionalEvent<
           ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>) ==
    TypeTraits<::fidl::internal::TransactionalEvent<
        ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>::
        kPrimarySize);
static_assert(
    offsetof(
        ::fidl::internal::TransactionalEvent<
            ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>,
        header) == 0);

template <>
struct TypeTraits<::fidl::WireEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>
    : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(
    sizeof(::fidl::internal::TransactionalEvent<
           ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>) ==
    TypeTraits<::fidl::internal::TransactionalEvent<
        ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>::
        kPrimarySize);
static_assert(
    offsetof(
        ::fidl::internal::TransactionalEvent<
            ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>,
        header) == 0);
static_assert(
    offsetof(
        ::fidl::internal::TransactionalEvent<
            ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>,
        body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16);
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(
    sizeof(::fidl::WireEvent<
           ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>) ==
    TypeTraits<::fidl::WireEvent<
        ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>::
        kPrimarySize);
static_assert(
    offsetof(
        ::fidl::WireEvent<
            ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>,
        ret) == 0);

}  // namespace fidl
namespace test_protocols {
#ifdef __Fuchsia__
}  // namespace test_protocols
template <>
class ::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
    final : public ::fidl::Result {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>
          client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>*
          request);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>
          client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>*
          request);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};
template <>
class ::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    final : public ::fidl::Result {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>
          client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>* request);
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>
          client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>* request,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
  ::fidl::internal::InlineMessageBuffer<16> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>
          client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>* request);
  explicit WireUnownedResult(::fidl::internal::TransactionalResponse<
                             ::test_protocols::WithAndWithoutRequestResponse::
                                 NoRequestEmptyResponse>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>>&& decoded,
      ::fidl::internal::IncomingTransportContext context)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final : public ::fidl::Result {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>
          client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>* request);
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>
          client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>* request,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;
  ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::
                                 NoRequestWithResponse>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>*>(bytes_.data() +
                                     sizeof(fidl_message_header_t));
  }

  ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>
          client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>* request);
  explicit WireUnownedResult(::fidl::internal::TransactionalResponse<
                             ::test_protocols::WithAndWithoutRequestResponse::
                                 NoRequestWithResponse>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>>&& decoded,
      ::fidl::internal::IncomingTransportContext context)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
  ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<::fidl::internal::TransactionalResponse<
                 ::test_protocols::WithAndWithoutRequestResponse::
                     NoRequestWithResponse>*>(bytes_)
                 ->body);
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<const ::fidl::internal::TransactionalResponse<
                 ::test_protocols::WithAndWithoutRequestResponse::
                     NoRequestWithResponse>*>(bytes_)
                 ->body);
  }

  ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
    final : public ::fidl::Result {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>
          client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestNoResponse>* request);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>
          client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestNoResponse>* request);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};
template <>
class ::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    final : public ::fidl::Result {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>
          client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>* request);
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>
          client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>* request,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
  ::fidl::internal::InlineMessageBuffer<16> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>
          client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>* request);
  explicit WireUnownedResult(::fidl::internal::TransactionalResponse<
                             ::test_protocols::WithAndWithoutRequestResponse::
                                 WithRequestEmptyResponse>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>>&& decoded,
      ::fidl::internal::IncomingTransportContext context)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    final : public ::fidl::Result {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>
          client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>* request);
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>
          client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>* request,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;
  ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::
                                 WithRequestWithResponse>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>*>(bytes_.data() +
                                       sizeof(fidl_message_header_t));
  }

  ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>
          client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>* request);
  explicit WireUnownedResult(::fidl::internal::TransactionalResponse<
                             ::test_protocols::WithAndWithoutRequestResponse::
                                 WithRequestWithResponse>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>>&& decoded,
      ::fidl::internal::IncomingTransportContext context)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
  ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<::fidl::internal::TransactionalResponse<
                 ::test_protocols::WithAndWithoutRequestResponse::
                     WithRequestWithResponse>*>(bytes_)
                 ->body);
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<const ::fidl::internal::TransactionalResponse<
                 ::test_protocols::WithAndWithoutRequestResponse::
                     WithRequestWithResponse>*>(bytes_)
                 ->body);
  }

  ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::test_protocols::WithAndWithoutRequestResponse> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
  virtual void OnEmptyResponse(
      ::fidl::WireEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>*
          event) {}
  virtual void OnWithResponse(
      ::fidl::WireEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>*
          event) {}
};

template <>
class ::fidl::WireAsyncEventHandler<
    ::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::test_protocols::WithAndWithoutRequestResponse>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<
    ::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::test_protocols::WithAndWithoutRequestResponse> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>
          client_end);
};

template <>
class ::fidl::internal::WireEventDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::WireAsyncEventHandler<
                    ::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  explicit WireEventDispatcher(
      ::fidl::WireAsyncEventHandler<
          ::test_protocols::WithAndWithoutRequestResponse>* event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::IncomingTransportContext transport_context) override;
};

// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a
// |fidl::ClientEnd<::test_protocols::WithAndWithoutRequestResponse>|, avoiding
// setting up a client.
template <>
class ::fidl::internal::WireSyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>
    final : public ::fidl::internal::SyncEndpointManagedVeneer<
                ::fidl::internal::WireSyncClientImpl<
                    ::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
  NoRequestNoResponse() {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
        _request{};
    return ::fidl::WireResult<
        ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>(
        _client_end(), &_request);
  }

  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
  NoRequestEmptyResponse() {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
        _request{};
    return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::
                                  NoRequestEmptyResponse>(_client_end(),
                                                          &_request);
  }

  // Allocates 16 bytes of request buffer on the stack. Response is
  // heap-allocated.
  ::fidl::WireResult<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
  NoRequestWithResponse() {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
        _request{};
    return ::fidl::WireResult<
        ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(
        _client_end(), &_request);
  }

  // Allocates 16 bytes of response buffer on the stack. Request is
  // heap-allocated.
  ::fidl::WireResult<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
  WithRequestNoResponse(::fidl::StringView arg) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
        _request{arg};
    return ::fidl::WireResult<
        ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>(
        _client_end(), &_request);
  }

  // Allocates 16 bytes of response buffer on the stack. Request is
  // heap-allocated.
  ::fidl::WireResult<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
  WithRequestEmptyResponse(::fidl::StringView arg) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>
        _request{arg};
    return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::
                                  WithRequestEmptyResponse>(_client_end(),
                                                            &_request);
  }

  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
  WithRequestWithResponse(::fidl::StringView arg) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>
        _request{arg};
    return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::
                                  WithRequestWithResponse>(_client_end(),
                                                           &_request);
  }

 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>
  _client_end() const {
    return ::fidl::UnownedClientEnd<
        ::test_protocols::WithAndWithoutRequestResponse>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>
    final : public ::fidl::internal::SyncEndpointBufferVeneer<
                ::fidl::internal::WireSyncBufferClientImpl<
                    ::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
  NoRequestNoResponse() {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
        _request{};
    return ::fidl::WireUnownedResult<
        ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>(
        _client_end(), _allocator(), &_request);
  }

  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
  NoRequestEmptyResponse() {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
        _request{};
    return ::fidl::WireUnownedResult<
        ::test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>(_client_end(), _allocator(), &_request);
  }

  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
  NoRequestWithResponse() {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
        _request{};
    return ::fidl::WireUnownedResult<
        ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(
        _client_end(), _allocator(), &_request);
  }

  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
  WithRequestNoResponse(::fidl::StringView arg) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
        _request{arg};
    return ::fidl::WireUnownedResult<
        ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>(
        _client_end(), _allocator(), &_request);
  }

  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
  WithRequestEmptyResponse(::fidl::StringView arg) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>
        _request{arg};
    return ::fidl::WireUnownedResult<
        ::test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>(_client_end(), _allocator(), &_request);
  }

  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
  WithRequestWithResponse(::fidl::StringView arg) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>
        _request{arg};
    return ::fidl::WireUnownedResult<
        ::test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>(_client_end(), _allocator(), &_request);
  }

 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>
  _client_end() const {
    return ::fidl::UnownedClientEnd<
        ::test_protocols::WithAndWithoutRequestResponse>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    : public ::fidl::internal::CompleterImplBase<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse> {
 public:
  using CompleterImplBase::CompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply();
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply();
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    : public ::fidl::CompleterBase,
      public ::fidl::internal::WireCompleterImpl<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned,
                    bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>;
};

template <>
class ::fidl::internal::WireCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    : public ::fidl::internal::CompleterImplBase<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse> {
 public:
  using CompleterImplBase::CompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(::fidl::StringView ret);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(::fidl::StringView ret);
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    : public ::fidl::CompleterBase,
      public ::fidl::internal::WireCompleterImpl<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned,
                    bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>;
};

template <>
class ::fidl::internal::WireCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    : public ::fidl::internal::CompleterImplBase<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse> {
 public:
  using CompleterImplBase::CompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply();
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply();
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    : public ::fidl::CompleterBase,
      public ::fidl::internal::WireCompleterImpl<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned,
                    bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>>;
};

template <>
class ::fidl::internal::WireCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    : public ::fidl::internal::CompleterImplBase<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse> {
 public:
  using CompleterImplBase::CompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(::fidl::StringView ret);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(::fidl::StringView ret);
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    : public ::fidl::CompleterBase,
      public ::fidl::internal::WireCompleterImpl<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned,
                    bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>>;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithAndWithoutRequestResponse;

  using NoRequestNoResponseCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>;
  using NoRequestNoResponseRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>;

  virtual void NoRequestNoResponse(
      NoRequestNoResponseRequestView request,
      NoRequestNoResponseCompleter::Sync& _completer) = 0;

  using NoRequestEmptyResponseCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>;
  using NoRequestEmptyResponseRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>;

  virtual void NoRequestEmptyResponse(
      NoRequestEmptyResponseRequestView request,
      NoRequestEmptyResponseCompleter::Sync& _completer) = 0;

  using NoRequestWithResponseCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>;
  using NoRequestWithResponseRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>;

  virtual void NoRequestWithResponse(
      NoRequestWithResponseRequestView request,
      NoRequestWithResponseCompleter::Sync& _completer) = 0;

  using WithRequestNoResponseCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>;
  using WithRequestNoResponseRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>;

  virtual void WithRequestNoResponse(
      WithRequestNoResponseRequestView request,
      WithRequestNoResponseCompleter::Sync& _completer) = 0;

  using WithRequestEmptyResponseCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>;
  using WithRequestEmptyResponseRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>;

  virtual void WithRequestEmptyResponse(
      WithRequestEmptyResponseRequestView request,
      WithRequestEmptyResponseCompleter::Sync& _completer) = 0;

  using WithRequestWithResponseCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>;
  using WithRequestWithResponseRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>;

  virtual void WithRequestWithResponse(
      WithRequestWithResponseRequestView request,
      WithRequestWithResponseCompleter::Sync& _completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};
namespace test_protocols {
#endif  // __Fuchsia__

__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalRequestRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalRequestTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalOneWayRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalEventRequestTable;
}  // namespace test_protocols
template <>
struct ::fidl::internal::WireOrdinal<::test_protocols::Transitional::Request>
    final {
  static constexpr uint64_t value = 5849263021838298888lu;
};
template <>
struct ::fidl::internal::WireOrdinal<::test_protocols::Transitional::OneWay>
    final {
  static constexpr uint64_t value = 4336658926562441191lu;
};
template <>
struct ::fidl::internal::WireOrdinal<::test_protocols::Transitional::Event>
    final {
  static constexpr uint64_t value = 8507647465196374081lu;
};

namespace test_protocols {}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<::test_protocols::Transitional> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::Transitional>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::test_protocols::Transitional>* impl,
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::Transitional>* impl,
                       ::fidl::IncomingMessage&& msg,
                       internal::IncomingTransportContext transport_context,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<::test_protocols::Transitional::Request> final {
  FIDL_ALIGNDECL
  int64_t x;

  explicit WireRequest(int64_t x) : x(x) {}
  WireRequest() = default;
  using ResponseType =
      ::fidl::WireResponse<::test_protocols::Transitional::Request>;
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::Transitional::Request>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireRequest<::test_protocols::Transitional::Request> body;
  explicit TransactionalRequest(int64_t x)
      : body(::fidl::WireRequest<::test_protocols::Transitional::Request>(x)) {
    _InitHeader();
  }
  TransactionalRequest() { _InitHeader(); }
  using ResponseType = ::fidl::internal::TransactionalResponse<
      ::test_protocols::Transitional::Request>;

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireResponse<::test_protocols::Transitional::Request> final {
  FIDL_ALIGNDECL
  int64_t y;

  explicit WireResponse(int64_t y) : y(y) {}
  WireResponse() = default;
};

template <>
struct ::fidl::internal::TransactionalResponse<
    ::test_protocols::Transitional::Request>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_protocols::Transitional::Request> body;
  explicit TransactionalResponse(int64_t y)
      : body(::fidl::WireResponse<::test_protocols::Transitional::Request>(y)) {
    _InitHeader();
  }
  TransactionalResponse() { _InitHeader(); }

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireRequest<::test_protocols::Transitional::OneWay> final {
  FIDL_ALIGNDECL
  int64_t x;

  explicit WireRequest(int64_t x) : x(x) {}
  WireRequest() = default;
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::Transitional::OneWay>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireRequest<::test_protocols::Transitional::OneWay> body;
  explicit TransactionalRequest(int64_t x)
      : body(::fidl::WireRequest<::test_protocols::Transitional::OneWay>(x)) {
    _InitHeader();
  }
  TransactionalRequest() { _InitHeader(); }

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireEvent<::test_protocols::Transitional::Event> final {
  FIDL_ALIGNDECL
  int64_t x;

  explicit WireEvent(int64_t x) : x(x) {}
  WireEvent() = default;
};

template <>
struct ::fidl::internal::TransactionalEvent<
    ::test_protocols::Transitional::Event>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireEvent<::test_protocols::Transitional::Event> body;
  explicit TransactionalEvent(int64_t x)
      : body(::fidl::WireEvent<::test_protocols::Transitional::Event>(x)) {
    _InitHeader();
  }
  TransactionalEvent() { _InitHeader(); }

 private:
  void _InitHeader();
};

namespace fidl {

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::Transitional::Request>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::Transitional::Request>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::Transitional::Request>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireRequest<::test_protocols::Transitional::Request>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::Transitional::Request>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_TransitionalRequestRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<
                     ::test_protocols::Transitional::Request>) ==
              TypeTraits<::fidl::internal::TransactionalRequest<
                  ::test_protocols::Transitional::Request>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::Transitional::Request>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::Transitional::Request>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireRequest<::test_protocols::Transitional::Request>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_TransitionalRequestRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(8);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(8);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(
    sizeof(::fidl::WireRequest<::test_protocols::Transitional::Request>) ==
    TypeTraits<::fidl::WireRequest<::test_protocols::Transitional::Request>>::
        kPrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::Transitional::Request>, x) ==
    0);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<
    ::test_protocols::Transitional::Request>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::Transitional::Request>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<
    ::test_protocols::Transitional::Request>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireResponse<::test_protocols::Transitional::Request>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<
    ::test_protocols::Transitional::Request>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_TransitionalRequestTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<
                     ::test_protocols::Transitional::Request>) ==
              TypeTraits<::fidl::internal::TransactionalResponse<
                  ::test_protocols::Transitional::Request>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::Transitional::Request>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::Transitional::Request>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireResponse<::test_protocols::Transitional::Request>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_TransitionalRequestTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(8);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(8);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(
    sizeof(::fidl::WireResponse<::test_protocols::Transitional::Request>) ==
    TypeTraits<::fidl::WireResponse<::test_protocols::Transitional::Request>>::
        kPrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<::test_protocols::Transitional::Request>,
             y) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::Transitional::OneWay>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::Transitional::OneWay>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::Transitional::OneWay>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireRequest<::test_protocols::Transitional::OneWay>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::Transitional::OneWay>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_TransitionalOneWayRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<
                     ::test_protocols::Transitional::OneWay>) ==
              TypeTraits<::fidl::internal::TransactionalRequest<
                  ::test_protocols::Transitional::OneWay>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::Transitional::OneWay>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::Transitional::OneWay>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::Transitional::OneWay>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_TransitionalOneWayRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(8);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(8);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(
    sizeof(::fidl::WireRequest<::test_protocols::Transitional::OneWay>) ==
    TypeTraits<::fidl::WireRequest<::test_protocols::Transitional::OneWay>>::
        kPrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::Transitional::OneWay>, x) ==
    0);

template <>
struct IsFidlType<
    ::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>>
    : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireEvent<::test_protocols::Transitional::Event>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireEvent<::test_protocols::Transitional::Event>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<
    ::test_protocols::Transitional::Event>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_TransitionalEventRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<
                     ::test_protocols::Transitional::Event>) ==
              TypeTraits<::fidl::internal::TransactionalEvent<
                  ::test_protocols::Transitional::Event>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<
                           ::test_protocols::Transitional::Event>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalEvent<
                           ::test_protocols::Transitional::Event>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireEvent<::test_protocols::Transitional::Event>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_TransitionalEventRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(8);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(8);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(
    sizeof(::fidl::WireEvent<::test_protocols::Transitional::Event>) ==
    TypeTraits<::fidl::WireEvent<::test_protocols::Transitional::Event>>::
        kPrimarySize);
static_assert(offsetof(::fidl::WireEvent<::test_protocols::Transitional::Event>,
                       x) == 0);

}  // namespace fidl
namespace test_protocols {
#ifdef __Fuchsia__
}  // namespace test_protocols
template <>
class ::fidl::WireResult<::test_protocols::Transitional::Request> final
    : public ::fidl::Result {
 public:
  WireResult(::fidl::UnownedClientEnd<::test_protocols::Transitional> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::Transitional::Request>* request);
  WireResult(::fidl::UnownedClientEnd<::test_protocols::Transitional> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::Transitional::Request>* request,
             zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;
  ::fidl::WireResponse<::test_protocols::Transitional::Request>* Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::test_protocols::Transitional::Request>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }
  const ::fidl::WireResponse<::test_protocols::Transitional::Request>* Unwrap()
      const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        const ::fidl::WireResponse<::test_protocols::Transitional::Request>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }

  ::fidl::WireResponse<::test_protocols::Transitional::Request>& value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::test_protocols::Transitional::Request>& value()
      const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::Transitional::Request>* operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::test_protocols::Transitional::Request>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::Transitional::Request>& operator*() {
    return value();
  }
  const ::fidl::WireResponse<::test_protocols::Transitional::Request>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> bytes_;
};
template <>
class ::fidl::WireUnownedResult<::test_protocols::Transitional::Request> final
    : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::Transitional::Request>* request);
  explicit WireUnownedResult(::fidl::internal::TransactionalResponse<
                             ::test_protocols::Transitional::Request>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<
          ::test_protocols::Transitional::Request>>&& decoded,
      ::fidl::internal::IncomingTransportContext context)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
  ::fidl::WireResponse<::test_protocols::Transitional::Request>* Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<::fidl::internal::TransactionalResponse<
                 ::test_protocols::Transitional::Request>*>(bytes_)
                 ->body);
  }
  const ::fidl::WireResponse<::test_protocols::Transitional::Request>* Unwrap()
      const {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<const ::fidl::internal::TransactionalResponse<
                 ::test_protocols::Transitional::Request>*>(bytes_)
                 ->body);
  }

  ::fidl::WireResponse<::test_protocols::Transitional::Request>& value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::test_protocols::Transitional::Request>& value()
      const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::Transitional::Request>* operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::test_protocols::Transitional::Request>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::Transitional::Request>& operator*() {
    return value();
  }
  const ::fidl::WireResponse<::test_protocols::Transitional::Request>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::test_protocols::Transitional::OneWay> final
    : public ::fidl::Result {
 public:
  WireResult(::fidl::UnownedClientEnd<::test_protocols::Transitional> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::Transitional::OneWay>* request);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<::test_protocols::Transitional::OneWay> final
    : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::Transitional::OneWay>* request);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::test_protocols::Transitional> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
  virtual void Event(
      ::fidl::WireEvent<::test_protocols::Transitional::Event>* event) {}
};

template <>
class ::fidl::WireAsyncEventHandler<::test_protocols::Transitional>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::test_protocols::Transitional>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::test_protocols::Transitional>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::test_protocols::Transitional> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end);
};

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::Transitional>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::WireAsyncEventHandler<::test_protocols::Transitional>> {
 public:
  explicit WireEventDispatcher(
      ::fidl::WireAsyncEventHandler<::test_protocols::Transitional>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::IncomingTransportContext transport_context) override;
};

// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |fidl::ClientEnd<::test_protocols::Transitional>|,
// avoiding setting up a client.
template <>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::Transitional> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::WireSyncClientImpl<
              ::test_protocols::Transitional>> {
 public:
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::Transitional::Request> Request(
      int64_t x) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::Transitional::Request>
        _request{x};
    return ::fidl::WireResult<::test_protocols::Transitional::Request>(
        _client_end(), &_request);
  }

  // Allocates 40 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::Transitional::OneWay> OneWay(int64_t x) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::Transitional::OneWay>
        _request{x};
    return ::fidl::WireResult<::test_protocols::Transitional::OneWay>(
        _client_end(), &_request);
  }

 private:
  ::fidl::UnownedClientEnd<::test_protocols::Transitional> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::Transitional>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::Transitional>
    final : public ::fidl::internal::SyncEndpointBufferVeneer<
                ::fidl::internal::WireSyncBufferClientImpl<
                    ::test_protocols::Transitional>> {
 public:
  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<::test_protocols::Transitional::Request> Request(
      int64_t x) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::Transitional::Request>
        _request{x};
    return ::fidl::WireUnownedResult<::test_protocols::Transitional::Request>(
        _client_end(), _allocator(), &_request);
  }

  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<::test_protocols::Transitional::OneWay> OneWay(
      int64_t x) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::Transitional::OneWay>
        _request{x};
    return ::fidl::WireUnownedResult<::test_protocols::Transitional::OneWay>(
        _client_end(), _allocator(), &_request);
  }

 private:
  ::fidl::UnownedClientEnd<::test_protocols::Transitional> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::Transitional>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireCompleterImpl<
    ::test_protocols::Transitional::Request>
    : public ::fidl::internal::CompleterImplBase<
          ::test_protocols::Transitional::Request> {
 public:
  using CompleterImplBase::CompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(int64_t y);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::Transitional::Request>
    : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(int64_t y);
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::test_protocols::Transitional::Request>
    : public ::fidl::CompleterBase,
      public ::fidl::internal::WireCompleterImpl<
          ::test_protocols::Transitional::Request> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned,
                    bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::test_protocols::Transitional::Request> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::test_protocols::Transitional::Request>>;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::test_protocols::Transitional>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::Transitional;

  using RequestCompleter =
      ::fidl::internal::WireCompleter<::test_protocols::Transitional::Request>;
  using RequestRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::Transitional::Request>;

  virtual void Request(RequestRequestView request,
                       RequestCompleter::Sync& _completer) {
    _completer.Close(ZX_ERR_NOT_SUPPORTED);
  }

  using OneWayCompleter =
      ::fidl::internal::WireCompleter<::test_protocols::Transitional::OneWay>;
  using OneWayRequestView =
      ::fidl::internal::WireRequestView<::test_protocols::Transitional::OneWay>;

  virtual void OneWay(OneWayRequestView request,
                      OneWayCompleter::Sync& _completer) {
    _completer.Close(ZX_ERR_NOT_SUPPORTED);
  }

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};
namespace test_protocols {
#endif  // __Fuchsia__

__LOCAL extern "C" const fidl_type_t
    test_protocols_MethodWithUnionUnionMethodRequestTable;

}  // namespace test_protocols
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::MethodWithUnion::UnionMethod>
    final {
  static constexpr uint64_t value = 4124874338266649112lu;
};

namespace test_protocols {}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<::test_protocols::MethodWithUnion> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::MethodWithUnion>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::test_protocols::MethodWithUnion>* impl,
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);
  static void Dispatch(
      ::fidl::WireServer<::test_protocols::MethodWithUnion>* impl,
      ::fidl::IncomingMessage&& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod>
    final {
  FIDL_ALIGNDECL
  ::test_protocols::wire::TheUnion u;

  explicit WireRequest(::test_protocols::wire::TheUnion u) : u(u) {}
  WireRequest() = default;
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::MethodWithUnion::UnionMethod>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod> body;
  explicit TransactionalRequest(::test_protocols::wire::TheUnion u)
      : body(
            ::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod>(
                u)) {
    _InitHeader();
  }
  TransactionalRequest() { _InitHeader(); }

 private:
  void _InitHeader();
};

namespace fidl {

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::MethodWithUnion::UnionMethod>> : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::MethodWithUnion::UnionMethod>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::MethodWithUnion::UnionMethod>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_MethodWithUnionUnionMethodRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(24 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(
    sizeof(::fidl::internal::TransactionalRequest<
           ::test_protocols::MethodWithUnion::UnionMethod>) ==
    TypeTraits<::fidl::internal::TransactionalRequest<
        ::test_protocols::MethodWithUnion::UnionMethod>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::MethodWithUnion::UnionMethod>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::MethodWithUnion::UnionMethod>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_MethodWithUnionUnionMethodRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(24);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(
    sizeof(
        ::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod>) ==
    TypeTraits<::fidl::WireRequest<
        ::test_protocols::MethodWithUnion::UnionMethod>>::kPrimarySize);
static_assert(
    offsetof(
        ::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod>,
        u) == 0);

}  // namespace fidl
namespace test_protocols {
#ifdef __Fuchsia__
}  // namespace test_protocols
template <>
class ::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod> final
    : public ::fidl::Result {
 public:
  WireResult(::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::MethodWithUnion::UnionMethod>* request);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<::test_protocols::MethodWithUnion::UnionMethod>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::MethodWithUnion::UnionMethod>* request);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::test_protocols::MethodWithUnion> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template <>
class ::fidl::WireAsyncEventHandler<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::test_protocols::MethodWithUnion>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::test_protocols::MethodWithUnion> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client_end);
};

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::MethodWithUnion>
    final
    : public ::fidl::internal::IncomingEventDispatcher<
          ::fidl::WireAsyncEventHandler<::test_protocols::MethodWithUnion>> {
 public:
  explicit WireEventDispatcher(
      ::fidl::WireAsyncEventHandler<::test_protocols::MethodWithUnion>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::IncomingTransportContext transport_context) override;
};

// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |fidl::ClientEnd<::test_protocols::MethodWithUnion>|,
// avoiding setting up a client.
template <>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::MethodWithUnion>
    final : public ::fidl::internal::SyncEndpointManagedVeneer<
                ::fidl::internal::WireSyncClientImpl<
                    ::test_protocols::MethodWithUnion>> {
 public:
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod>
  UnionMethod(::test_protocols::wire::TheUnion u) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::MethodWithUnion::UnionMethod>
        _request{u};
    return ::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod>(
        _client_end(), &_request);
  }

 private:
  ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> _client_end()
      const {
    return ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<
    ::test_protocols::MethodWithUnion>
    final : public ::fidl::internal::SyncEndpointBufferVeneer<
                ::fidl::internal::WireSyncBufferClientImpl<
                    ::test_protocols::MethodWithUnion>> {
 public:
  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<::test_protocols::MethodWithUnion::UnionMethod>
  UnionMethod(::test_protocols::wire::TheUnion u) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::MethodWithUnion::UnionMethod>
        _request{u};
    return ::fidl::WireUnownedResult<
        ::test_protocols::MethodWithUnion::UnionMethod>(
        _client_end(), _allocator(), &_request);
  }

 private:
  ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> _client_end()
      const {
    return ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::MethodWithUnion;

  using UnionMethodCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::MethodWithUnion::UnionMethod>;
  using UnionMethodRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::MethodWithUnion::UnionMethod>;

  virtual void UnionMethod(UnionMethodRequestView request,
                           UnionMethodCompleter::Sync& _completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};
namespace test_protocols {
#endif  // __Fuchsia__

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;
}  // namespace test_protocols
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::WithProtocolEnds::ClientEnds>
    final {
  static constexpr uint64_t value = 5870448041025163330lu;
};
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::WithProtocolEnds::ServerEnds>
    final {
  static constexpr uint64_t value = 8115535094437022259lu;
};
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>
    final {
  static constexpr uint64_t value = 4076866772260025813lu;
};

namespace test_protocols {}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<::test_protocols::WithProtocolEnds> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::test_protocols::WithProtocolEnds>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::test_protocols::WithProtocolEnds>* impl,
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);
  static void Dispatch(
      ::fidl::WireServer<::test_protocols::WithProtocolEnds>* impl,
      ::fidl::IncomingMessage&& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>
    final {
  FIDL_ALIGNDECL
  ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> in;

  explicit WireRequest(
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in)
      : in(std::move(in)) {}
  WireRequest() = default;
  using ResponseType =
      ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>;
  void _CloseHandles();
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::ClientEnds>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds> body;
  explicit TransactionalRequest(
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in)
      : body(
            ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>(
                std::move(in))) {
    _InitHeader();
  }
  TransactionalRequest() { _InitHeader(); }
  using ResponseType = ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ClientEnds>;
  void _CloseHandles() { body._CloseHandles(); }

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>
    final {
  FIDL_ALIGNDECL
  ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> out;

  explicit WireResponse(
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out)
      : out(std::move(out)) {}
  WireResponse() = default;
  void _CloseHandles();
};

template <>
struct ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::ClientEnds>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds> body;
  explicit TransactionalResponse(
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out)
      : body(::fidl::WireResponse<
             ::test_protocols::WithProtocolEnds::ClientEnds>(std::move(out))) {
    _InitHeader();
  }
  TransactionalResponse() { _InitHeader(); }
  void _CloseHandles() { body._CloseHandles(); }

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>
    final {
  FIDL_ALIGNDECL
  ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> in;

  explicit WireRequest(
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in)
      : in(std::move(in)) {}
  WireRequest() = default;
  using ResponseType =
      ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>;
  void _CloseHandles();
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::ServerEnds>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds> body;
  explicit TransactionalRequest(
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in)
      : body(
            ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>(
                std::move(in))) {
    _InitHeader();
  }
  TransactionalRequest() { _InitHeader(); }
  using ResponseType = ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ServerEnds>;
  void _CloseHandles() { body._CloseHandles(); }

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>
    final {
  FIDL_ALIGNDECL
  ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> out;

  explicit WireResponse(
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out)
      : out(std::move(out)) {}
  WireResponse() = default;
  void _CloseHandles();
};

template <>
struct ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::ServerEnds>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds> body;
  explicit TransactionalResponse(
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out)
      : body(::fidl::WireResponse<
             ::test_protocols::WithProtocolEnds::ServerEnds>(std::move(out))) {
    _InitHeader();
  }
  TransactionalResponse() { _InitHeader(); }
  void _CloseHandles() { body._CloseHandles(); }

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>
    final {
  FIDL_ALIGNDECL
  ::test_protocols::wire::ProtocolEnds in;

  explicit WireRequest(::test_protocols::wire::ProtocolEnds&& in)
      : in(std::move(in)) {}
  WireRequest() = default;
  using ResponseType = ::fidl::WireResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>;
  void _CloseHandles();
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>
      body;
  explicit TransactionalRequest(::test_protocols::wire::ProtocolEnds&& in)
      : body(::fidl::WireRequest<
             ::test_protocols::WithProtocolEnds::StructContainingEnds>(
            std::move(in))) {
    _InitHeader();
  }
  TransactionalRequest() { _InitHeader(); }
  using ResponseType = ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>;
  void _CloseHandles() { body._CloseHandles(); }

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>
    final {
  FIDL_ALIGNDECL
  ::test_protocols::wire::ProtocolEnds out;

  explicit WireResponse(::test_protocols::wire::ProtocolEnds&& out)
      : out(std::move(out)) {}
  WireResponse() = default;
  void _CloseHandles();
};

template <>
struct ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>
      body;
  explicit TransactionalResponse(::test_protocols::wire::ProtocolEnds&& out)
      : body(::fidl::WireResponse<
             ::test_protocols::WithProtocolEnds::StructContainingEnds>(
            std::move(out))) {
    _InitHeader();
  }
  TransactionalResponse() { _InitHeader(); }
  void _CloseHandles() { body._CloseHandles(); }

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

namespace fidl {

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>>
    : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
template <>
struct IsResource<
    ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>>
    : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::ClientEnds>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_WithProtocolEndsClientEndsRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(
    sizeof(::fidl::internal::TransactionalRequest<
           ::test_protocols::WithProtocolEnds::ClientEnds>) ==
    TypeTraits<::fidl::internal::TransactionalRequest<
        ::test_protocols::WithProtocolEnds::ClientEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::WithProtocolEnds::ClientEnds>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::WithProtocolEnds::ClientEnds>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_WithProtocolEndsClientEndsRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(
    sizeof(
        ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>) ==
    TypeTraits<::fidl::WireRequest<
        ::test_protocols::WithProtocolEnds::ClientEnds>>::kPrimarySize);
static_assert(
    offsetof(
        ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>,
        in) == 0);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>>
    : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
template <>
struct IsResource<
    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>>
    : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::ClientEnds>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithProtocolEndsClientEndsTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(
    sizeof(::fidl::internal::TransactionalResponse<
           ::test_protocols::WithProtocolEnds::ClientEnds>) ==
    TypeTraits<::fidl::internal::TransactionalResponse<
        ::test_protocols::WithProtocolEnds::ClientEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::WithProtocolEnds::ClientEnds>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::WithProtocolEnds::ClientEnds>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithProtocolEndsClientEndsTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(
    sizeof(
        ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>) ==
    TypeTraits<::fidl::WireResponse<
        ::test_protocols::WithProtocolEnds::ClientEnds>>::kPrimarySize);
static_assert(
    offsetof(
        ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>,
        out) == 0);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>>
    : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
template <>
struct IsResource<
    ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>>
    : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::ServerEnds>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_WithProtocolEndsServerEndsRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(
    sizeof(::fidl::internal::TransactionalRequest<
           ::test_protocols::WithProtocolEnds::ServerEnds>) ==
    TypeTraits<::fidl::internal::TransactionalRequest<
        ::test_protocols::WithProtocolEnds::ServerEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::WithProtocolEnds::ServerEnds>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::WithProtocolEnds::ServerEnds>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_WithProtocolEndsServerEndsRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(
    sizeof(
        ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>) ==
    TypeTraits<::fidl::WireRequest<
        ::test_protocols::WithProtocolEnds::ServerEnds>>::kPrimarySize);
static_assert(
    offsetof(
        ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>,
        in) == 0);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>>
    : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
template <>
struct IsResource<
    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>>
    : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::ServerEnds>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithProtocolEndsServerEndsTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(
    sizeof(::fidl::internal::TransactionalResponse<
           ::test_protocols::WithProtocolEnds::ServerEnds>) ==
    TypeTraits<::fidl::internal::TransactionalResponse<
        ::test_protocols::WithProtocolEnds::ServerEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::WithProtocolEnds::ServerEnds>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::WithProtocolEnds::ServerEnds>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithProtocolEndsServerEndsTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(
    sizeof(
        ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>) ==
    TypeTraits<::fidl::WireResponse<
        ::test_protocols::WithProtocolEnds::ServerEnds>>::kPrimarySize);
static_assert(
    offsetof(
        ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>,
        out) == 0);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::true_type {};
template <>
struct IsResource<::fidl::WireRequest<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithProtocolEndsStructContainingEndsRequestTable;
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(
    sizeof(::fidl::internal::TransactionalRequest<
           ::test_protocols::WithProtocolEnds::StructContainingEnds>) ==
    TypeTraits<::fidl::internal::TransactionalRequest<
        ::test_protocols::WithProtocolEnds::StructContainingEnds>>::
        kPrimarySize);
static_assert(
    offsetof(::fidl::internal::TransactionalRequest<
                 ::test_protocols::WithProtocolEnds::StructContainingEnds>,
             header) == 0);
static_assert(
    offsetof(::fidl::internal::TransactionalRequest<
                 ::test_protocols::WithProtocolEnds::StructContainingEnds>,
             body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithProtocolEndsStructContainingEndsRequestTable;
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(
    sizeof(::fidl::WireRequest<
           ::test_protocols::WithProtocolEnds::StructContainingEnds>) ==
    TypeTraits<::fidl::WireRequest<::test_protocols::WithProtocolEnds::
                                       StructContainingEnds>>::kPrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<
                 ::test_protocols::WithProtocolEnds::StructContainingEnds>,
             in) == 0);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::true_type {};
template <>
struct IsResource<::fidl::WireResponse<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(
    sizeof(::fidl::internal::TransactionalResponse<
           ::test_protocols::WithProtocolEnds::StructContainingEnds>) ==
    TypeTraits<::fidl::internal::TransactionalResponse<
        ::test_protocols::WithProtocolEnds::StructContainingEnds>>::
        kPrimarySize);
static_assert(
    offsetof(::fidl::internal::TransactionalResponse<
                 ::test_protocols::WithProtocolEnds::StructContainingEnds>,
             header) == 0);
static_assert(
    offsetof(::fidl::internal::TransactionalResponse<
                 ::test_protocols::WithProtocolEnds::StructContainingEnds>,
             body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireResponse<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(
    sizeof(::fidl::WireResponse<
           ::test_protocols::WithProtocolEnds::StructContainingEnds>) ==
    TypeTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::
                                        StructContainingEnds>>::kPrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::test_protocols::WithProtocolEnds::StructContainingEnds>,
             out) == 0);
#endif  // __Fuchsia__

}  // namespace fidl
namespace test_protocols {
#ifdef __Fuchsia__
}  // namespace test_protocols
template <>
class ::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds> final
    : public ::fidl::Result {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ClientEnds>* request);
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ClientEnds>* request,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }
  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }
  const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::test_protocols::WithProtocolEnds::ClientEnds>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }

  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> bytes_;
};
template <>
class ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ClientEnds>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ClientEnds>* request);
  explicit WireUnownedResult(
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithProtocolEnds::ClientEnds>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<
          ::test_protocols::WithProtocolEnds::ClientEnds>>&& decoded,
      ::fidl::internal::IncomingTransportContext context)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }
  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<::fidl::internal::TransactionalResponse<
                 ::test_protocols::WithProtocolEnds::ClientEnds>*>(bytes_)
                 ->body);
  }
  const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<const ::fidl::internal::TransactionalResponse<
                 ::test_protocols::WithProtocolEnds::ClientEnds>*>(bytes_)
                 ->body);
  }

  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds> final
    : public ::fidl::Result {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ServerEnds>* request);
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ServerEnds>* request,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }
  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }
  const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::test_protocols::WithProtocolEnds::ServerEnds>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }

  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> bytes_;
};
template <>
class ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ServerEnds>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ServerEnds>* request);
  explicit WireUnownedResult(
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithProtocolEnds::ServerEnds>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<
          ::test_protocols::WithProtocolEnds::ServerEnds>>&& decoded,
      ::fidl::internal::IncomingTransportContext context)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }
  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<::fidl::internal::TransactionalResponse<
                 ::test_protocols::WithProtocolEnds::ServerEnds>*>(bytes_)
                 ->body);
  }
  const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<const ::fidl::internal::TransactionalResponse<
                 ::test_protocols::WithProtocolEnds::ServerEnds>*>(bytes_)
                 ->body);
  }

  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>
    final : public ::fidl::Result {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>* request);
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>* request,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }
  ::fidl::WireResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::test_protocols::WithProtocolEnds::StructContainingEnds>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::test_protocols::WithProtocolEnds::StructContainingEnds>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }

  ::fidl::WireResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<32> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>* request);
  explicit WireUnownedResult(
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>>&& decoded,
      ::fidl::internal::IncomingTransportContext context)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }
  ::fidl::WireResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return &(
        reinterpret_cast<::fidl::internal::TransactionalResponse<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>*>(bytes_)
            ->body);
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return &(
        reinterpret_cast<const ::fidl::internal::TransactionalResponse<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>*>(bytes_)
            ->body);
  }

  ::fidl::WireResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::test_protocols::WithProtocolEnds> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template <>
class ::fidl::WireAsyncEventHandler<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::test_protocols::WithProtocolEnds>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::test_protocols::WithProtocolEnds> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end);
};

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::WithProtocolEnds>
    final
    : public ::fidl::internal::IncomingEventDispatcher<
          ::fidl::WireAsyncEventHandler<::test_protocols::WithProtocolEnds>> {
 public:
  explicit WireEventDispatcher(
      ::fidl::WireAsyncEventHandler<::test_protocols::WithProtocolEnds>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::IncomingTransportContext transport_context) override;
};

// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |fidl::ClientEnd<::test_protocols::WithProtocolEnds>|,
// avoiding setting up a client.
template <>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::WithProtocolEnds>
    final : public ::fidl::internal::SyncEndpointManagedVeneer<
                ::fidl::internal::WireSyncClientImpl<
                    ::test_protocols::WithProtocolEnds>> {
 public:
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds> ClientEnds(
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithProtocolEnds::ClientEnds>
        _request{std::move(in)};
    return ::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds>(
        _client_end(), &_request);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds> ServerEnds(
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithProtocolEnds::ServerEnds>
        _request{std::move(in)};
    return ::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds>(
        _client_end(), &_request);
  }

  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>
  StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithProtocolEnds::StructContainingEnds>
        _request{std::move(in)};
    return ::fidl::WireResult<
        ::test_protocols::WithProtocolEnds::StructContainingEnds>(_client_end(),
                                                                  &_request);
  }

 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> _client_end()
      const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<
    ::test_protocols::WithProtocolEnds>
    final : public ::fidl::internal::SyncEndpointBufferVeneer<
                ::fidl::internal::WireSyncBufferClientImpl<
                    ::test_protocols::WithProtocolEnds>> {
 public:
  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ClientEnds>
  ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithProtocolEnds::ClientEnds>
        _request{std::move(in)};
    return ::fidl::WireUnownedResult<
        ::test_protocols::WithProtocolEnds::ClientEnds>(
        _client_end(), _allocator(), &_request);
  }

  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ServerEnds>
  ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithProtocolEnds::ServerEnds>
        _request{std::move(in)};
    return ::fidl::WireUnownedResult<
        ::test_protocols::WithProtocolEnds::ServerEnds>(
        _client_end(), _allocator(), &_request);
  }

  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>
  StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithProtocolEnds::StructContainingEnds>
        _request{std::move(in)};
    return ::fidl::WireUnownedResult<
        ::test_protocols::WithProtocolEnds::StructContainingEnds>(
        _client_end(), _allocator(), &_request);
  }

 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> _client_end()
      const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireCompleterImpl<
    ::test_protocols::WithProtocolEnds::ClientEnds>
    : public ::fidl::internal::CompleterImplBase<
          ::test_protocols::WithProtocolEnds::ClientEnds> {
 public:
  using CompleterImplBase::CompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithProtocolEnds::ClientEnds>
    : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out);
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::test_protocols::WithProtocolEnds::ClientEnds>
    : public ::fidl::CompleterBase,
      public ::fidl::internal::WireCompleterImpl<
          ::test_protocols::WithProtocolEnds::ClientEnds> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned,
                    bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::test_protocols::WithProtocolEnds::ClientEnds> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::test_protocols::WithProtocolEnds::ClientEnds>>;
};

template <>
class ::fidl::internal::WireCompleterImpl<
    ::test_protocols::WithProtocolEnds::ServerEnds>
    : public ::fidl::internal::CompleterImplBase<
          ::test_protocols::WithProtocolEnds::ServerEnds> {
 public:
  using CompleterImplBase::CompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithProtocolEnds::ServerEnds>
    : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out);
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::test_protocols::WithProtocolEnds::ServerEnds>
    : public ::fidl::CompleterBase,
      public ::fidl::internal::WireCompleterImpl<
          ::test_protocols::WithProtocolEnds::ServerEnds> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned,
                    bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::test_protocols::WithProtocolEnds::ServerEnds> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::test_protocols::WithProtocolEnds::ServerEnds>>;
};

template <>
class ::fidl::internal::WireCompleterImpl<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>
    : public ::fidl::internal::CompleterImplBase<
          ::test_protocols::WithProtocolEnds::StructContainingEnds> {
 public:
  using CompleterImplBase::CompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(::test_protocols::wire::ProtocolEnds&& out);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>
    : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(::test_protocols::wire::ProtocolEnds&& out);
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>
    : public ::fidl::CompleterBase,
      public ::fidl::internal::WireCompleterImpl<
          ::test_protocols::WithProtocolEnds::StructContainingEnds> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned,
                    bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::test_protocols::WithProtocolEnds::StructContainingEnds> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>>;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithProtocolEnds;

  using ClientEndsCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::WithProtocolEnds::ClientEnds>;
  using ClientEndsRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::WithProtocolEnds::ClientEnds>;

  virtual void ClientEnds(ClientEndsRequestView request,
                          ClientEndsCompleter::Sync& _completer) = 0;

  using ServerEndsCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::WithProtocolEnds::ServerEnds>;
  using ServerEndsRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::WithProtocolEnds::ServerEnds>;

  virtual void ServerEnds(ServerEndsRequestView request,
                          ServerEndsCompleter::Sync& _completer) = 0;

  using StructContainingEndsCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>;
  using StructContainingEndsRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>;

  virtual void StructContainingEnds(
      StructContainingEndsRequestView request,
      StructContainingEndsCompleter::Sync& _completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};
namespace test_protocols {
#endif  // __Fuchsia__

__LOCAL extern "C" const fidl_type_t
    test_protocols_ManyParametersFifteenRequestTable;

}  // namespace test_protocols
template <>
struct ::fidl::internal::WireOrdinal<::test_protocols::ManyParameters::Fifteen>
    final {
  static constexpr uint64_t value = 6423043252952467815lu;
};

namespace test_protocols {}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<::test_protocols::ManyParameters> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::ManyParameters>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::test_protocols::ManyParameters>* impl,
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);
  static void Dispatch(
      ::fidl::WireServer<::test_protocols::ManyParameters>* impl,
      ::fidl::IncomingMessage&& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen> final {
  FIDL_ALIGNDECL
  bool p1;
  bool p2;
  bool p3;
  bool p4;
  bool p5;
  bool p6;
  bool p7;
  bool p8;
  bool p9;
  bool p10;
  bool p11;
  bool p12;
  bool p13;
  bool p14;
  bool p15;

  explicit WireRequest(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6,
                       bool p7, bool p8, bool p9, bool p10, bool p11, bool p12,
                       bool p13, bool p14, bool p15)
      : p1(p1),
        p2(p2),
        p3(p3),
        p4(p4),
        p5(p5),
        p6(p6),
        p7(p7),
        p8(p8),
        p9(p9),
        p10(p10),
        p11(p11),
        p12(p12),
        p13(p13),
        p14(p14),
        p15(p15) {}
  WireRequest() = default;
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::ManyParameters::Fifteen>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen> body;
  explicit TransactionalRequest(bool p1, bool p2, bool p3, bool p4, bool p5,
                                bool p6, bool p7, bool p8, bool p9, bool p10,
                                bool p11, bool p12, bool p13, bool p14,
                                bool p15)
      : body(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>(
            p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15)) {
    _InitHeader();
  }
  TransactionalRequest() { _InitHeader(); }

 private:
  void _InitHeader();
};

namespace fidl {

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::ManyParameters::Fifteen>> : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::ManyParameters::Fifteen>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::ManyParameters::Fifteen>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_ManyParametersFifteenRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(15 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(15 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<
                     ::test_protocols::ManyParameters::Fifteen>) ==
              TypeTraits<::fidl::internal::TransactionalRequest<
                  ::test_protocols::ManyParameters::Fifteen>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::ManyParameters::Fifteen>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::ManyParameters::Fifteen>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_ManyParametersFifteenRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(15);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(15);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(
    sizeof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>) ==
    TypeTraits<::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>>::
        kPrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>,
             p1) == 0);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>,
             p2) == 1);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>,
             p3) == 2);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>,
             p4) == 3);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>,
             p5) == 4);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>,
             p6) == 5);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>,
             p7) == 6);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>,
             p8) == 7);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>,
             p9) == 8);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>,
             p10) == 9);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>,
             p11) == 10);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>,
             p12) == 11);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>,
             p13) == 12);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>,
             p14) == 13);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>,
             p15) == 14);

}  // namespace fidl
namespace test_protocols {
#ifdef __Fuchsia__
}  // namespace test_protocols
template <>
class ::fidl::WireResult<::test_protocols::ManyParameters::Fifteen> final
    : public ::fidl::Result {
 public:
  WireResult(::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::ManyParameters::Fifteen>* request);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<::test_protocols::ManyParameters::Fifteen> final
    : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ManyParameters::Fifteen>* request);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::test_protocols::ManyParameters> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template <>
class ::fidl::WireAsyncEventHandler<::test_protocols::ManyParameters>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::test_protocols::ManyParameters>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::test_protocols::ManyParameters>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::test_protocols::ManyParameters> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client_end);
};

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::ManyParameters>
    final
    : public ::fidl::internal::IncomingEventDispatcher<
          ::fidl::WireAsyncEventHandler<::test_protocols::ManyParameters>> {
 public:
  explicit WireEventDispatcher(
      ::fidl::WireAsyncEventHandler<::test_protocols::ManyParameters>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::IncomingTransportContext transport_context) override;
};

// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |fidl::ClientEnd<::test_protocols::ManyParameters>|,
// avoiding setting up a client.
template <>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::ManyParameters>
    final : public ::fidl::internal::SyncEndpointManagedVeneer<
                ::fidl::internal::WireSyncClientImpl<
                    ::test_protocols::ManyParameters>> {
 public:
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::ManyParameters::Fifteen> Fifteen(
      bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8,
      bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ManyParameters::Fifteen>
        _request{p1, p2,  p3,  p4,  p5,  p6,  p7, p8,
                 p9, p10, p11, p12, p13, p14, p15};
    return ::fidl::WireResult<::test_protocols::ManyParameters::Fifteen>(
        _client_end(), &_request);
  }

 private:
  ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> _client_end()
      const {
    return ::fidl::UnownedClientEnd<::test_protocols::ManyParameters>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<
    ::test_protocols::ManyParameters>
    final : public ::fidl::internal::SyncEndpointBufferVeneer<
                ::fidl::internal::WireSyncBufferClientImpl<
                    ::test_protocols::ManyParameters>> {
 public:
  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<::test_protocols::ManyParameters::Fifteen> Fifteen(
      bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8,
      bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ManyParameters::Fifteen>
        _request{p1, p2,  p3,  p4,  p5,  p6,  p7, p8,
                 p9, p10, p11, p12, p13, p14, p15};
    return ::fidl::WireUnownedResult<::test_protocols::ManyParameters::Fifteen>(
        _client_end(), _allocator(), &_request);
  }

 private:
  ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> _client_end()
      const {
    return ::fidl::UnownedClientEnd<::test_protocols::ManyParameters>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::test_protocols::ManyParameters>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::ManyParameters;

  using FifteenCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::ManyParameters::Fifteen>;
  using FifteenRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::ManyParameters::Fifteen>;

  virtual void Fifteen(FifteenRequestView request,
                       FifteenCompleter::Sync& _completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};
namespace test_protocols {
#endif  // __Fuchsia__

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;
}  // namespace test_protocols
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>
    final {
  static constexpr uint64_t value = 268248568430741139lu;
};
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final {
  static constexpr uint64_t value = 6930994461233198567lu;
};
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>
    final {
  static constexpr uint64_t value = 5491891352371277635lu;
};
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::WithErrorSyntax::HandleInResult>
    final {
  static constexpr uint64_t value = 1371676333068455103lu;
};

namespace test_protocols {}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<::test_protocols::WithErrorSyntax> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::WithErrorSyntax>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::test_protocols::WithErrorSyntax>* impl,
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);
  static void Dispatch(
      ::fidl::WireServer<::test_protocols::WithErrorSyntax>* impl,
      ::fidl::IncomingMessage&& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>
    final {
  WireRequest() = default;
  using ResponseType =
      ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>;
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalRequest() { _InitHeader(); }
  using ResponseType = ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>;

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>
    final {
  using Result = test_protocols::wire::WithErrorSyntaxResponseAsStructResult;

  FIDL_ALIGNDECL
  ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result;

  explicit WireResponse(
      ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result)
      : result(result) {}
  WireResponse() = default;
};

template <>
struct ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>
      body;
  explicit TransactionalResponse(
      ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result)
      : body(::fidl::WireResponse<
             ::test_protocols::WithErrorSyntax::ResponseAsStruct>(result)) {
    _InitHeader();
  }
  TransactionalResponse() { _InitHeader(); }

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final {
  WireRequest() = default;
  using ResponseType =
      ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>;
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalRequest() { _InitHeader(); }
  using ResponseType = ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>;

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final {
  using Result = test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult;

  FIDL_ALIGNDECL
  ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result;

  explicit WireResponse(
      ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result)
      : result(result) {}
  WireResponse() = default;
};

template <>
struct ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
      body;
  explicit TransactionalResponse(
      ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result)
      : body(::fidl::WireResponse<
             ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(result)) {
    _InitHeader();
  }
  TransactionalResponse() { _InitHeader(); }

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>
    final {
  WireRequest() = default;
  using ResponseType =
      ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>;
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalRequest() { _InitHeader(); }
  using ResponseType = ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>;

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>
    final {
  using Result = test_protocols::wire::WithErrorSyntaxErrorAsEnumResult;

  FIDL_ALIGNDECL
  ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result;

  explicit WireResponse(
      ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result)
      : result(result) {}
  WireResponse() = default;
};

template <>
struct ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum> body;
  explicit TransactionalResponse(
      ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result)
      : body(::fidl::WireResponse<
             ::test_protocols::WithErrorSyntax::ErrorAsEnum>(result)) {
    _InitHeader();
  }
  TransactionalResponse() { _InitHeader(); }

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireRequest<::test_protocols::WithErrorSyntax::HandleInResult>
    final {
  WireRequest() = default;
  using ResponseType =
      ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>;
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::HandleInResult>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalRequest() { _InitHeader(); }
  using ResponseType = ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::HandleInResult>;

 private:
  void _InitHeader();
};
#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>
    final {
  using Result = test_protocols::wire::WithErrorSyntaxHandleInResultResult;

  FIDL_ALIGNDECL
  ::test_protocols::wire::WithErrorSyntaxHandleInResultResult result;

  explicit WireResponse(
      ::test_protocols::wire::WithErrorSyntaxHandleInResultResult result)
      : result(std::move(result)) {}
  WireResponse() = default;
  void _CloseHandles();
};

template <>
struct ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::HandleInResult>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult> body;
  explicit TransactionalResponse(
      ::test_protocols::wire::WithErrorSyntaxHandleInResultResult result)
      : body(::fidl::WireResponse<
             ::test_protocols::WithErrorSyntax::HandleInResult>(
            std::move(result))) {
    _InitHeader();
  }
  TransactionalResponse() { _InitHeader(); }
  void _CloseHandles() { body._CloseHandles(); }

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

namespace fidl {

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>>
    : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(
    sizeof(::fidl::internal::TransactionalRequest<
           ::test_protocols::WithErrorSyntax::ResponseAsStruct>) ==
    TypeTraits<::fidl::internal::TransactionalRequest<
        ::test_protocols::WithErrorSyntax::ResponseAsStruct>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::WithErrorSyntax::ResponseAsStruct>,
                       header) == 0);

template <>
struct TypeTraits<
    ::fidl::WireRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>>
    : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(24 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(
    sizeof(::fidl::internal::TransactionalResponse<
           ::test_protocols::WithErrorSyntax::ResponseAsStruct>) ==
    TypeTraits<::fidl::internal::TransactionalResponse<
        ::test_protocols::WithErrorSyntax::ResponseAsStruct>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::WithErrorSyntax::ResponseAsStruct>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::WithErrorSyntax::ResponseAsStruct>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(24);
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(
    sizeof(::fidl::WireResponse<
           ::test_protocols::WithErrorSyntax::ResponseAsStruct>) ==
    TypeTraits<::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::ResponseAsStruct>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<
                           ::test_protocols::WithErrorSyntax::ResponseAsStruct>,
                       result) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(
    sizeof(::fidl::internal::TransactionalRequest<
           ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>) ==
    TypeTraits<::fidl::internal::TransactionalRequest<
        ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
                       header) == 0);

template <>
struct TypeTraits<
    ::fidl::WireRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(24 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(
    sizeof(::fidl::internal::TransactionalResponse<
           ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>) ==
    TypeTraits<::fidl::internal::TransactionalResponse<
        ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(24);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(
    sizeof(::fidl::WireResponse<
           ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>) ==
    TypeTraits<::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<
                           ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
                       result) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>> : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(
    sizeof(::fidl::internal::TransactionalRequest<
           ::test_protocols::WithErrorSyntax::ErrorAsEnum>) ==
    TypeTraits<::fidl::internal::TransactionalRequest<
        ::test_protocols::WithErrorSyntax::ErrorAsEnum>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::WithErrorSyntax::ErrorAsEnum>,
                       header) == 0);

template <>
struct TypeTraits<
    ::fidl::WireRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>> : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(24 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(
    sizeof(::fidl::internal::TransactionalResponse<
           ::test_protocols::WithErrorSyntax::ErrorAsEnum>) ==
    TypeTraits<::fidl::internal::TransactionalResponse<
        ::test_protocols::WithErrorSyntax::ErrorAsEnum>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::WithErrorSyntax::ErrorAsEnum>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::WithErrorSyntax::ErrorAsEnum>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(24);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(
    sizeof(
        ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>) ==
    TypeTraits<::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::ErrorAsEnum>>::kPrimarySize);
static_assert(
    offsetof(
        ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>,
        result) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::HandleInResult>>
    : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireRequest<::test_protocols::WithErrorSyntax::HandleInResult>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::HandleInResult>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireRequest<::test_protocols::WithErrorSyntax::HandleInResult>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::HandleInResult>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(
    sizeof(::fidl::internal::TransactionalRequest<
           ::test_protocols::WithErrorSyntax::HandleInResult>) ==
    TypeTraits<::fidl::internal::TransactionalRequest<
        ::test_protocols::WithErrorSyntax::HandleInResult>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::WithErrorSyntax::HandleInResult>,
                       header) == 0);

template <>
struct TypeTraits<
    ::fidl::WireRequest<::test_protocols::WithErrorSyntax::HandleInResult>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::HandleInResult>>
    : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::HandleInResult>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>>
    : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::HandleInResult>>
    : public std::true_type {};
template <>
struct IsResource<
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>>
    : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::HandleInResult>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(24 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(
    sizeof(::fidl::internal::TransactionalResponse<
           ::test_protocols::WithErrorSyntax::HandleInResult>) ==
    TypeTraits<::fidl::internal::TransactionalResponse<
        ::test_protocols::WithErrorSyntax::HandleInResult>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::WithErrorSyntax::HandleInResult>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::WithErrorSyntax::HandleInResult>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(24);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(
    sizeof(::fidl::WireResponse<
           ::test_protocols::WithErrorSyntax::HandleInResult>) ==
    TypeTraits<::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::HandleInResult>>::kPrimarySize);
static_assert(
    offsetof(
        ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>,
        result) == 0);
#endif  // __Fuchsia__

}  // namespace fidl
namespace test_protocols {
#ifdef __Fuchsia__
}  // namespace test_protocols
template <>
class ::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>
    final : public ::fidl::Result {
 public:
  WireResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::WithErrorSyntax::ResponseAsStruct>* request);
  WireResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::WithErrorSyntax::ResponseAsStruct>* request,
             zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;
  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::ResponseAsStruct>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::ResponseAsStruct>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<64> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>* request);
  explicit WireUnownedResult(
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>>&& decoded,
      ::fidl::internal::IncomingTransportContext context)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<::fidl::internal::TransactionalResponse<
                 ::test_protocols::WithErrorSyntax::ResponseAsStruct>*>(bytes_)
                 ->body);
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<const ::fidl::internal::TransactionalResponse<
                 ::test_protocols::WithErrorSyntax::ResponseAsStruct>*>(bytes_)
                 ->body);
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final : public ::fidl::Result {
 public:
  WireResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* request);
  WireResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* request,
             zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;
  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<48> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* request);
  explicit WireUnownedResult(
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>&& decoded,
      ::fidl::internal::IncomingTransportContext context)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<::fidl::internal::TransactionalResponse<
                 ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>*>(bytes_)
                 ->body);
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<const ::fidl::internal::TransactionalResponse<
                 ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>*>(bytes_)
                 ->body);
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum> final
    : public ::fidl::Result {
 public:
  WireResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::WithErrorSyntax::ErrorAsEnum>* request);
  WireResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::WithErrorSyntax::ErrorAsEnum>* request,
             zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;
  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }
  const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::ErrorAsEnum>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<48> bytes_;
};
template <>
class ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>* request);
  explicit WireUnownedResult(
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>>&& decoded,
      ::fidl::internal::IncomingTransportContext context)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<::fidl::internal::TransactionalResponse<
                 ::test_protocols::WithErrorSyntax::ErrorAsEnum>*>(bytes_)
                 ->body);
  }
  const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<const ::fidl::internal::TransactionalResponse<
                 ::test_protocols::WithErrorSyntax::ErrorAsEnum>*>(bytes_)
                 ->body);
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>
    final : public ::fidl::Result {
 public:
  WireResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::WithErrorSyntax::HandleInResult>* request);
  WireResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::WithErrorSyntax::HandleInResult>* request,
             zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }
  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::HandleInResult>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }
  const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::HandleInResult>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<48> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::test_protocols::WithErrorSyntax::HandleInResult>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::HandleInResult>* request);
  explicit WireUnownedResult(
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::HandleInResult>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::HandleInResult>>&& decoded,
      ::fidl::internal::IncomingTransportContext context)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }
  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<::fidl::internal::TransactionalResponse<
                 ::test_protocols::WithErrorSyntax::HandleInResult>*>(bytes_)
                 ->body);
  }
  const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<const ::fidl::internal::TransactionalResponse<
                 ::test_protocols::WithErrorSyntax::HandleInResult>*>(bytes_)
                 ->body);
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::test_protocols::WithErrorSyntax> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template <>
class ::fidl::WireAsyncEventHandler<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::test_protocols::WithErrorSyntax>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::test_protocols::WithErrorSyntax> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end);
};

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::WithErrorSyntax>
    final
    : public ::fidl::internal::IncomingEventDispatcher<
          ::fidl::WireAsyncEventHandler<::test_protocols::WithErrorSyntax>> {
 public:
  explicit WireEventDispatcher(
      ::fidl::WireAsyncEventHandler<::test_protocols::WithErrorSyntax>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::IncomingTransportContext transport_context) override;
};

// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |fidl::ClientEnd<::test_protocols::WithErrorSyntax>|,
// avoiding setting up a client.
template <>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::WithErrorSyntax>
    final : public ::fidl::internal::SyncEndpointManagedVeneer<
                ::fidl::internal::WireSyncClientImpl<
                    ::test_protocols::WithErrorSyntax>> {
 public:
  // Allocates 72 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>
  ResponseAsStruct() {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithErrorSyntax::ResponseAsStruct>
        _request{};
    return ::fidl::WireResult<
        ::test_protocols::WithErrorSyntax::ResponseAsStruct>(_client_end(),
                                                             &_request);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  ErrorAsPrimitive() {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
        _request{};
    return ::fidl::WireResult<
        ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(_client_end(),
                                                             &_request);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>
  ErrorAsEnum() {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithErrorSyntax::ErrorAsEnum>
        _request{};
    return ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>(
        _client_end(), &_request);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>
  HandleInResult() {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithErrorSyntax::HandleInResult>
        _request{};
    return ::fidl::WireResult<
        ::test_protocols::WithErrorSyntax::HandleInResult>(_client_end(),
                                                           &_request);
  }

 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> _client_end()
      const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<
    ::test_protocols::WithErrorSyntax>
    final : public ::fidl::internal::SyncEndpointBufferVeneer<
                ::fidl::internal::WireSyncBufferClientImpl<
                    ::test_protocols::WithErrorSyntax>> {
 public:
  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>
  ResponseAsStruct() {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithErrorSyntax::ResponseAsStruct>
        _request{};
    return ::fidl::WireUnownedResult<
        ::test_protocols::WithErrorSyntax::ResponseAsStruct>(
        _client_end(), _allocator(), &_request);
  }

  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  ErrorAsPrimitive() {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
        _request{};
    return ::fidl::WireUnownedResult<
        ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(
        _client_end(), _allocator(), &_request);
  }

  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>
  ErrorAsEnum() {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithErrorSyntax::ErrorAsEnum>
        _request{};
    return ::fidl::WireUnownedResult<
        ::test_protocols::WithErrorSyntax::ErrorAsEnum>(
        _client_end(), _allocator(), &_request);
  }

  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::HandleInResult>
  HandleInResult() {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithErrorSyntax::HandleInResult>
        _request{};
    return ::fidl::WireUnownedResult<
        ::test_protocols::WithErrorSyntax::HandleInResult>(
        _client_end(), _allocator(), &_request);
  }

 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> _client_end()
      const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>
    : public ::fidl::internal::CompleterImplBase<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct> {
 public:
  using CompleterImplBase::CompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(
      ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result);
  ::fidl::Result ReplySuccess(int64_t a, int64_t b, int64_t c);
  ::fidl::Result ReplyError(uint32_t error);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>
    : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(
      ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result);
  ::fidl::Result ReplySuccess(int64_t a, int64_t b, int64_t c);
  ::fidl::Result ReplyError(uint32_t error);
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>
    : public ::fidl::CompleterBase,
      public ::fidl::internal::WireCompleterImpl<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned,
                    bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>>;
};

template <>
class ::fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    : public ::fidl::internal::CompleterImplBase<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
 public:
  using CompleterImplBase::CompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(
      ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result);
  ::fidl::Result ReplySuccess();
  ::fidl::Result ReplyError(uint32_t error);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(
      ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result);
  ::fidl::Result ReplySuccess();
  ::fidl::Result ReplyError(uint32_t error);
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    : public ::fidl::CompleterBase,
      public ::fidl::internal::WireCompleterImpl<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned,
                    bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>;
};

template <>
class ::fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>
    : public ::fidl::internal::CompleterImplBase<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum> {
 public:
  using CompleterImplBase::CompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(
      ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result);
  ::fidl::Result ReplySuccess();
  ::fidl::Result ReplyError(::test_protocols::wire::ErrorEnum error);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>
    : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(
      ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result);
  ::fidl::Result ReplySuccess();
  ::fidl::Result ReplyError(::test_protocols::wire::ErrorEnum error);
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>
    : public ::fidl::CompleterBase,
      public ::fidl::internal::WireCompleterImpl<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned,
                    bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>>;
};

template <>
class ::fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::HandleInResult>
    : public ::fidl::internal::CompleterImplBase<
          ::test_protocols::WithErrorSyntax::HandleInResult> {
 public:
  using CompleterImplBase::CompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(
      ::test_protocols::wire::WithErrorSyntaxHandleInResultResult result);
  ::fidl::Result ReplySuccess(::zx::handle&& h);
  ::fidl::Result ReplyError(uint32_t error);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::HandleInResult>
    : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(
      ::test_protocols::wire::WithErrorSyntaxHandleInResultResult result);
  ::fidl::Result ReplySuccess(::zx::handle&& h);
  ::fidl::Result ReplyError(uint32_t error);
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::test_protocols::WithErrorSyntax::HandleInResult>
    : public ::fidl::CompleterBase,
      public ::fidl::internal::WireCompleterImpl<
          ::test_protocols::WithErrorSyntax::HandleInResult> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned,
                    bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::test_protocols::WithErrorSyntax::HandleInResult> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::test_protocols::WithErrorSyntax::HandleInResult>>;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithErrorSyntax;

  using ResponseAsStructCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>;
  using ResponseAsStructRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>;

  virtual void ResponseAsStruct(
      ResponseAsStructRequestView request,
      ResponseAsStructCompleter::Sync& _completer) = 0;

  using ErrorAsPrimitiveCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>;
  using ErrorAsPrimitiveRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>;

  virtual void ErrorAsPrimitive(
      ErrorAsPrimitiveRequestView request,
      ErrorAsPrimitiveCompleter::Sync& _completer) = 0;

  using ErrorAsEnumCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>;
  using ErrorAsEnumRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>;

  virtual void ErrorAsEnum(ErrorAsEnumRequestView request,
                           ErrorAsEnumCompleter::Sync& _completer) = 0;

  using HandleInResultCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::WithErrorSyntax::HandleInResult>;
  using HandleInResultRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::WithErrorSyntax::HandleInResult>;

  virtual void HandleInResult(HandleInResultRequestView request,
                              HandleInResultCompleter::Sync& _completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::DiscoverableProtocol::Method>
    final {
  static constexpr uint64_t value = 3455873048082739435lu;
};

namespace test_protocols {}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<
    ::test_protocols::DiscoverableProtocol> {
  static constexpr char DiscoverableName[] =
      "test.protocols.DiscoverableProtocol";
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::test_protocols::DiscoverableProtocol>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::test_protocols::DiscoverableProtocol>* impl,
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);
  static void Dispatch(
      ::fidl::WireServer<::test_protocols::DiscoverableProtocol>* impl,
      ::fidl::IncomingMessage&& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<::test_protocols::DiscoverableProtocol::Method>
    final {
  WireRequest() = default;
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::DiscoverableProtocol::Method>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalRequest() { _InitHeader(); }

 private:
  void _InitHeader();
};

namespace fidl {

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::DiscoverableProtocol::Method>> : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireRequest<::test_protocols::DiscoverableProtocol::Method>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::DiscoverableProtocol::Method>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireRequest<::test_protocols::DiscoverableProtocol::Method>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::DiscoverableProtocol::Method>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(
    sizeof(::fidl::internal::TransactionalRequest<
           ::test_protocols::DiscoverableProtocol::Method>) ==
    TypeTraits<::fidl::internal::TransactionalRequest<
        ::test_protocols::DiscoverableProtocol::Method>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::DiscoverableProtocol::Method>,
                       header) == 0);

template <>
struct TypeTraits<
    ::fidl::WireRequest<::test_protocols::DiscoverableProtocol::Method>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

}  // namespace fidl
namespace test_protocols {
#ifdef __Fuchsia__
}  // namespace test_protocols
template <>
class ::fidl::WireResult<::test_protocols::DiscoverableProtocol::Method> final
    : public ::fidl::Result {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> client,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::DiscoverableProtocol::Method>* request);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<::test_protocols::DiscoverableProtocol::Method>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol>
          client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::DiscoverableProtocol::Method>* request);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::test_protocols::DiscoverableProtocol> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template <>
class ::fidl::WireAsyncEventHandler<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::test_protocols::DiscoverableProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::test_protocols::DiscoverableProtocol> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol>
          client_end);
};

template <>
class ::fidl::internal::WireEventDispatcher<
    ::test_protocols::DiscoverableProtocol>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::WireAsyncEventHandler<
                    ::test_protocols::DiscoverableProtocol>> {
 public:
  explicit WireEventDispatcher(
      ::fidl::WireAsyncEventHandler<::test_protocols::DiscoverableProtocol>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::IncomingTransportContext transport_context) override;
};

// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a
// |fidl::ClientEnd<::test_protocols::DiscoverableProtocol>|, avoiding setting
// up a client.
template <>
class ::fidl::internal::WireSyncClientImpl<
    ::test_protocols::DiscoverableProtocol>
    final : public ::fidl::internal::SyncEndpointManagedVeneer<
                ::fidl::internal::WireSyncClientImpl<
                    ::test_protocols::DiscoverableProtocol>> {
 public:
  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::DiscoverableProtocol::Method> Method() {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::DiscoverableProtocol::Method>
        _request{};
    return ::fidl::WireResult<::test_protocols::DiscoverableProtocol::Method>(
        _client_end(), &_request);
  }

 private:
  ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> _client_end()
      const {
    return ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<
    ::test_protocols::DiscoverableProtocol>
    final : public ::fidl::internal::SyncEndpointBufferVeneer<
                ::fidl::internal::WireSyncBufferClientImpl<
                    ::test_protocols::DiscoverableProtocol>> {
 public:
  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<::test_protocols::DiscoverableProtocol::Method>
  Method() {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::DiscoverableProtocol::Method>
        _request{};
    return ::fidl::WireUnownedResult<
        ::test_protocols::DiscoverableProtocol::Method>(
        _client_end(), _allocator(), &_request);
  }

 private:
  ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> _client_end()
      const {
    return ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::DiscoverableProtocol;

  using MethodCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::DiscoverableProtocol::Method>;
  using MethodRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::DiscoverableProtocol::Method>;

  virtual void Method(MethodRequestView request,
                      MethodCompleter::Sync& _completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};
namespace test_protocols {
#endif  // __Fuchsia__

__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodARequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolEventARequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodBRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodBTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolTakeHandleRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketTopResponseTable;
}  // namespace test_protocols
template <>
struct ::fidl::internal::WireOrdinal<::test_protocols::ChannelProtocol::MethodA>
    final {
  static constexpr uint64_t value = 3155008840945527714lu;
};
template <>
struct ::fidl::internal::WireOrdinal<::test_protocols::ChannelProtocol::EventA>
    final {
  static constexpr uint64_t value = 2220452875311597006lu;
};
template <>
struct ::fidl::internal::WireOrdinal<::test_protocols::ChannelProtocol::MethodB>
    final {
  static constexpr uint64_t value = 8903004957800778182lu;
};
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::ChannelProtocol::TakeHandle>
    final {
  static constexpr uint64_t value = 591935489944717925lu;
};
template <>
struct ::fidl::internal::WireOrdinal<
    ::test_protocols::ChannelProtocol::MutateSocket>
    final {
  static constexpr uint64_t value = 7411742788430590287lu;
};

namespace test_protocols {}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<::test_protocols::ChannelProtocol> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::ChannelProtocol>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::test_protocols::ChannelProtocol>* impl,
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);
  static void Dispatch(
      ::fidl::WireServer<::test_protocols::ChannelProtocol>* impl,
      ::fidl::IncomingMessage&& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA> final {
  FIDL_ALIGNDECL
  int64_t a;
  int64_t b;

  explicit WireRequest(int64_t a, int64_t b) : a(a), b(b) {}
  WireRequest() = default;
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::MethodA>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA> body;
  explicit TransactionalRequest(int64_t a, int64_t b)
      : body(::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>(
            a, b)) {
    _InitHeader();
  }
  TransactionalRequest() { _InitHeader(); }

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA> final {
  FIDL_ALIGNDECL
  int64_t a;
  int64_t b;

  explicit WireEvent(int64_t a, int64_t b) : a(a), b(b) {}
  WireEvent() = default;
};

template <>
struct ::fidl::internal::TransactionalEvent<
    ::test_protocols::ChannelProtocol::EventA>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA> body;
  explicit TransactionalEvent(int64_t a, int64_t b)
      : body(::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>(a,
                                                                          b)) {
    _InitHeader();
  }
  TransactionalEvent() { _InitHeader(); }

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB> final {
  FIDL_ALIGNDECL
  int64_t a;
  int64_t b;

  explicit WireRequest(int64_t a, int64_t b) : a(a), b(b) {}
  WireRequest() = default;
  using ResponseType =
      ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>;
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::MethodB>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB> body;
  explicit TransactionalRequest(int64_t a, int64_t b)
      : body(::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>(
            a, b)) {
    _InitHeader();
  }
  TransactionalRequest() { _InitHeader(); }
  using ResponseType = ::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MethodB>;

 private:
  void _InitHeader();
};

template <>
struct ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB> final {
  FIDL_ALIGNDECL
  int64_t result;

  explicit WireResponse(int64_t result) : result(result) {}
  WireResponse() = default;
};

template <>
struct ::fidl::internal::TransactionalResponse<
    ::test_protocols::ChannelProtocol::MethodB>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB> body;
  explicit TransactionalResponse(int64_t result)
      : body(::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>(
            result)) {
    _InitHeader();
  }
  TransactionalResponse() { _InitHeader(); }

 private:
  void _InitHeader();
};
#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>
    final {
  FIDL_ALIGNDECL
  ::zx::handle h;

  explicit WireRequest(::zx::handle&& h) : h(std::move(h)) {}
  WireRequest() = default;
  void _CloseHandles();
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::TakeHandle>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle> body;
  explicit TransactionalRequest(::zx::handle&& h)
      : body(::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>(
            std::move(h))) {
    _InitHeader();
  }
  TransactionalRequest() { _InitHeader(); }
  void _CloseHandles() { body._CloseHandles(); }

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireResponse<::test_protocols::ChannelProtocol::TakeHandle>
    final {
  WireResponse() = default;
};

template <>
struct ::fidl::internal::TransactionalResponse<
    ::test_protocols::ChannelProtocol::TakeHandle>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalResponse() { _InitHeader(); }

 private:
  void _InitHeader();
};
#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>
    final {
  FIDL_ALIGNDECL
  ::zx::socket a;

  explicit WireRequest(::zx::socket&& a) : a(std::move(a)) {}
  WireRequest() = default;
  using ResponseType =
      ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>;
  void _CloseHandles();
};

template <>
struct ::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::MutateSocket>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket> body;
  explicit TransactionalRequest(::zx::socket&& a)
      : body(::fidl::WireRequest<
             ::test_protocols::ChannelProtocol::MutateSocket>(std::move(a))) {
    _InitHeader();
  }
  TransactionalRequest() { _InitHeader(); }
  using ResponseType = ::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MutateSocket>;
  void _CloseHandles() { body._CloseHandles(); }

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>
    final {
  FIDL_ALIGNDECL
  ::zx::socket b;

  explicit WireResponse(::zx::socket&& b) : b(std::move(b)) {}
  WireResponse() = default;
  void _CloseHandles();
};

template <>
struct ::fidl::internal::TransactionalResponse<
    ::test_protocols::ChannelProtocol::MutateSocket>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket> body;
  explicit TransactionalResponse(::zx::socket&& b)
      : body(::fidl::WireResponse<
             ::test_protocols::ChannelProtocol::MutateSocket>(std::move(b))) {
    _InitHeader();
  }
  TransactionalResponse() { _InitHeader(); }
  void _CloseHandles() { body._CloseHandles(); }

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

namespace fidl {

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::MethodA>> : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::MethodA>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::MethodA>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_ChannelProtocolMethodARequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<
                     ::test_protocols::ChannelProtocol::MethodA>) ==
              TypeTraits<::fidl::internal::TransactionalRequest<
                  ::test_protocols::ChannelProtocol::MethodA>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::ChannelProtocol::MethodA>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::ChannelProtocol::MethodA>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_ChannelProtocolMethodARequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(
    sizeof(::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>) ==
    TypeTraits<::fidl::WireRequest<
        ::test_protocols::ChannelProtocol::MethodA>>::kPrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>,
             a) == 0);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>,
             b) == 8);

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<
    ::test_protocols::ChannelProtocol::EventA>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<
    ::test_protocols::ChannelProtocol::EventA>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<
    ::test_protocols::ChannelProtocol::EventA>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_ChannelProtocolEventARequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<
                     ::test_protocols::ChannelProtocol::EventA>) ==
              TypeTraits<::fidl::internal::TransactionalEvent<
                  ::test_protocols::ChannelProtocol::EventA>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<
                           ::test_protocols::ChannelProtocol::EventA>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalEvent<
                           ::test_protocols::ChannelProtocol::EventA>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_ChannelProtocolEventARequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(
    sizeof(::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>) ==
    TypeTraits<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>>::
        kPrimarySize);
static_assert(
    offsetof(::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>, a) ==
    0);
static_assert(
    offsetof(::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>, b) ==
    8);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::MethodB>> : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::MethodB>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::MethodB>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_ChannelProtocolMethodBRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<
                     ::test_protocols::ChannelProtocol::MethodB>) ==
              TypeTraits<::fidl::internal::TransactionalRequest<
                  ::test_protocols::ChannelProtocol::MethodB>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::ChannelProtocol::MethodB>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::ChannelProtocol::MethodB>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_ChannelProtocolMethodBRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(
    sizeof(::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>) ==
    TypeTraits<::fidl::WireRequest<
        ::test_protocols::ChannelProtocol::MethodB>>::kPrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>,
             a) == 0);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>,
             b) == 8);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<
    ::test_protocols::ChannelProtocol::MethodB>> : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<
    ::test_protocols::ChannelProtocol::MethodB>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<
    ::test_protocols::ChannelProtocol::MethodB>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_ChannelProtocolMethodBTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<
                     ::test_protocols::ChannelProtocol::MethodB>) ==
              TypeTraits<::fidl::internal::TransactionalResponse<
                  ::test_protocols::ChannelProtocol::MethodB>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::ChannelProtocol::MethodB>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::ChannelProtocol::MethodB>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_ChannelProtocolMethodBTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(8);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(8);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(
    sizeof(::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>) ==
    TypeTraits<::fidl::WireResponse<
        ::test_protocols::ChannelProtocol::MethodB>>::kPrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>,
             result) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::TakeHandle>> : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::TakeHandle>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>>
    : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::TakeHandle>> : public std::true_type {};
template <>
struct IsResource<
    ::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>>
    : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::TakeHandle>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_ChannelProtocolTakeHandleRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(
    sizeof(::fidl::internal::TransactionalRequest<
           ::test_protocols::ChannelProtocol::TakeHandle>) ==
    TypeTraits<::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::TakeHandle>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::ChannelProtocol::TakeHandle>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::ChannelProtocol::TakeHandle>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_ChannelProtocolTakeHandleRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(
    sizeof(
        ::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>) ==
    TypeTraits<::fidl::WireRequest<
        ::test_protocols::ChannelProtocol::TakeHandle>>::kPrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>,
             h) == 0);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<
    ::test_protocols::ChannelProtocol::TakeHandle>> : public std::true_type {};
template <>
struct IsFidlType<
    ::fidl::WireResponse<::test_protocols::ChannelProtocol::TakeHandle>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<
    ::test_protocols::ChannelProtocol::TakeHandle>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireResponse<::test_protocols::ChannelProtocol::TakeHandle>>
    : public std::false_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<
    ::test_protocols::ChannelProtocol::TakeHandle>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(
    sizeof(::fidl::internal::TransactionalResponse<
           ::test_protocols::ChannelProtocol::TakeHandle>) ==
    TypeTraits<::fidl::internal::TransactionalResponse<
        ::test_protocols::ChannelProtocol::TakeHandle>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::ChannelProtocol::TakeHandle>,
                       header) == 0);

template <>
struct TypeTraits<
    ::fidl::WireResponse<::test_protocols::ChannelProtocol::TakeHandle>> {
  static constexpr const fidl_type_t* kType = nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {
};
template <>
struct IsFidlType<
    ::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {
};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>>
    : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {
};
template <>
struct IsResource<
    ::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>>
    : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::MutateSocket>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_ChannelProtocolMutateSocketRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(
    sizeof(::fidl::internal::TransactionalRequest<
           ::test_protocols::ChannelProtocol::MutateSocket>) ==
    TypeTraits<::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::MutateSocket>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::ChannelProtocol::MutateSocket>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<
                           ::test_protocols::ChannelProtocol::MutateSocket>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::test_protocols_ChannelProtocolMutateSocketRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(
    sizeof(
        ::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>) ==
    TypeTraits<::fidl::WireRequest<
        ::test_protocols::ChannelProtocol::MutateSocket>>::kPrimarySize);
static_assert(
    offsetof(
        ::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>,
        a) == 0);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<
    ::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {
};
template <>
struct IsFidlType<
    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>>
    : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<
    ::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {
};
template <>
struct IsFidlTransactionalMessage<
    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>>
    : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalResponse<
    ::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {
};
template <>
struct IsResource<
    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>>
    : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<
    ::test_protocols::ChannelProtocol::MutateSocket>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_ChannelProtocolMutateSocketTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 =
      FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(
    sizeof(::fidl::internal::TransactionalResponse<
           ::test_protocols::ChannelProtocol::MutateSocket>) ==
    TypeTraits<::fidl::internal::TransactionalResponse<
        ::test_protocols::ChannelProtocol::MutateSocket>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::ChannelProtocol::MutateSocket>,
                       header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<
                           ::test_protocols::ChannelProtocol::MutateSocket>,
                       body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<
    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::
          test_protocols_ChannelProtocolMutateSocketTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4);
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4);
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(
    sizeof(::fidl::WireResponse<
           ::test_protocols::ChannelProtocol::MutateSocket>) ==
    TypeTraits<::fidl::WireResponse<
        ::test_protocols::ChannelProtocol::MutateSocket>>::kPrimarySize);
static_assert(
    offsetof(
        ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>,
        b) == 0);
#endif  // __Fuchsia__

}  // namespace fidl
namespace test_protocols {
#ifdef __Fuchsia__
}  // namespace test_protocols
template <>
class ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodA> final
    : public ::fidl::Result {
 public:
  WireResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::ChannelProtocol::MethodA>* request);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodA>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MethodA>* request);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};
template <>
class ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB> final
    : public ::fidl::Result {
 public:
  WireResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::ChannelProtocol::MethodB>* request);
  WireResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::ChannelProtocol::MethodB>* request,
             zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;
  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>* Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }
  const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::test_protocols::ChannelProtocol::MethodB>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }

  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>& value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> bytes_;
};
template <>
class ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodB>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MethodB>* request);
  explicit WireUnownedResult(
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::ChannelProtocol::MethodB>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<
          ::test_protocols::ChannelProtocol::MethodB>>&& decoded,
      ::fidl::internal::IncomingTransportContext context)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>* Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<::fidl::internal::TransactionalResponse<
                 ::test_protocols::ChannelProtocol::MethodB>*>(bytes_)
                 ->body);
  }
  const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<const ::fidl::internal::TransactionalResponse<
                 ::test_protocols::ChannelProtocol::MethodB>*>(bytes_)
                 ->body);
  }

  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>& value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle> final
    : public ::fidl::Result {
 public:
  WireResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::ChannelProtocol::TakeHandle>* request);
  WireResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::ChannelProtocol::TakeHandle>* request,
             zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
  ::fidl::internal::InlineMessageBuffer<16> bytes_;
};
template <>
class ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::TakeHandle>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::TakeHandle>* request);
  explicit WireUnownedResult(
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::ChannelProtocol::TakeHandle>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<
          ::test_protocols::ChannelProtocol::TakeHandle>>&& decoded,
      ::fidl::internal::IncomingTransportContext context)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket> final
    : public ::fidl::Result {
 public:
  WireResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::ChannelProtocol::MutateSocket>* request);
  WireResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
             ::fidl::internal::TransactionalRequest<
                 ::test_protocols::ChannelProtocol::MutateSocket>* request,
             zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }
  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }
  const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::test_protocols::ChannelProtocol::MutateSocket>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
  }

  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> bytes_;
};
template <>
class ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MutateSocket>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end,
      ::fidl::internal::AnyBufferAllocator& allocator,
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MutateSocket>* request);
  explicit WireUnownedResult(
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::ChannelProtocol::MutateSocket>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<
          ::test_protocols::ChannelProtocol::MutateSocket>>&& decoded,
      ::fidl::internal::IncomingTransportContext context)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }
  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<::fidl::internal::TransactionalResponse<
                 ::test_protocols::ChannelProtocol::MutateSocket>*>(bytes_)
                 ->body);
  }
  const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return &(reinterpret_cast<const ::fidl::internal::TransactionalResponse<
                 ::test_protocols::ChannelProtocol::MutateSocket>*>(bytes_)
                 ->body);
  }

  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::test_protocols::ChannelProtocol> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
  virtual void EventA(
      ::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>* event) {}
};

template <>
class ::fidl::WireAsyncEventHandler<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::test_protocols::ChannelProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::test_protocols::ChannelProtocol> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end);
};

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::ChannelProtocol>
    final
    : public ::fidl::internal::IncomingEventDispatcher<
          ::fidl::WireAsyncEventHandler<::test_protocols::ChannelProtocol>> {
 public:
  explicit WireEventDispatcher(
      ::fidl::WireAsyncEventHandler<::test_protocols::ChannelProtocol>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::IncomingTransportContext transport_context) override;
};

// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |fidl::ClientEnd<::test_protocols::ChannelProtocol>|,
// avoiding setting up a client.
template <>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::ChannelProtocol>
    final : public ::fidl::internal::SyncEndpointManagedVeneer<
                ::fidl::internal::WireSyncClientImpl<
                    ::test_protocols::ChannelProtocol>> {
 public:
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodA> MethodA(
      int64_t a, int64_t b) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::MethodA>
        _request{a, b};
    return ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodA>(
        _client_end(), &_request);
  }

  // Allocates 56 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB> MethodB(
      int64_t a, int64_t b) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::MethodB>
        _request{a, b};
    return ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>(
        _client_end(), &_request);
  }

  // Allocates 40 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle> TakeHandle(
      ::zx::handle&& h) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::TakeHandle>
        _request{std::move(h)};
    return ::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle>(
        _client_end(), &_request);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>
  MutateSocket(::zx::socket&& a) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::MutateSocket>
        _request{std::move(a)};
    return ::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>(
        _client_end(), &_request);
  }

 private:
  ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> _client_end()
      const {
    return ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<
    ::test_protocols::ChannelProtocol>
    final : public ::fidl::internal::SyncEndpointBufferVeneer<
                ::fidl::internal::WireSyncBufferClientImpl<
                    ::test_protocols::ChannelProtocol>> {
 public:
  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodA> MethodA(
      int64_t a, int64_t b) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::MethodA>
        _request{a, b};
    return ::fidl::WireUnownedResult<
        ::test_protocols::ChannelProtocol::MethodA>(_client_end(), _allocator(),
                                                    &_request);
  }

  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodB> MethodB(
      int64_t a, int64_t b) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::MethodB>
        _request{a, b};
    return ::fidl::WireUnownedResult<
        ::test_protocols::ChannelProtocol::MethodB>(_client_end(), _allocator(),
                                                    &_request);
  }

  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::TakeHandle>
  TakeHandle(::zx::handle&& h) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::TakeHandle>
        _request{std::move(h)};
    return ::fidl::WireUnownedResult<
        ::test_protocols::ChannelProtocol::TakeHandle>(_client_end(),
                                                       _allocator(), &_request);
  }

  // Caller provides the backing storage for FIDL message via an argument to
  // `.buffer()`.
  ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MutateSocket>
  MutateSocket(::zx::socket&& a) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::MutateSocket>
        _request{std::move(a)};
    return ::fidl::WireUnownedResult<
        ::test_protocols::ChannelProtocol::MutateSocket>(
        _client_end(), _allocator(), &_request);
  }

 private:
  ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> _client_end()
      const {
    return ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireCompleterImpl<
    ::test_protocols::ChannelProtocol::MethodB>
    : public ::fidl::internal::CompleterImplBase<
          ::test_protocols::ChannelProtocol::MethodB> {
 public:
  using CompleterImplBase::CompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(int64_t result);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::ChannelProtocol::MethodB>
    : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(int64_t result);
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::test_protocols::ChannelProtocol::MethodB>
    : public ::fidl::CompleterBase,
      public ::fidl::internal::WireCompleterImpl<
          ::test_protocols::ChannelProtocol::MethodB> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned,
                    bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::test_protocols::ChannelProtocol::MethodB> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::test_protocols::ChannelProtocol::MethodB>>;
};

template <>
class ::fidl::internal::WireCompleterImpl<
    ::test_protocols::ChannelProtocol::TakeHandle>
    : public ::fidl::internal::CompleterImplBase<
          ::test_protocols::ChannelProtocol::TakeHandle> {
 public:
  using CompleterImplBase::CompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply();
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::ChannelProtocol::TakeHandle>
    : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply();
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::test_protocols::ChannelProtocol::TakeHandle>
    : public ::fidl::CompleterBase,
      public ::fidl::internal::WireCompleterImpl<
          ::test_protocols::ChannelProtocol::TakeHandle> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned,
                    bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::test_protocols::ChannelProtocol::TakeHandle> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::test_protocols::ChannelProtocol::TakeHandle>>;
};

template <>
class ::fidl::internal::WireCompleterImpl<
    ::test_protocols::ChannelProtocol::MutateSocket>
    : public ::fidl::internal::CompleterImplBase<
          ::test_protocols::ChannelProtocol::MutateSocket> {
 public:
  using CompleterImplBase::CompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(::zx::socket&& b);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::ChannelProtocol::MutateSocket>
    : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.

  ::fidl::Result Reply(::zx::socket&& b);
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::test_protocols::ChannelProtocol::MutateSocket>
    : public ::fidl::CompleterBase,
      public ::fidl::internal::WireCompleterImpl<
          ::test_protocols::ChannelProtocol::MutateSocket> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned,
                    bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::test_protocols::ChannelProtocol::MutateSocket> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::test_protocols::ChannelProtocol::MutateSocket>>;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::ChannelProtocol;

  using MethodACompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::ChannelProtocol::MethodA>;
  using MethodARequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::ChannelProtocol::MethodA>;

  virtual void MethodA(MethodARequestView request,
                       MethodACompleter::Sync& _completer) = 0;

  using MethodBCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::ChannelProtocol::MethodB>;
  using MethodBRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::ChannelProtocol::MethodB>;

  virtual void MethodB(MethodBRequestView request,
                       MethodBCompleter::Sync& _completer) = 0;

  using TakeHandleCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::ChannelProtocol::TakeHandle>;
  using TakeHandleRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::ChannelProtocol::TakeHandle>;

  virtual void TakeHandle(TakeHandleRequestView request,
                          TakeHandleCompleter::Sync& _completer) = 0;

  using MutateSocketCompleter = ::fidl::internal::WireCompleter<
      ::test_protocols::ChannelProtocol::MutateSocket>;
  using MutateSocketRequestView = ::fidl::internal::WireRequestView<
      ::test_protocols::ChannelProtocol::MutateSocket>;

  virtual void MutateSocket(MutateSocketRequestView request,
                            MutateSocketCompleter::Sync& _completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
namespace fidl {

#ifdef __Fuchsia__
}  // namespace fidl
template <>
class ::fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;

  // Allocates 40 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result NoResponseMethod(::zx::socket&& h);
};

template <>
class ::fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::HandleRightsProtocol>
    final : public ::fidl::internal::WireWeakOnewayClientImpl<
                ::test_protocols::HandleRightsProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  // Allocates 24 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void ResponseMethod(
      ::zx::socket&& h,
      ::fidl::WireClientCallback<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>
          _cb);
  void ResponseMethod(
      ::zx::socket&& h,
      ::fit::callback<
          void(::fidl::WireResponse<::test_protocols::HandleRightsProtocol::
                                        ResponseMethod>* response)>
          _cb);
};

template <>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

  // Caller provides the backing storage for FIDL message.
  ::fidl::Result NoResponseMethod(::zx::socket&& h);
};

template <>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::HandleRightsProtocol>
    final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<
                ::test_protocols::HandleRightsProtocol> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

  // Caller provides the backing storage for FIDL message.
  void ResponseMethod(
      ::zx::socket&& h,
      ::fidl::WireResponseContext<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>* _context);
};
template <>
class ::fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::HandleRightsProtocol>
    final : public ::fidl::internal::WireWeakOnewayClientImpl<
                ::test_protocols::HandleRightsProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>
  ResponseMethod(::zx::socket&& h);
};
namespace fidl {
#endif  // __Fuchsia__

}  // namespace fidl
#ifdef __Fuchsia__
template <>
class ::fidl::internal::WireWeakEventSender<
    ::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  fidl::Result AnEvent(::zx::socket&& h);
};

template <>
class ::fidl::internal::WireWeakBufferEventSender<
    ::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

  fidl::Result AnEvent(::zx::socket&& h);
};

template <>
class ::fidl::internal::WireEventSender<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::WireEventSender<
              ::test_protocols::HandleRightsProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  fidl::Result AnEvent(::zx::socket&& h);
};

template <>
class ::fidl::internal::WireBufferEventSender<
    ::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::SyncEndpointBufferVeneer<
          ::fidl::internal::WireBufferEventSender<
              ::test_protocols::HandleRightsProtocol>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

  fidl::Result AnEvent(::zx::socket&& h);
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;

  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result NoRequestNoResponse();

  // Allocates 16 bytes of response buffer on the stack. Request is
  // heap-allocated.
  ::fidl::Result WithRequestNoResponse(::fidl::StringView arg);
};

template <>
class ::fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>
    final : public ::fidl::internal::WireWeakOnewayClientImpl<
                ::test_protocols::WithAndWithoutRequestResponse> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  // Allocates 16 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void NoRequestEmptyResponse(::fidl::WireClientCallback<
                              ::test_protocols::WithAndWithoutRequestResponse::
                                  NoRequestEmptyResponse>
                                  _cb);
  void NoRequestEmptyResponse(::fit::callback<void()> _cb);
  // Allocates 16 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void NoRequestWithResponse(::fidl::WireClientCallback<
                             ::test_protocols::WithAndWithoutRequestResponse::
                                 NoRequestWithResponse>
                                 _cb);
  void NoRequestWithResponse(
      ::fit::callback<void(
          ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::
                                   NoRequestWithResponse>* response)>
          _cb);
  // The request and callback are allocated on the heap.
  void WithRequestEmptyResponse(
      ::fidl::StringView arg,
      ::fidl::WireClientCallback<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>
          _cb);
  void WithRequestEmptyResponse(::fidl::StringView arg,
                                ::fit::callback<void()> _cb);
  // The request and callback are allocated on the heap.
  void WithRequestWithResponse(
      ::fidl::StringView arg,
      ::fidl::WireClientCallback<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>
          _cb);
  void WithRequestWithResponse(
      ::fidl::StringView arg,
      ::fit::callback<void(
          ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::
                                   WithRequestWithResponse>* response)>
          _cb);
};

template <>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

  // Caller provides the backing storage for FIDL message.
  ::fidl::Result NoRequestNoResponse();

  // Caller provides the backing storage for FIDL message.
  ::fidl::Result WithRequestNoResponse(::fidl::StringView arg);
};

template <>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>
    final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<
                ::test_protocols::WithAndWithoutRequestResponse> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

  // Caller provides the backing storage for FIDL message.
  void NoRequestEmptyResponse(::fidl::WireResponseContext<
                              ::test_protocols::WithAndWithoutRequestResponse::
                                  NoRequestEmptyResponse>* _context);

  // Caller provides the backing storage for FIDL message.
  void NoRequestWithResponse(::fidl::WireResponseContext<
                             ::test_protocols::WithAndWithoutRequestResponse::
                                 NoRequestWithResponse>* _context);

  // Caller provides the backing storage for FIDL message.
  void WithRequestEmptyResponse(
      ::fidl::StringView arg,
      ::fidl::WireResponseContext<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>* _context);

  // Caller provides the backing storage for FIDL message.
  void WithRequestWithResponse(
      ::fidl::StringView arg,
      ::fidl::WireResponseContext<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>* _context);
};
template <>
class ::fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>
    final : public ::fidl::internal::WireWeakOnewayClientImpl<
                ::test_protocols::WithAndWithoutRequestResponse> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;

  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
  NoRequestEmptyResponse();

  // Allocates 16 bytes of request buffer on the stack. Response is
  // heap-allocated.
  ::fidl::WireResult<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
  NoRequestWithResponse();

  // Allocates 16 bytes of response buffer on the stack. Request is
  // heap-allocated.
  ::fidl::WireResult<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
  WithRequestEmptyResponse(::fidl::StringView arg);

  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
  WithRequestWithResponse(::fidl::StringView arg);
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::WireWeakEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  fidl::Result OnEmptyResponse();

  fidl::Result OnWithResponse(::fidl::StringView ret);
};

template <>
class ::fidl::internal::WireWeakBufferEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

  fidl::Result OnEmptyResponse();

  fidl::Result OnWithResponse(::fidl::StringView ret);
};

template <>
class ::fidl::internal::WireEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::WireEventSender<
              ::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  fidl::Result OnEmptyResponse();

  fidl::Result OnWithResponse(::fidl::StringView ret);
};

template <>
class ::fidl::internal::WireBufferEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::SyncEndpointBufferVeneer<
          ::fidl::internal::WireBufferEventSender<
              ::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

  fidl::Result OnEmptyResponse();

  fidl::Result OnWithResponse(::fidl::StringView ret);
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::Transitional>
    : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;

  // Allocates 40 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result OneWay(int64_t x);
};

template <>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::Transitional>
    final : public ::fidl::internal::WireWeakOnewayClientImpl<
                ::test_protocols::Transitional> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  // Allocates 24 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void Request(
      int64_t x,
      ::fidl::WireClientCallback<::test_protocols::Transitional::Request> _cb);
  void Request(
      int64_t x,
      ::fit::callback<void(::fidl::WireResponse<
                           ::test_protocols::Transitional::Request>* response)>
          _cb);
};

template <>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::Transitional>
    : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

  // Caller provides the backing storage for FIDL message.
  ::fidl::Result OneWay(int64_t x);
};

template <>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::Transitional>
    final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<
                ::test_protocols::Transitional> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

  // Caller provides the backing storage for FIDL message.
  void Request(
      int64_t x,
      ::fidl::WireResponseContext<::test_protocols::Transitional::Request>*
          _context);
};
template <>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::Transitional>
    final : public ::fidl::internal::WireWeakOnewayClientImpl<
                ::test_protocols::Transitional> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::Transitional::Request> Request(
      int64_t x);
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::WireWeakEventSender<::test_protocols::Transitional>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  fidl::Result Event(int64_t x);
};

template <>
class ::fidl::internal::WireWeakBufferEventSender<
    ::test_protocols::Transitional>
    : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

  fidl::Result Event(int64_t x);
};

template <>
class ::fidl::internal::WireEventSender<::test_protocols::Transitional>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::WireEventSender<::test_protocols::Transitional>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  fidl::Result Event(int64_t x);
};

template <>
class ::fidl::internal::WireBufferEventSender<::test_protocols::Transitional>
    : public ::fidl::internal::SyncEndpointBufferVeneer<
          ::fidl::internal::WireBufferEventSender<
              ::test_protocols::Transitional>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

  fidl::Result Event(int64_t x);
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::MethodWithUnion>
    : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result UnionMethod(::test_protocols::wire::TheUnion u);
};

template <>
class ::fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::MethodWithUnion>
    final : public ::fidl::internal::WireWeakOnewayClientImpl<
                ::test_protocols::MethodWithUnion> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
};

template <>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::MethodWithUnion>
    : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

  // Caller provides the backing storage for FIDL message.
  ::fidl::Result UnionMethod(::test_protocols::wire::TheUnion u);
};

template <>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::MethodWithUnion>
    final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<
                ::test_protocols::MethodWithUnion> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;
};
template <>
class ::fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::MethodWithUnion>
    final : public ::fidl::internal::WireWeakOnewayClientImpl<
                ::test_protocols::MethodWithUnion> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::WireWeakEventSender<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::WireWeakBufferEventSender<
    ::test_protocols::MethodWithUnion>
    : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;
};

template <>
class ::fidl::internal::WireEventSender<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::WireEventSender<
              ::test_protocols::MethodWithUnion>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};

template <>
class ::fidl::internal::WireBufferEventSender<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::SyncEndpointBufferVeneer<
          ::fidl::internal::WireBufferEventSender<
              ::test_protocols::MethodWithUnion>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
};

template <>
class ::fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithProtocolEnds>
    final : public ::fidl::internal::WireWeakOnewayClientImpl<
                ::test_protocols::WithProtocolEnds> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  // Allocates 24 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void ClientEnds(
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in,
      ::fidl::WireClientCallback<::test_protocols::WithProtocolEnds::ClientEnds>
          _cb);
  void ClientEnds(
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in,
      ::fit::callback<void(
          ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>*
              response)>
          _cb);
  // Allocates 24 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void ServerEnds(
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in,
      ::fidl::WireClientCallback<::test_protocols::WithProtocolEnds::ServerEnds>
          _cb);
  void ServerEnds(
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in,
      ::fit::callback<void(
          ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>*
              response)>
          _cb);
  // Allocates 32 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void StructContainingEnds(
      ::test_protocols::wire::ProtocolEnds&& in,
      ::fidl::WireClientCallback<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>
          _cb);
  void StructContainingEnds(
      ::test_protocols::wire::ProtocolEnds&& in,
      ::fit::callback<
          void(::fidl::WireResponse<::test_protocols::WithProtocolEnds::
                                        StructContainingEnds>* response)>
          _cb);
};

template <>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;
};

template <>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithProtocolEnds>
    final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<
                ::test_protocols::WithProtocolEnds> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

  // Caller provides the backing storage for FIDL message.
  void ClientEnds(
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in,
      ::fidl::WireResponseContext<
          ::test_protocols::WithProtocolEnds::ClientEnds>* _context);

  // Caller provides the backing storage for FIDL message.
  void ServerEnds(
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in,
      ::fidl::WireResponseContext<
          ::test_protocols::WithProtocolEnds::ServerEnds>* _context);

  // Caller provides the backing storage for FIDL message.
  void StructContainingEnds(
      ::test_protocols::wire::ProtocolEnds&& in,
      ::fidl::WireResponseContext<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>* _context);
};
template <>
class ::fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::WithProtocolEnds>
    final : public ::fidl::internal::WireWeakOnewayClientImpl<
                ::test_protocols::WithProtocolEnds> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds> ClientEnds(
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in);

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds> ServerEnds(
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in);

  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>
  StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in);
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::WireWeakEventSender<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::WireWeakBufferEventSender<
    ::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;
};

template <>
class ::fidl::internal::WireEventSender<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::WireEventSender<
              ::test_protocols::WithProtocolEnds>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};

template <>
class ::fidl::internal::WireBufferEventSender<
    ::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::SyncEndpointBufferVeneer<
          ::fidl::internal::WireBufferEventSender<
              ::test_protocols::WithProtocolEnds>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::ManyParameters>
    : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6,
                         bool p7, bool p8, bool p9, bool p10, bool p11,
                         bool p12, bool p13, bool p14, bool p15);
};

template <>
class ::fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::ManyParameters>
    final : public ::fidl::internal::WireWeakOnewayClientImpl<
                ::test_protocols::ManyParameters> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
};

template <>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::ManyParameters>
    : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

  // Caller provides the backing storage for FIDL message.
  ::fidl::Result Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6,
                         bool p7, bool p8, bool p9, bool p10, bool p11,
                         bool p12, bool p13, bool p14, bool p15);
};

template <>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::ManyParameters>
    final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<
                ::test_protocols::ManyParameters> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;
};
template <>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::ManyParameters>
    final : public ::fidl::internal::WireWeakOnewayClientImpl<
                ::test_protocols::ManyParameters> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::WireWeakEventSender<::test_protocols::ManyParameters>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::WireWeakBufferEventSender<
    ::test_protocols::ManyParameters>
    : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;
};

template <>
class ::fidl::internal::WireEventSender<::test_protocols::ManyParameters>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::WireEventSender<::test_protocols::ManyParameters>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};

template <>
class ::fidl::internal::WireBufferEventSender<::test_protocols::ManyParameters>
    : public ::fidl::internal::SyncEndpointBufferVeneer<
          ::fidl::internal::WireBufferEventSender<
              ::test_protocols::ManyParameters>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
};

template <>
class ::fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithErrorSyntax>
    final : public ::fidl::internal::WireWeakOnewayClientImpl<
                ::test_protocols::WithErrorSyntax> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  // Allocates 16 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void ResponseAsStruct(::fidl::WireClientCallback<
                        ::test_protocols::WithErrorSyntax::ResponseAsStruct>
                            _cb);
  void ResponseAsStruct(
      ::fit::callback<
          void(::fidl::WireResponse<
               ::test_protocols::WithErrorSyntax::ResponseAsStruct>* response)>
          _cb);
  // Allocates 16 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void ErrorAsPrimitive(::fidl::WireClientCallback<
                        ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
                            _cb);
  void ErrorAsPrimitive(
      ::fit::callback<
          void(::fidl::WireResponse<
               ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* response)>
          _cb);
  // Allocates 16 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void ErrorAsEnum(
      ::fidl::WireClientCallback<::test_protocols::WithErrorSyntax::ErrorAsEnum>
          _cb);
  void ErrorAsEnum(
      ::fit::callback<void(
          ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>*
              response)>
          _cb);
  // Allocates 16 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void HandleInResult(::fidl::WireClientCallback<
                      ::test_protocols::WithErrorSyntax::HandleInResult>
                          _cb);
  void HandleInResult(
      ::fit::callback<
          void(::fidl::WireResponse<
               ::test_protocols::WithErrorSyntax::HandleInResult>* response)>
          _cb);
};

template <>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;
};

template <>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithErrorSyntax>
    final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<
                ::test_protocols::WithErrorSyntax> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

  // Caller provides the backing storage for FIDL message.
  void ResponseAsStruct(
      ::fidl::WireResponseContext<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>* _context);

  // Caller provides the backing storage for FIDL message.
  void ErrorAsPrimitive(
      ::fidl::WireResponseContext<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* _context);

  // Caller provides the backing storage for FIDL message.
  void ErrorAsEnum(::fidl::WireResponseContext<
                   ::test_protocols::WithErrorSyntax::ErrorAsEnum>* _context);

  // Caller provides the backing storage for FIDL message.
  void HandleInResult(
      ::fidl::WireResponseContext<
          ::test_protocols::WithErrorSyntax::HandleInResult>* _context);
};
template <>
class ::fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::WithErrorSyntax>
    final : public ::fidl::internal::WireWeakOnewayClientImpl<
                ::test_protocols::WithErrorSyntax> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;

  // Allocates 72 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>
  ResponseAsStruct();

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  ErrorAsPrimitive();

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>
  ErrorAsEnum();

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>
  HandleInResult();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::WireWeakEventSender<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::WireWeakBufferEventSender<
    ::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;
};

template <>
class ::fidl::internal::WireEventSender<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::WireEventSender<
              ::test_protocols::WithErrorSyntax>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};

template <>
class ::fidl::internal::WireBufferEventSender<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::SyncEndpointBufferVeneer<
          ::fidl::internal::WireBufferEventSender<
              ::test_protocols::WithErrorSyntax>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;

  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result Method();
};

template <>
class ::fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::DiscoverableProtocol>
    final : public ::fidl::internal::WireWeakOnewayClientImpl<
                ::test_protocols::DiscoverableProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
};

template <>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

  // Caller provides the backing storage for FIDL message.
  ::fidl::Result Method();
};

template <>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::DiscoverableProtocol>
    final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<
                ::test_protocols::DiscoverableProtocol> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;
};
template <>
class ::fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::DiscoverableProtocol>
    final : public ::fidl::internal::WireWeakOnewayClientImpl<
                ::test_protocols::DiscoverableProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::WireWeakEventSender<
    ::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::WireWeakBufferEventSender<
    ::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;
};

template <>
class ::fidl::internal::WireEventSender<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::WireEventSender<
              ::test_protocols::DiscoverableProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};

template <>
class ::fidl::internal::WireBufferEventSender<
    ::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::SyncEndpointBufferVeneer<
          ::fidl::internal::WireBufferEventSender<
              ::test_protocols::DiscoverableProtocol>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::ChannelProtocol>
    : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result MethodA(int64_t a, int64_t b);
};

template <>
class ::fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::ChannelProtocol>
    final : public ::fidl::internal::WireWeakOnewayClientImpl<
                ::test_protocols::ChannelProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  // Allocates 32 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void MethodB(
      int64_t a, int64_t b,
      ::fidl::WireClientCallback<::test_protocols::ChannelProtocol::MethodB>
          _cb);
  void MethodB(int64_t a, int64_t b,
               ::fit::callback<
                   void(::fidl::WireResponse<
                        ::test_protocols::ChannelProtocol::MethodB>* response)>
                   _cb);
  // Allocates 24 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void TakeHandle(
      ::zx::handle&& h,
      ::fidl::WireClientCallback<::test_protocols::ChannelProtocol::TakeHandle>
          _cb);
  void TakeHandle(::zx::handle&& h, ::fit::callback<void()> _cb);
  // Allocates 24 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void MutateSocket(::zx::socket&& a,
                    ::fidl::WireClientCallback<
                        ::test_protocols::ChannelProtocol::MutateSocket>
                        _cb);
  void MutateSocket(
      ::zx::socket&& a,
      ::fit::callback<void(
          ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>*
              response)>
          _cb);
};

template <>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::ChannelProtocol>
    : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

  // Caller provides the backing storage for FIDL message.
  ::fidl::Result MethodA(int64_t a, int64_t b);
};

template <>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::ChannelProtocol>
    final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<
                ::test_protocols::ChannelProtocol> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

  // Caller provides the backing storage for FIDL message.
  void MethodB(
      int64_t a, int64_t b,
      ::fidl::WireResponseContext<::test_protocols::ChannelProtocol::MethodB>*
          _context);

  // Caller provides the backing storage for FIDL message.
  void TakeHandle(::zx::handle&& h,
                  ::fidl::WireResponseContext<
                      ::test_protocols::ChannelProtocol::TakeHandle>* _context);

  // Caller provides the backing storage for FIDL message.
  void MutateSocket(
      ::zx::socket&& a,
      ::fidl::WireResponseContext<
          ::test_protocols::ChannelProtocol::MutateSocket>* _context);
};
template <>
class ::fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::ChannelProtocol>
    final : public ::fidl::internal::WireWeakOnewayClientImpl<
                ::test_protocols::ChannelProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;

  // Allocates 56 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB> MethodB(
      int64_t a, int64_t b);

  // Allocates 40 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle> TakeHandle(
      ::zx::handle&& h);

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>
  MutateSocket(::zx::socket&& a);
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::WireWeakEventSender<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  fidl::Result EventA(int64_t a, int64_t b);
};

template <>
class ::fidl::internal::WireWeakBufferEventSender<
    ::test_protocols::ChannelProtocol>
    : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

  fidl::Result EventA(int64_t a, int64_t b);
};

template <>
class ::fidl::internal::WireEventSender<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::WireEventSender<
              ::test_protocols::ChannelProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  fidl::Result EventA(int64_t a, int64_t b);
};

template <>
class ::fidl::internal::WireBufferEventSender<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::SyncEndpointBufferVeneer<
          ::fidl::internal::WireBufferEventSender<
              ::test_protocols::ChannelProtocol>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

  fidl::Result EventA(int64_t a, int64_t b);
};
#endif  // __Fuchsia__
