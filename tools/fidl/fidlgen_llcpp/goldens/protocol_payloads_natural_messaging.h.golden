// WARNING: This file is machine generated by fidlgen_llcpp.

#pragma once

#include <fidl/test.protocolpayloads.imported/cpp/natural_messaging.h>
#include <fidl/test.protocolpayloads/cpp/markers.h>
#include <fidl/test.protocolpayloads/cpp/natural_types.h>
#include <lib/fidl/cpp/channel.h>
#include <lib/fidl/cpp/client.h>
#include <lib/fidl/cpp/internal/message_extensions.h>
#include <lib/fidl/cpp/internal/natural_client_messenger.h>
#include <lib/fidl/cpp/internal/natural_server_messenger.h>
#include <lib/fidl/cpp/natural_types.h>
#include <lib/fidl/cpp/unified_messaging.h>

namespace fidl {}  // namespace fidl
namespace test_protocolpayloads {
__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_imported_ImportStructPayloadTable;

__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_imported_ComposedProtocolTwoWayComposedWithErrorTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_imported_ComposedProtocolOnComposedWithErrorRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_LocalStructPayloadTable;

__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolTwoWayLocalWithErrorTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolOnLocalWithErrorRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolTwoWayImportWithErrorTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolOnImportWithErrorRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolOneWayAnonRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolTwoWayAnonRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolTwoWayAnonTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolTwoWayAnonWithErrorRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolTwoWayAnonWithErrorTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolOnAnonRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolOnAnonWithErrorRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

template <>
class ::fidl::Event<::test_protocolpayloads::MainProtocol::OnComposed> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Event<::test_protocolpayloads::MainProtocol::OnComposed>> {
 public:
  Event() = default;
  ~Event() = default;
  Event(Event&&) noexcept = default;
  Event& operator=(Event&&) noexcept = default;
  Event(::test_protocolpayloads_imported::ImportStructPayload payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads_imported::ImportStructPayload* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload* operator->()
      const {
    return &payload_;
  }
  ::test_protocolpayloads_imported::ImportStructPayload& operator*() {
    return payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocolpayloads_imported::ImportStructPayload payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnComposed>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
namespace test_protocolpayloads {}  // namespace test_protocolpayloads

template <>
class ::fidl::Event<::test_protocolpayloads::MainProtocol::OnComposedWithError>
    final : public ::fidl::internal::MessageBase<::fidl::Event<
                ::test_protocolpayloads::MainProtocol::OnComposedWithError>> {
 public:
  Event() = default;
  ~Event() = default;
  Event(Event&&) noexcept = default;
  Event& operator=(Event&&) noexcept = default;
  Event(::test_protocolpayloads_imported::
            ComposedProtocolOnComposedWithErrorRequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads_imported::ComposedProtocolOnComposedWithErrorRequest*
  operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads_imported::
      ComposedProtocolOnComposedWithErrorRequest*
      operator->() const {
    return &payload_;
  }
  ::test_protocolpayloads_imported::ComposedProtocolOnComposedWithErrorRequest&
  operator*() {
    return payload_;
  }
  const ::test_protocolpayloads_imported::
      ComposedProtocolOnComposedWithErrorRequest&
      operator*() const {
    return payload_;
  }

 private:
  ::test_protocolpayloads_imported::ComposedProtocolOnComposedWithErrorRequest
      payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnComposedWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::
      ComposedProtocolOnComposedWithErrorRequest;
};
namespace test_protocolpayloads {}  // namespace test_protocolpayloads

template <>
class ::fidl::Event<::test_protocolpayloads::MainProtocol::OnLocal> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Event<::test_protocolpayloads::MainProtocol::OnLocal>> {
 public:
  Event() = default;
  ~Event() = default;
  Event(Event&&) noexcept = default;
  Event& operator=(Event&&) noexcept = default;
  Event(::test_protocolpayloads::LocalStructPayload payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads::LocalStructPayload* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads::LocalStructPayload* operator->() const {
    return &payload_;
  }
  ::test_protocolpayloads::LocalStructPayload& operator*() { return payload_; }
  const ::test_protocolpayloads::LocalStructPayload& operator*() const {
    return payload_;
  }

 private:
  ::test_protocolpayloads::LocalStructPayload payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnLocal>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::LocalStructPayload;
};
namespace test_protocolpayloads {}  // namespace test_protocolpayloads

template <>
class ::fidl::Event<::test_protocolpayloads::MainProtocol::OnLocalWithError>
    final : public ::fidl::internal::MessageBase<::fidl::Event<
                ::test_protocolpayloads::MainProtocol::OnLocalWithError>> {
 public:
  Event() = default;
  ~Event() = default;
  Event(Event&&) noexcept = default;
  Event& operator=(Event&&) noexcept = default;
  Event(::test_protocolpayloads::MainProtocolOnLocalWithErrorRequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads::MainProtocolOnLocalWithErrorRequest* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads::MainProtocolOnLocalWithErrorRequest*
  operator->() const {
    return &payload_;
  }
  ::test_protocolpayloads::MainProtocolOnLocalWithErrorRequest& operator*() {
    return payload_;
  }
  const ::test_protocolpayloads::MainProtocolOnLocalWithErrorRequest&
  operator*() const {
    return payload_;
  }

 private:
  ::test_protocolpayloads::MainProtocolOnLocalWithErrorRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnLocalWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::MainProtocolOnLocalWithErrorRequest;
};
namespace test_protocolpayloads {}  // namespace test_protocolpayloads

template <>
class ::fidl::Event<::test_protocolpayloads::MainProtocol::OnImport> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Event<::test_protocolpayloads::MainProtocol::OnImport>> {
 public:
  Event() = default;
  ~Event() = default;
  Event(Event&&) noexcept = default;
  Event& operator=(Event&&) noexcept = default;
  Event(::test_protocolpayloads_imported::ImportStructPayload payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads_imported::ImportStructPayload* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload* operator->()
      const {
    return &payload_;
  }
  ::test_protocolpayloads_imported::ImportStructPayload& operator*() {
    return payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocolpayloads_imported::ImportStructPayload payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnImport>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
namespace test_protocolpayloads {}  // namespace test_protocolpayloads

template <>
class ::fidl::Event<::test_protocolpayloads::MainProtocol::OnImportWithError>
    final : public ::fidl::internal::MessageBase<::fidl::Event<
                ::test_protocolpayloads::MainProtocol::OnImportWithError>> {
 public:
  Event() = default;
  ~Event() = default;
  Event(Event&&) noexcept = default;
  Event& operator=(Event&&) noexcept = default;
  Event(::test_protocolpayloads::MainProtocolOnImportWithErrorRequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads::MainProtocolOnImportWithErrorRequest* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads::MainProtocolOnImportWithErrorRequest*
  operator->() const {
    return &payload_;
  }
  ::test_protocolpayloads::MainProtocolOnImportWithErrorRequest& operator*() {
    return payload_;
  }
  const ::test_protocolpayloads::MainProtocolOnImportWithErrorRequest&
  operator*() const {
    return payload_;
  }

 private:
  ::test_protocolpayloads::MainProtocolOnImportWithErrorRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnImportWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::MainProtocolOnImportWithErrorRequest;
};
namespace test_protocolpayloads {}  // namespace test_protocolpayloads

template <>
class ::fidl::Event<::test_protocolpayloads::MainProtocol::OnAnon> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Event<::test_protocolpayloads::MainProtocol::OnAnon>> {
 public:
  Event() = default;
  ~Event() = default;
  Event(Event&&) noexcept = default;
  Event& operator=(Event&&) noexcept = default;
  Event(::test_protocolpayloads::MainProtocolOnAnonRequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads::MainProtocolOnAnonRequest* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads::MainProtocolOnAnonRequest* operator->() const {
    return &payload_;
  }
  ::test_protocolpayloads::MainProtocolOnAnonRequest& operator*() {
    return payload_;
  }
  const ::test_protocolpayloads::MainProtocolOnAnonRequest& operator*() const {
    return payload_;
  }

 private:
  ::test_protocolpayloads::MainProtocolOnAnonRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnAnon>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::MainProtocolOnAnonRequest;
};
namespace test_protocolpayloads {}  // namespace test_protocolpayloads

template <>
class ::fidl::Event<::test_protocolpayloads::MainProtocol::OnAnonWithError>
    final : public ::fidl::internal::MessageBase<::fidl::Event<
                ::test_protocolpayloads::MainProtocol::OnAnonWithError>> {
 public:
  Event() = default;
  ~Event() = default;
  Event(Event&&) noexcept = default;
  Event& operator=(Event&&) noexcept = default;
  Event(::test_protocolpayloads::MainProtocolOnAnonWithErrorRequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads::MainProtocolOnAnonWithErrorRequest* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads::MainProtocolOnAnonWithErrorRequest*
  operator->() const {
    return &payload_;
  }
  ::test_protocolpayloads::MainProtocolOnAnonWithErrorRequest& operator*() {
    return payload_;
  }
  const ::test_protocolpayloads::MainProtocolOnAnonWithErrorRequest& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocolpayloads::MainProtocolOnAnonWithErrorRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnAnonWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::MainProtocolOnAnonWithErrorRequest;
};
namespace test_protocolpayloads {}  // namespace test_protocolpayloads

template <>
class ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayComposed>
    final : public ::fidl::internal::MessageBase<::fidl::Response<
                ::test_protocolpayloads::MainProtocol::TwoWayComposed>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocolpayloads_imported::ImportStructPayload payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads_imported::ImportStructPayload* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload* operator->()
      const {
    return &payload_;
  }
  ::test_protocolpayloads_imported::ImportStructPayload& operator*() {
    return payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocolpayloads_imported::ImportStructPayload payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayComposed>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
namespace test_protocolpayloads {}  // namespace test_protocolpayloads
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocolpayloads::MainProtocol::TwoWayComposed>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<::fidl::Error,
                     ::fidl::Response<::test_protocolpayloads::MainProtocol::
                                          TwoWayComposed>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<
          ::test_protocolpayloads::MainProtocol::TwoWayComposed>&)>;
};

template <>
class ::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>
    final
    : public ::fidl::internal::MessageBase<::fidl::Response<
          ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocolpayloads_imported::
               ComposedProtocolTwoWayComposedWithErrorTopResponse payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads_imported::
      ComposedProtocolTwoWayComposedWithErrorTopResponse*
      operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads_imported::
      ComposedProtocolTwoWayComposedWithErrorTopResponse*
      operator->() const {
    return &payload_;
  }
  ::test_protocolpayloads_imported::
      ComposedProtocolTwoWayComposedWithErrorTopResponse&
      operator*() {
    return payload_;
  }
  const ::test_protocolpayloads_imported::
      ComposedProtocolTwoWayComposedWithErrorTopResponse&
      operator*() const {
    return payload_;
  }

 private:
  ::test_protocolpayloads_imported::
      ComposedProtocolTwoWayComposedWithErrorTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::
      ComposedProtocolTwoWayComposedWithErrorTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<::fidl::Error,
                     ::fidl::Response<::test_protocolpayloads::MainProtocol::
                                          TwoWayComposedWithError>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<
          ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>&)>;
};

template <>
class ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayLocal> final
    : public ::fidl::internal::MessageBase<::fidl::Response<
          ::test_protocolpayloads::MainProtocol::TwoWayLocal>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocolpayloads::LocalStructPayload payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads::LocalStructPayload* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads::LocalStructPayload* operator->() const {
    return &payload_;
  }
  ::test_protocolpayloads::LocalStructPayload& operator*() { return payload_; }
  const ::test_protocolpayloads::LocalStructPayload& operator*() const {
    return payload_;
  }

 private:
  ::test_protocolpayloads::LocalStructPayload payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayLocal>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::LocalStructPayload;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocolpayloads::MainProtocol::TwoWayLocal>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<::fidl::Error,
                     ::fidl::Response<::test_protocolpayloads::MainProtocol::
                                          TwoWayLocal>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayLocal>&)>;
};

template <>
class ::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>
    final : public ::fidl::internal::MessageBase<::fidl::Response<
                ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorTopResponse
               payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorTopResponse*
  operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorTopResponse*
  operator->() const {
    return &payload_;
  }
  ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorTopResponse&
  operator*() {
    return payload_;
  }
  const ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorTopResponse&
  operator*() const {
    return payload_;
  }

 private:
  ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload =
      ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<::fidl::Error,
                     ::fidl::Response<::test_protocolpayloads::MainProtocol::
                                          TwoWayLocalWithError>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<
          ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>&)>;
};

template <>
class ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayImport>
    final : public ::fidl::internal::MessageBase<::fidl::Response<
                ::test_protocolpayloads::MainProtocol::TwoWayImport>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocolpayloads_imported::ImportStructPayload payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads_imported::ImportStructPayload* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload* operator->()
      const {
    return &payload_;
  }
  ::test_protocolpayloads_imported::ImportStructPayload& operator*() {
    return payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocolpayloads_imported::ImportStructPayload payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayImport>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocolpayloads::MainProtocol::TwoWayImport>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<::fidl::Error,
                     ::fidl::Response<::test_protocolpayloads::MainProtocol::
                                          TwoWayImport>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayImport>&)>;
};

template <>
class ::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>
    final : public ::fidl::internal::MessageBase<::fidl::Response<
                ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocolpayloads::MainProtocolTwoWayImportWithErrorTopResponse
               payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorTopResponse*
  operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorTopResponse*
  operator->() const {
    return &payload_;
  }
  ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorTopResponse&
  operator*() {
    return payload_;
  }
  const ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorTopResponse&
  operator*() const {
    return payload_;
  }

 private:
  ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorTopResponse
      payload_;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload =
      ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<::fidl::Error,
                     ::fidl::Response<::test_protocolpayloads::MainProtocol::
                                          TwoWayImportWithError>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<
          ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>&)>;
};

template <>
class ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayAnon> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayAnon>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocolpayloads::MainProtocolTwoWayAnonTopResponse payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads::MainProtocolTwoWayAnonTopResponse* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads::MainProtocolTwoWayAnonTopResponse* operator->()
      const {
    return &payload_;
  }
  ::test_protocolpayloads::MainProtocolTwoWayAnonTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocolpayloads::MainProtocolTwoWayAnonTopResponse& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocolpayloads::MainProtocolTwoWayAnonTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayAnon>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::MainProtocolTwoWayAnonTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocolpayloads::MainProtocol::TwoWayAnon>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<::fidl::Error,
                     ::fidl::Response<
                         ::test_protocolpayloads::MainProtocol::TwoWayAnon>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayAnon>&)>;
};

template <>
class ::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>
    final : public ::fidl::internal::MessageBase<::fidl::Response<
                ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorTopResponse
               payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorTopResponse*
  operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorTopResponse*
  operator->() const {
    return &payload_;
  }
  ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorTopResponse&
  operator*() {
    return payload_;
  }
  const ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorTopResponse&
  operator*() const {
    return payload_;
  }

 private:
  ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload =
      ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<::fidl::Error,
                     ::fidl::Response<::test_protocolpayloads::MainProtocol::
                                          TwoWayAnonWithError>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<
          ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>&)>;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocolpayloads::MainProtocol>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void TwoWayComposed(
      ::test_protocolpayloads_imported::ImportStructPayload&& payload,
      ::fidl::ClientCallback<
          ::test_protocolpayloads::MainProtocol::TwoWayComposed>&& _callback)
      const;

  void TwoWayComposed(
      ::test_protocolpayloads_imported::ImportStructPayload&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocolpayloads::MainProtocol::TwoWayComposed>&& _callback)
      const;

  void TwoWayComposedWithError(
      ::test_protocolpayloads_imported::ImportStructPayload&& payload,
      ::fidl::ClientCallback<
          ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>&&
          _callback) const;

  void TwoWayComposedWithError(
      ::test_protocolpayloads_imported::ImportStructPayload&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>&&
          _callback) const;

  void TwoWayLocal(::test_protocolpayloads::LocalStructPayload&& payload,
                   ::fidl::ClientCallback<
                       ::test_protocolpayloads::MainProtocol::TwoWayLocal>&&
                       _callback) const;

  void TwoWayLocal(::test_protocolpayloads::LocalStructPayload&& payload,
                   ::fidl::ClientResponseCallback<
                       ::test_protocolpayloads::MainProtocol::TwoWayLocal>&&
                       _callback) const;

  void TwoWayLocalWithError(
      ::test_protocolpayloads::LocalStructPayload&& payload,
      ::fidl::ClientCallback<
          ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>&&
          _callback) const;

  void TwoWayLocalWithError(
      ::test_protocolpayloads::LocalStructPayload&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>&&
          _callback) const;

  void TwoWayImport(
      ::test_protocolpayloads_imported::ImportStructPayload&& payload,
      ::fidl::ClientCallback<
          ::test_protocolpayloads::MainProtocol::TwoWayImport>&& _callback)
      const;

  void TwoWayImport(
      ::test_protocolpayloads_imported::ImportStructPayload&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocolpayloads::MainProtocol::TwoWayImport>&& _callback)
      const;

  void TwoWayImportWithError(
      ::test_protocolpayloads_imported::ImportStructPayload&& payload,
      ::fidl::ClientCallback<
          ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>&&
          _callback) const;

  void TwoWayImportWithError(
      ::test_protocolpayloads_imported::ImportStructPayload&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>&&
          _callback) const;

  void TwoWayAnon(
      ::test_protocolpayloads::MainProtocolTwoWayAnonRequest&& payload,
      ::fidl::ClientCallback<
          ::test_protocolpayloads::MainProtocol::TwoWayAnon>&& _callback) const;

  void TwoWayAnon(
      ::test_protocolpayloads::MainProtocolTwoWayAnonRequest&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocolpayloads::MainProtocol::TwoWayAnon>&& _callback) const;

  void TwoWayAnonWithError(
      ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest&& payload,
      ::fidl::ClientCallback<
          ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>&&
          _callback) const;

  void TwoWayAnonWithError(
      ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>&&
          _callback) const;

  ::fitx::result<::fidl::Error> OneWayComposed(
      ::test_protocolpayloads_imported::ImportStructPayload&& payload) const;

  ::fitx::result<::fidl::Error> OneWayLocal(
      ::test_protocolpayloads::LocalStructPayload&& payload) const;

  ::fitx::result<::fidl::Error> OneWayImport(
      ::test_protocolpayloads_imported::ImportStructPayload&& payload) const;

  ::fitx::result<::fidl::Error> OneWayAnon(
      ::test_protocolpayloads::MainProtocolOneWayAnonRequest&& payload) const;
};
namespace test_protocolpayloads {
#endif  // __Fuchsia__

}  // namespace test_protocolpayloads
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocolpayloads::MainProtocol> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void OnComposed(
      ::fidl::Event<::test_protocolpayloads::MainProtocol::OnComposed>&) {}
  virtual void OnComposedWithError(
      ::fidl::Event<
          ::test_protocolpayloads::MainProtocol::OnComposedWithError>&) {}
  virtual void OnLocal(
      ::fidl::Event<::test_protocolpayloads::MainProtocol::OnLocal>&) {}
  virtual void OnLocalWithError(
      ::fidl::Event<::test_protocolpayloads::MainProtocol::OnLocalWithError>&) {
  }
  virtual void OnImport(
      ::fidl::Event<::test_protocolpayloads::MainProtocol::OnImport>&) {}
  virtual void OnImportWithError(
      ::fidl::Event<
          ::test_protocolpayloads::MainProtocol::OnImportWithError>&) {}
  virtual void OnAnon(
      ::fidl::Event<::test_protocolpayloads::MainProtocol::OnAnon>&) {}
  virtual void OnAnonWithError(
      ::fidl::Event<::test_protocolpayloads::MainProtocol::OnAnonWithError>&) {}
};

template <>
class ::fidl::AsyncEventHandler<::test_protocolpayloads::MainProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocolpayloads::MainProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocolpayloads::MainProtocol>
    final
    : public ::fidl::internal::IncomingEventDispatcher<
          ::fidl::AsyncEventHandler<::test_protocolpayloads::MainProtocol>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocolpayloads::MainProtocol>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<
    ::test_protocolpayloads::MainProtocol>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  ::fitx::result<::fidl::Error> OnComposed(
      ::test_protocolpayloads_imported::ImportStructPayload payload);

  ::fitx::result<::fidl::Error> OnComposedWithError(
      ::test_protocolpayloads_imported::
          ComposedProtocolOnComposedWithErrorRequest payload);

  ::fitx::result<::fidl::Error> OnLocal(
      ::test_protocolpayloads::LocalStructPayload payload);

  ::fitx::result<::fidl::Error> OnLocalWithError(
      ::test_protocolpayloads::MainProtocolOnLocalWithErrorRequest payload);

  ::fitx::result<::fidl::Error> OnImport(
      ::test_protocolpayloads_imported::ImportStructPayload payload);

  ::fitx::result<::fidl::Error> OnImportWithError(
      ::test_protocolpayloads::MainProtocolOnImportWithErrorRequest payload);

  ::fitx::result<::fidl::Error> OnAnon(
      ::test_protocolpayloads::MainProtocolOnAnonRequest payload);

  ::fitx::result<::fidl::Error> OnAnonWithError(
      ::test_protocolpayloads::MainProtocolOnAnonWithErrorRequest payload);
};

template <>
class ::fidl::internal::NaturalEventSender<
    ::test_protocolpayloads::MainProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocolpayloads::MainProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  ::fitx::result<::fidl::Error> OnComposed(
      ::test_protocolpayloads_imported::ImportStructPayload payload);

  ::fitx::result<::fidl::Error> OnComposedWithError(
      ::test_protocolpayloads_imported::
          ComposedProtocolOnComposedWithErrorRequest payload);

  ::fitx::result<::fidl::Error> OnLocal(
      ::test_protocolpayloads::LocalStructPayload payload);

  ::fitx::result<::fidl::Error> OnLocalWithError(
      ::test_protocolpayloads::MainProtocolOnLocalWithErrorRequest payload);

  ::fitx::result<::fidl::Error> OnImport(
      ::test_protocolpayloads_imported::ImportStructPayload payload);

  ::fitx::result<::fidl::Error> OnImportWithError(
      ::test_protocolpayloads::MainProtocolOnImportWithErrorRequest payload);

  ::fitx::result<::fidl::Error> OnAnon(
      ::test_protocolpayloads::MainProtocolOnAnonRequest payload);

  ::fitx::result<::fidl::Error> OnAnonWithError(
      ::test_protocolpayloads::MainProtocolOnAnonWithErrorRequest payload);
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayComposed>
    final : public ::fidl::internal::MessageBase<::fidl::Request<
                ::test_protocolpayloads::MainProtocol::OneWayComposed>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocolpayloads_imported::ImportStructPayload payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads_imported::ImportStructPayload* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload* operator->()
      const {
    return &payload_;
  }
  ::test_protocolpayloads_imported::ImportStructPayload& operator*() {
    return payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocolpayloads_imported::ImportStructPayload payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayComposed>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayComposed>
    final : public ::fidl::internal::MessageBase<::fidl::Request<
                ::test_protocolpayloads::MainProtocol::TwoWayComposed>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocolpayloads_imported::ImportStructPayload payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads_imported::ImportStructPayload* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload* operator->()
      const {
    return &payload_;
  }
  ::test_protocolpayloads_imported::ImportStructPayload& operator*() {
    return payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocolpayloads_imported::ImportStructPayload payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayComposed>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>
    final
    : public ::fidl::internal::MessageBase<::fidl::Request<
          ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocolpayloads_imported::ImportStructPayload payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads_imported::ImportStructPayload* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload* operator->()
      const {
    return &payload_;
  }
  ::test_protocolpayloads_imported::ImportStructPayload& operator*() {
    return payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocolpayloads_imported::ImportStructPayload payload_;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<
    ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayLocal> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayLocal>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocolpayloads::LocalStructPayload payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads::LocalStructPayload* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads::LocalStructPayload* operator->() const {
    return &payload_;
  }
  ::test_protocolpayloads::LocalStructPayload& operator*() { return payload_; }
  const ::test_protocolpayloads::LocalStructPayload& operator*() const {
    return payload_;
  }

 private:
  ::test_protocolpayloads::LocalStructPayload payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayLocal>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::LocalStructPayload;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayLocal> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayLocal>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocolpayloads::LocalStructPayload payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads::LocalStructPayload* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads::LocalStructPayload* operator->() const {
    return &payload_;
  }
  ::test_protocolpayloads::LocalStructPayload& operator*() { return payload_; }
  const ::test_protocolpayloads::LocalStructPayload& operator*() const {
    return payload_;
  }

 private:
  ::test_protocolpayloads::LocalStructPayload payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayLocal>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::LocalStructPayload;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>
    final : public ::fidl::internal::MessageBase<::fidl::Request<
                ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocolpayloads::LocalStructPayload payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads::LocalStructPayload* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads::LocalStructPayload* operator->() const {
    return &payload_;
  }
  ::test_protocolpayloads::LocalStructPayload& operator*() { return payload_; }
  const ::test_protocolpayloads::LocalStructPayload& operator*() const {
    return payload_;
  }

 private:
  ::test_protocolpayloads::LocalStructPayload payload_;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<
    ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::LocalStructPayload;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayImport> final
    : public ::fidl::internal::MessageBase<::fidl::Request<
          ::test_protocolpayloads::MainProtocol::OneWayImport>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocolpayloads_imported::ImportStructPayload payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads_imported::ImportStructPayload* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload* operator->()
      const {
    return &payload_;
  }
  ::test_protocolpayloads_imported::ImportStructPayload& operator*() {
    return payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocolpayloads_imported::ImportStructPayload payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayImport>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayImport> final
    : public ::fidl::internal::MessageBase<::fidl::Request<
          ::test_protocolpayloads::MainProtocol::TwoWayImport>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocolpayloads_imported::ImportStructPayload payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads_imported::ImportStructPayload* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload* operator->()
      const {
    return &payload_;
  }
  ::test_protocolpayloads_imported::ImportStructPayload& operator*() {
    return payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocolpayloads_imported::ImportStructPayload payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayImport>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>
    final : public ::fidl::internal::MessageBase<::fidl::Request<
                ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocolpayloads_imported::ImportStructPayload payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads_imported::ImportStructPayload* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload* operator->()
      const {
    return &payload_;
  }
  ::test_protocolpayloads_imported::ImportStructPayload& operator*() {
    return payload_;
  }
  const ::test_protocolpayloads_imported::ImportStructPayload& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocolpayloads_imported::ImportStructPayload payload_;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<
    ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayAnon> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayAnon>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocolpayloads::MainProtocolOneWayAnonRequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads::MainProtocolOneWayAnonRequest* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads::MainProtocolOneWayAnonRequest* operator->()
      const {
    return &payload_;
  }
  ::test_protocolpayloads::MainProtocolOneWayAnonRequest& operator*() {
    return payload_;
  }
  const ::test_protocolpayloads::MainProtocolOneWayAnonRequest& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocolpayloads::MainProtocolOneWayAnonRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayAnon>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::MainProtocolOneWayAnonRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayAnon> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayAnon>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocolpayloads::MainProtocolTwoWayAnonRequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads::MainProtocolTwoWayAnonRequest* operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads::MainProtocolTwoWayAnonRequest* operator->()
      const {
    return &payload_;
  }
  ::test_protocolpayloads::MainProtocolTwoWayAnonRequest& operator*() {
    return payload_;
  }
  const ::test_protocolpayloads::MainProtocolTwoWayAnonRequest& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocolpayloads::MainProtocolTwoWayAnonRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayAnon>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::MainProtocolTwoWayAnonRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>
    final : public ::fidl::internal::MessageBase<::fidl::Request<
                ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(
      ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest*
  operator->() {
    return &payload_;
  }
  const ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest*
  operator->() const {
    return &payload_;
  }
  ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest& operator*() {
    return payload_;
  }
  const ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest&
  operator*() const {
    return payload_;
  }

 private:
  ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload =
      ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest;
};
#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayComposed>
    : public ::fidl::CompleterBase {
 public:
  void Reply(::test_protocolpayloads_imported::ImportStructPayload&& payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocolpayloads::MainProtocol::TwoWayComposed> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocolpayloads::MainProtocol::TwoWayComposed>>;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>
    : public ::fidl::CompleterBase {
 public:
  void Reply(::test_protocolpayloads_imported::
                 ComposedProtocolTwoWayComposedWithErrorTopResponse&& payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>>;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayLocal>
    : public ::fidl::CompleterBase {
 public:
  void Reply(::test_protocolpayloads::LocalStructPayload&& payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocolpayloads::MainProtocol::TwoWayLocal> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocolpayloads::MainProtocol::TwoWayLocal>>;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>
    : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorTopResponse&&
          payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>>;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayImport>
    : public ::fidl::CompleterBase {
 public:
  void Reply(::test_protocolpayloads_imported::ImportStructPayload&& payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocolpayloads::MainProtocol::TwoWayImport> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocolpayloads::MainProtocol::TwoWayImport>>;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>
    : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorTopResponse&&
          payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocolpayloads::MainProtocol::TwoWayImportWithError> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>>;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayAnon>
    : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::test_protocolpayloads::MainProtocolTwoWayAnonTopResponse&& payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocolpayloads::MainProtocol::TwoWayAnon> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocolpayloads::MainProtocol::TwoWayAnon>>;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>
    : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorTopResponse&&
          payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>>;
};

template <>
class ::fidl::Server<::test_protocolpayloads::MainProtocol>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocolpayloads::MainProtocol;

  using OneWayComposedRequest =
      ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayComposed>;
  using OneWayComposedCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::OneWayComposed>;

  virtual void OneWayComposed(OneWayComposedRequest& request,
                              OneWayComposedCompleter::Sync& completer) = 0;

  using TwoWayComposedRequest =
      ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayComposed>;
  using TwoWayComposedCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::TwoWayComposed>;

  virtual void TwoWayComposed(TwoWayComposedRequest& request,
                              TwoWayComposedCompleter::Sync& completer) = 0;

  using TwoWayComposedWithErrorRequest = ::fidl::Request<
      ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>;
  using TwoWayComposedWithErrorCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>;

  virtual void TwoWayComposedWithError(
      TwoWayComposedWithErrorRequest& request,
      TwoWayComposedWithErrorCompleter::Sync& completer) = 0;

  using OneWayLocalRequest =
      ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayLocal>;
  using OneWayLocalCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::OneWayLocal>;

  virtual void OneWayLocal(OneWayLocalRequest& request,
                           OneWayLocalCompleter::Sync& completer) = 0;

  using TwoWayLocalRequest =
      ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayLocal>;
  using TwoWayLocalCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::TwoWayLocal>;

  virtual void TwoWayLocal(TwoWayLocalRequest& request,
                           TwoWayLocalCompleter::Sync& completer) = 0;

  using TwoWayLocalWithErrorRequest = ::fidl::Request<
      ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>;
  using TwoWayLocalWithErrorCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>;

  virtual void TwoWayLocalWithError(
      TwoWayLocalWithErrorRequest& request,
      TwoWayLocalWithErrorCompleter::Sync& completer) = 0;

  using OneWayImportRequest =
      ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayImport>;
  using OneWayImportCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::OneWayImport>;

  virtual void OneWayImport(OneWayImportRequest& request,
                            OneWayImportCompleter::Sync& completer) = 0;

  using TwoWayImportRequest =
      ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayImport>;
  using TwoWayImportCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::TwoWayImport>;

  virtual void TwoWayImport(TwoWayImportRequest& request,
                            TwoWayImportCompleter::Sync& completer) = 0;

  using TwoWayImportWithErrorRequest = ::fidl::Request<
      ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>;
  using TwoWayImportWithErrorCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>;

  virtual void TwoWayImportWithError(
      TwoWayImportWithErrorRequest& request,
      TwoWayImportWithErrorCompleter::Sync& completer) = 0;

  using OneWayAnonRequest =
      ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayAnon>;
  using OneWayAnonCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::OneWayAnon>;

  virtual void OneWayAnon(OneWayAnonRequest& request,
                          OneWayAnonCompleter::Sync& completer) = 0;

  using TwoWayAnonRequest =
      ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayAnon>;
  using TwoWayAnonCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::TwoWayAnon>;

  virtual void TwoWayAnon(TwoWayAnonRequest& request,
                          TwoWayAnonCompleter::Sync& completer) = 0;

  using TwoWayAnonWithErrorRequest = ::fidl::Request<
      ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>;
  using TwoWayAnonWithErrorCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>;

  virtual void TwoWayAnonWithError(
      TwoWayAnonWithErrorRequest& request,
      TwoWayAnonWithErrorCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<
    ::test_protocolpayloads::MainProtocol>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(
      ::fidl::Server<::test_protocolpayloads::MainProtocol>* impl,
      ::fidl::IncomingMessage&& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__
