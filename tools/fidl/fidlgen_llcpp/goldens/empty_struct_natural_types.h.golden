// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <fidl/test.emptystruct/cpp/common_types.h>
#include <fidl/test.emptystruct/cpp/markers.h>
#include <lib/fidl/cpp/coding_traits.h>
#include <lib/fidl/cpp/unified_messaging.h>

#include <cinttypes>
#include <string>

#ifdef __Fuchsia__

#include <lib/zx/channel.h>

#endif  // __Fuchsia__

namespace test_emptystruct {
class Empty;

class EmptyProtocolSendRequest;

class EmptyProtocolSendAndReceiveTopResponse;

class EmptyProtocolSendAndReceiveRequest;

class EmptyProtocolReceiveRequest;

extern "C" const fidl_type_t test_emptystruct_EmptyTable;

class Empty final {
 private:
  struct Storage_;

 public:
  Empty(Storage_ storage) noexcept : storage_(std::move(storage)) {}
  Empty(uint8_t __reserved) noexcept
      : storage_({.__reserved = std::move(__reserved)}) {}
  Empty() : Empty(Storage_{}) {}

  Empty(Empty&&) noexcept = default;
  Empty& operator=(Empty&&) noexcept = default;
  Empty(const Empty& other) noexcept : Empty(other.CloneStorage_()) {}
  Empty& operator=(const Empty& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Empty& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_emptystruct::Empty, 1, 1>::Equal(this, &other);
  }
  bool operator!=(const Empty& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_emptystruct::Empty, 1, 1>::Equal(this, &other);
  }

  uint8_t __reserved() const { return storage_.__reserved; }

  uint8_t& __reserved() { return storage_.__reserved; }

 private:
  struct Storage_ final {
    uint8_t __reserved = 0u;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_emptystruct::Empty, 1, 1>;
  friend struct ::fidl::internal::MemberVisitor<::test_emptystruct::Empty>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, uint8_t>{
          &Storage_::__reserved, 0, 0});
};

extern "C" const fidl_type_t test_emptystruct_EmptyProtocolSendRequestTable;

class EmptyProtocolSendRequest final {
 private:
  struct Storage_;

 public:
  EmptyProtocolSendRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  EmptyProtocolSendRequest(::test_emptystruct::Empty e) noexcept
      : storage_({.e = std::move(e)}) {}
  EmptyProtocolSendRequest() : EmptyProtocolSendRequest(Storage_{}) {}

  EmptyProtocolSendRequest(EmptyProtocolSendRequest&&) noexcept = default;
  EmptyProtocolSendRequest& operator=(EmptyProtocolSendRequest&&) noexcept =
      default;
  EmptyProtocolSendRequest(const EmptyProtocolSendRequest& other) noexcept
      : EmptyProtocolSendRequest(other.CloneStorage_()) {}
  EmptyProtocolSendRequest& operator=(
      const EmptyProtocolSendRequest& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const EmptyProtocolSendRequest& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_emptystruct::EmptyProtocolSendRequest, 1, 1>::Equal(this,
                                                                   &other);
  }
  bool operator!=(const EmptyProtocolSendRequest& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_emptystruct::EmptyProtocolSendRequest, 1, 1>::Equal(this,
                                                                   &other);
  }

  const ::test_emptystruct::Empty& e() const { return storage_.e; }

  ::test_emptystruct::Empty& e() { return storage_.e; }

 private:
  struct Storage_ final {
    ::test_emptystruct::Empty e{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_emptystruct::EmptyProtocolSendRequest, 1, 1>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_emptystruct::EmptyProtocolSendRequest>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<
                      Storage_, ::test_emptystruct::Empty>{&Storage_::e, 0, 0});
};

extern "C" const fidl_type_t
    test_emptystruct_EmptyProtocolSendAndReceiveTopResponseTable;

class EmptyProtocolSendAndReceiveTopResponse final {
 private:
  struct Storage_;

 public:
  EmptyProtocolSendAndReceiveTopResponse(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  EmptyProtocolSendAndReceiveTopResponse(::test_emptystruct::Empty e) noexcept
      : storage_({.e = std::move(e)}) {}
  EmptyProtocolSendAndReceiveTopResponse()
      : EmptyProtocolSendAndReceiveTopResponse(Storage_{}) {}

  EmptyProtocolSendAndReceiveTopResponse(
      EmptyProtocolSendAndReceiveTopResponse&&) noexcept = default;
  EmptyProtocolSendAndReceiveTopResponse& operator=(
      EmptyProtocolSendAndReceiveTopResponse&&) noexcept = default;
  EmptyProtocolSendAndReceiveTopResponse(
      const EmptyProtocolSendAndReceiveTopResponse& other) noexcept
      : EmptyProtocolSendAndReceiveTopResponse(other.CloneStorage_()) {}
  EmptyProtocolSendAndReceiveTopResponse& operator=(
      const EmptyProtocolSendAndReceiveTopResponse& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const EmptyProtocolSendAndReceiveTopResponse& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_emptystruct::EmptyProtocolSendAndReceiveTopResponse, 1,
        1>::Equal(this, &other);
  }
  bool operator!=(
      const EmptyProtocolSendAndReceiveTopResponse& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_emptystruct::EmptyProtocolSendAndReceiveTopResponse, 1,
        1>::Equal(this, &other);
  }

  const ::test_emptystruct::Empty& e() const { return storage_.e; }

  ::test_emptystruct::Empty& e() { return storage_.e; }

 private:
  struct Storage_ final {
    ::test_emptystruct::Empty e{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_emptystruct::EmptyProtocolSendAndReceiveTopResponse, 1, 1>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_emptystruct::EmptyProtocolSendAndReceiveTopResponse>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<
                      Storage_, ::test_emptystruct::Empty>{&Storage_::e, 0, 0});
};

extern "C" const fidl_type_t
    test_emptystruct_EmptyProtocolSendAndReceiveRequestTable;

class EmptyProtocolSendAndReceiveRequest final {
 private:
  struct Storage_;

 public:
  EmptyProtocolSendAndReceiveRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  EmptyProtocolSendAndReceiveRequest(::test_emptystruct::Empty e) noexcept
      : storage_({.e = std::move(e)}) {}
  EmptyProtocolSendAndReceiveRequest()
      : EmptyProtocolSendAndReceiveRequest(Storage_{}) {}

  EmptyProtocolSendAndReceiveRequest(
      EmptyProtocolSendAndReceiveRequest&&) noexcept = default;
  EmptyProtocolSendAndReceiveRequest& operator=(
      EmptyProtocolSendAndReceiveRequest&&) noexcept = default;
  EmptyProtocolSendAndReceiveRequest(
      const EmptyProtocolSendAndReceiveRequest& other) noexcept
      : EmptyProtocolSendAndReceiveRequest(other.CloneStorage_()) {}
  EmptyProtocolSendAndReceiveRequest& operator=(
      const EmptyProtocolSendAndReceiveRequest& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const EmptyProtocolSendAndReceiveRequest& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_emptystruct::EmptyProtocolSendAndReceiveRequest, 1,
        1>::Equal(this, &other);
  }
  bool operator!=(
      const EmptyProtocolSendAndReceiveRequest& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_emptystruct::EmptyProtocolSendAndReceiveRequest, 1,
        1>::Equal(this, &other);
  }

  const ::test_emptystruct::Empty& e() const { return storage_.e; }

  ::test_emptystruct::Empty& e() { return storage_.e; }

 private:
  struct Storage_ final {
    ::test_emptystruct::Empty e{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_emptystruct::EmptyProtocolSendAndReceiveRequest, 1, 1>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_emptystruct::EmptyProtocolSendAndReceiveRequest>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<
                      Storage_, ::test_emptystruct::Empty>{&Storage_::e, 0, 0});
};

extern "C" const fidl_type_t test_emptystruct_EmptyProtocolReceiveRequestTable;

class EmptyProtocolReceiveRequest final {
 private:
  struct Storage_;

 public:
  EmptyProtocolReceiveRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  EmptyProtocolReceiveRequest(::test_emptystruct::Empty e) noexcept
      : storage_({.e = std::move(e)}) {}
  EmptyProtocolReceiveRequest() : EmptyProtocolReceiveRequest(Storage_{}) {}

  EmptyProtocolReceiveRequest(EmptyProtocolReceiveRequest&&) noexcept = default;
  EmptyProtocolReceiveRequest& operator=(
      EmptyProtocolReceiveRequest&&) noexcept = default;
  EmptyProtocolReceiveRequest(const EmptyProtocolReceiveRequest& other) noexcept
      : EmptyProtocolReceiveRequest(other.CloneStorage_()) {}
  EmptyProtocolReceiveRequest& operator=(
      const EmptyProtocolReceiveRequest& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const EmptyProtocolReceiveRequest& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_emptystruct::EmptyProtocolReceiveRequest, 1, 1>::Equal(this,
                                                                      &other);
  }
  bool operator!=(const EmptyProtocolReceiveRequest& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_emptystruct::EmptyProtocolReceiveRequest, 1, 1>::Equal(this,
                                                                      &other);
  }

  const ::test_emptystruct::Empty& e() const { return storage_.e; }

  ::test_emptystruct::Empty& e() { return storage_.e; }

 private:
  struct Storage_ final {
    ::test_emptystruct::Empty e{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_emptystruct::EmptyProtocolReceiveRequest, 1, 1>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_emptystruct::EmptyProtocolReceiveRequest>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<
                      Storage_, ::test_emptystruct::Empty>{&Storage_::e, 0, 0});
};

}  // namespace test_emptystruct
namespace fidl {

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_emptystruct_EmptyTable;

template <>
struct IsFidlType<::test_emptystruct::Empty> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_emptystruct::Empty> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_emptystruct_EmptyTable;
};

template <>
struct internal::NaturalCodingTraits<::test_emptystruct::Empty> final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_emptystruct::Empty, 1, 1> {};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_emptystruct::Empty>
    : public internal::BoolConstant<
          !HasPadding<::test_emptystruct::Empty>::value &&
          internal::NaturalIsMemcpyCompatible<uint8_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_emptystruct_EmptyProtocolSendRequestTable;

template <>
struct IsFidlType<::test_emptystruct::EmptyProtocolSendRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_emptystruct::EmptyProtocolSendRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_emptystruct_EmptyProtocolSendRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_emptystruct::EmptyProtocolSendRequest>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_emptystruct::EmptyProtocolSendRequest, 1, 1> {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_emptystruct::EmptyProtocolSendRequest>
    : public internal::BoolConstant<
          !HasPadding<::test_emptystruct::EmptyProtocolSendRequest>::value &&
          internal::NaturalIsMemcpyCompatible<
              ::test_emptystruct::Empty>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_emptystruct_EmptyProtocolSendAndReceiveTopResponseTable;

template <>
struct IsFidlType<::test_emptystruct::EmptyProtocolSendAndReceiveTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_emptystruct::EmptyProtocolSendAndReceiveTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_emptystruct_EmptyProtocolSendAndReceiveTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_emptystruct::EmptyProtocolSendAndReceiveTopResponse>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_emptystruct::EmptyProtocolSendAndReceiveTopResponse, 1, 1> {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_emptystruct::EmptyProtocolSendAndReceiveTopResponse>
    : public internal::BoolConstant<
          !HasPadding<::test_emptystruct::
                          EmptyProtocolSendAndReceiveTopResponse>::value &&
          internal::NaturalIsMemcpyCompatible<
              ::test_emptystruct::Empty>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_emptystruct_EmptyProtocolSendAndReceiveRequestTable;

template <>
struct IsFidlType<::test_emptystruct::EmptyProtocolSendAndReceiveRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_emptystruct::EmptyProtocolSendAndReceiveRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_emptystruct_EmptyProtocolSendAndReceiveRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_emptystruct::EmptyProtocolSendAndReceiveRequest>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_emptystruct::EmptyProtocolSendAndReceiveRequest, 1, 1> {
};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_emptystruct::EmptyProtocolSendAndReceiveRequest>
    : public internal::BoolConstant<
          !HasPadding<
              ::test_emptystruct::EmptyProtocolSendAndReceiveRequest>::value &&
          internal::NaturalIsMemcpyCompatible<
              ::test_emptystruct::Empty>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_emptystruct_EmptyProtocolReceiveRequestTable;

template <>
struct IsFidlType<::test_emptystruct::EmptyProtocolReceiveRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_emptystruct::EmptyProtocolReceiveRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_emptystruct_EmptyProtocolReceiveRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_emptystruct::EmptyProtocolReceiveRequest>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_emptystruct::EmptyProtocolReceiveRequest, 1, 1> {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_emptystruct::EmptyProtocolReceiveRequest>
    : public internal::BoolConstant<
          !HasPadding<::test_emptystruct::EmptyProtocolReceiveRequest>::value &&
          internal::NaturalIsMemcpyCompatible<
              ::test_emptystruct::Empty>::value> {};

#endif  // __Fuchsia__

}  // namespace fidl
