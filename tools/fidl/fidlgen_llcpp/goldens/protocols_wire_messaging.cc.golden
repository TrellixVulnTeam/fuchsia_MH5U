// WARNING: This file is machine generated by fidlgen.

#include <fidl/test.protocols/cpp/wire_messaging.h>

#include <memory>

namespace test_protocols {
[[maybe_unused]] constexpr uint64_t
    kHandleRightsProtocol_NoResponseMethod_Ordinal = 1155044649514904573lu;

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;

[[maybe_unused]] constexpr uint64_t
    kHandleRightsProtocol_ResponseMethod_Ordinal = 5956276128041940295lu;

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodRequestTable;

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;

[[maybe_unused]] constexpr uint64_t kHandleRightsProtocol_AnEvent_Ordinal =
    476727631355490611lu;

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolAnEventRequestTable;
#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::HandleRightsProtocol::NoResponseMethod>*
            request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::NoResponseMethod>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client.handle());
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<
    ::test_protocols::HandleRightsProtocol::NoResponseMethod>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>
            client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::HandleRightsProtocol::NoResponseMethod>*
            request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::HandleRightsProtocol::NoResponseMethod>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  uint32_t request_byte_capacity = buffer_size;
  uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::NoResponseMethod>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client_end.handle());
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetResult(outgoing);
}

::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>* request,
        zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>
            client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

::fidl::Result fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::HandleRightsProtocol>::NoResponseMethod(::zx::socket&&
                                                                  h) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::HandleRightsProtocol::NoResponseMethod>
      _request_object{std::move(h)};
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::NoResponseMethod>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{},
                       &_request_object);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
void fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::HandleRightsProtocol>::
    ResponseMethod(::zx::socket&& h,
                   ::fidl::WireClientCallback<
                       ::test_protocols::HandleRightsProtocol::ResponseMethod>
                       _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::HandleRightsProtocol::ResponseMethod> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(::fidl::WireUnownedResult<
                  ::test_protocols::HandleRightsProtocol::ResponseMethod>&
                      result) override {
      cb_(result);
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>
      _request{std::move(h)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

void fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::HandleRightsProtocol>::
    ResponseMethod(
        ::zx::socket&& h,
        ::fit::callback<
            void(::fidl::WireResponse<::test_protocols::HandleRightsProtocol::
                                          ResponseMethod>* response)>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::HandleRightsProtocol::ResponseMethod> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(::fidl::WireUnownedResult<
                  ::test_protocols::HandleRightsProtocol::ResponseMethod>&
                      result) override {
      if (result.ok()) {
        ::fidl::WireResponse<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>* response =
            result.Unwrap();
        cb_(response);
      }
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>
      _request{std::move(h)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
::fidl::Result fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::HandleRightsProtocol>::NoResponseMethod(::zx::socket&&
                                                                  h) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::HandleRightsProtocol::NoResponseMethod>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::HandleRightsProtocol::NoResponseMethod>
      _request{std::move(h)};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::NoResponseMethod>>
      _request_message(_allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
void fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::HandleRightsProtocol>::
    ResponseMethod(
        ::zx::socket&& h,
        ::fidl::WireResponseContext<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>* _context) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    _client_base()->SendTwoWay(_failure, _context);
    return;
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>
      _request{std::move(h)};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>>
      _request_message(_allocation->data, _buffer_size, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::HandleRightsProtocol>::ResponseMethod(::zx::socket&& h) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>
            _request{std::move(h)};
        return ::fidl::WireResult<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>(
            ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fidl::Result
fidl::WireSyncEventHandler<::test_protocols::HandleRightsProtocol>::
    HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>
            client_end) {
  zx_status_t status = client_end.channel()->wait_one(
      ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED, ::zx::time::infinite(),
      nullptr);
  if (status != ZX_OK) {
    return ::fidl::Result::TransportError(
        status, ::fidl::internal::kErrorWaitOneFailed);
  }
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
            ::test_protocols::HandleRightsProtocol::AnEvent>>::kMaxNumHandles >=
        x) {
      x = ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
          ::test_protocols::HandleRightsProtocol::AnEvent>>::kMaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  static_assert(kHandleAllocSize <= ZX_CHANNEL_MAX_MSG_HANDLES);
  ::fidl::internal::InlineMessageBuffer<24> read_storage;
  std::array<zx_handle_t, kHandleAllocSize> read_handles;
  // TODO(fxbug.dev/85734) Remove this channel-specific allocation.
  std::array<fidl_channel_handle_metadata_t, kHandleAllocSize>
      read_handle_metadata;
  ::fidl::IncomingMessage msg = ::fidl::MessageRead(
      zx::unowned_channel(client_end.handle()), read_storage.view(),
      read_handles.data(), read_handle_metadata.data(), kHandleAllocSize,
      ReadOptions{.discardable = true});
  if (msg.status() == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Result::UnexpectedMessage(Unknown());
  }
  if (!msg.ok()) {
    return msg;
  }
  fidl_message_header_t* hdr = msg.header();
  switch (hdr->ordinal) {
    case ::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::HandleRightsProtocol::AnEvent>>
          decoded{::std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::Result(decoded);
      }
      auto* primary = &decoded.PrimaryObject()->body;
      AnEvent(primary);
      return ::fidl::Result::Ok();
    }
    default: {
      return ::fidl::Result::UnexpectedMessage(Unknown());
    }
  }
}

std::optional<::fidl::UnbindInfo> fidl::internal::
    WireEventDispatcher<::test_protocols::HandleRightsProtocol>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::HandleRightsProtocol::AnEvent>>
          decoded{std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::UnbindInfo{decoded};
      }
      if (event_handler()) {
        auto* primary = &decoded.PrimaryObject()->body;
        event_handler()->AnEvent(primary);
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<
    ::test_protocols::HandleRightsProtocol>::entries_[] = {
    {
        ::test_protocols::kHandleRightsProtocol_NoResponseMethod_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::HandleRightsProtocol::NoResponseMethod>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::HandleRightsProtocol::NoResponseMethod>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::HandleRightsProtocol>*>(
              interface)
              ->NoResponseMethod(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::HandleRightsProtocol::ResponseMethod>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::HandleRightsProtocol>*>(
              interface)
              ->ResponseMethod(primary, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<
    ::test_protocols::HandleRightsProtocol>::entries_end_ = &entries_[2];

::fidl::DispatchResult fidl::internal::
    WireServerDispatcher<::test_protocols::HandleRightsProtocol>::TryDispatch(
        ::fidl::WireServer<::test_protocols::HandleRightsProtocol>* impl,
        ::fidl::IncomingMessage& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(impl, msg, std::move(transport_context),
                                       txn, entries_, entries_end_);
}

void fidl::internal::
    WireServerDispatcher<::test_protocols::HandleRightsProtocol>::Dispatch(
        ::fidl::WireServer<::test_protocols::HandleRightsProtocol>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::WireServer<::test_protocols::HandleRightsProtocol>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::WireServerDispatcher<
      ::test_protocols::HandleRightsProtocol>::Dispatch(this, std::move(msg),
                                                        std::move(
                                                            transport_context),
                                                        txn);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>::
    Reply(::zx::socket&& h) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>
      _response{std::move(h)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>::
    Reply(::zx::socket&& h) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>
      _response{std::move(h)};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::HandleRightsProtocol::NoResponseMethod>::_InitHeader() {
  fidl_init_txn_header(
      &header, 0,
      ::test_protocols::kHandleRightsProtocol_NoResponseMethod_Ordinal);
}

void ::fidl::WireRequest<
    ::test_protocols::HandleRightsProtocol::NoResponseMethod>::_CloseHandles() {
  h.reset();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>::_InitHeader() {
  fidl_init_txn_header(
      &header, 0,
      ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal);
}

void ::fidl::WireRequest<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>::_CloseHandles() {
  h.reset();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>::_InitHeader() {
  fidl_init_txn_header(
      &header, 0,
      ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal);
}

void ::fidl::WireResponse<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>::_CloseHandles() {
  h.reset();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalEvent<
    ::test_protocols::HandleRightsProtocol::AnEvent>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal);
}

void ::fidl::WireEvent<
    ::test_protocols::HandleRightsProtocol::AnEvent>::_CloseHandles() {
  h.reset();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

fidl::Result fidl::internal::WireWeakEventSender<
    ::test_protocols::HandleRightsProtocol>::AnEvent(::zx::socket&& h) {
  ::fidl::internal::TransactionalEvent<
      ::test_protocols::HandleRightsProtocol::AnEvent>
      _response{std::move(h)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::HandleRightsProtocol::AnEvent>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Result fidl::internal::WireWeakBufferEventSender<
    ::test_protocols::HandleRightsProtocol>::AnEvent(::zx::socket&& h) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::HandleRightsProtocol::AnEvent>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<
      ::test_protocols::HandleRightsProtocol::AnEvent>
      _response{std::move(h)};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::HandleRightsProtocol::AnEvent>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Result fidl::internal::WireEventSender<
    ::test_protocols::HandleRightsProtocol>::AnEvent(::zx::socket&& h) {
  ::fidl::internal::TransactionalEvent<
      ::test_protocols::HandleRightsProtocol::AnEvent>
      _response{std::move(h)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::HandleRightsProtocol::AnEvent>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Result{_message};
}

fidl::Result fidl::internal::WireBufferEventSender<
    ::test_protocols::HandleRightsProtocol>::AnEvent(::zx::socket&& h) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::HandleRightsProtocol::AnEvent>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<
      ::test_protocols::HandleRightsProtocol::AnEvent>
      _response{std::move(h)};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::HandleRightsProtocol::AnEvent>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Result{_message};
}

#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal =
        5413654872775949227lu;

[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal =
        1631193469798418024lu;

[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal =
        9037369643591427517lu;

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;

[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal =
        7326057319832554103lu;

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;

[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal =
        2877322062572412767lu;

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;

[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal =
        6417226585456833969lu;

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;

[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal =
        5397663296507358806lu;

[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_OnWithResponse_Ordinal =
        5811598563493228968lu;

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;
#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       NoRequestNoResponse>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client.handle());
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       NoRequestEmptyResponse>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetResult(outgoing);
}

::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       NoRequestEmptyResponse>* request,
               zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       NoRequestWithResponse>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetResult(outgoing);
}

::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       NoRequestWithResponse>* request,
               zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::
    WireUnownedResult(::fidl::UnownedClientEnd<
                          ::test_protocols::WithAndWithoutRequestResponse>
                          client_end,
                      ::fidl::internal::AnyBufferAllocator& allocator,
                      ::fidl::internal::TransactionalRequest<
                          ::test_protocols::WithAndWithoutRequestResponse::
                              NoRequestWithResponse>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       WithRequestNoResponse>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestNoResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client.handle());
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>::
    WireUnownedResult(::fidl::UnownedClientEnd<
                          ::test_protocols::WithAndWithoutRequestResponse>
                          client_end,
                      ::fidl::internal::AnyBufferAllocator& allocator,
                      ::fidl::internal::TransactionalRequest<
                          ::test_protocols::WithAndWithoutRequestResponse::
                              WithRequestNoResponse>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  uint32_t request_byte_capacity = buffer_size;
  uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestNoResponse>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client_end.handle());
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       WithRequestEmptyResponse>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>>(client.handle(), bytes_.data(),
                                     static_cast<uint32_t>(bytes_.size()));
  SetResult(outgoing);
}

::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       WithRequestEmptyResponse>* request,
               zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>>(client.handle(), bytes_.data(),
                                     static_cast<uint32_t>(bytes_.size()),
                                     fidl::CallOptions{.deadline = deadline});
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::
    WireUnownedResult(::fidl::UnownedClientEnd<
                          ::test_protocols::WithAndWithoutRequestResponse>
                          client_end,
                      ::fidl::internal::AnyBufferAllocator& allocator,
                      ::fidl::internal::TransactionalRequest<
                          ::test_protocols::WithAndWithoutRequestResponse::
                              WithRequestEmptyResponse>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>>(client_end.handle(), response_bytes,
                                     response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       WithRequestWithResponse>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>>(client.handle(), bytes_.data(),
                                    static_cast<uint32_t>(bytes_.size()));
  SetResult(outgoing);
}

::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       WithRequestWithResponse>* request,
               zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>>(client.handle(), bytes_.data(),
                                    static_cast<uint32_t>(bytes_.size()),
                                    fidl::CallOptions{.deadline = deadline});
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::
    WireUnownedResult(::fidl::UnownedClientEnd<
                          ::test_protocols::WithAndWithoutRequestResponse>
                          client_end,
                      ::fidl::internal::AnyBufferAllocator& allocator,
                      ::fidl::internal::TransactionalRequest<
                          ::test_protocols::WithAndWithoutRequestResponse::
                              WithRequestWithResponse>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>>(client_end.handle(), response_bytes,
                                    response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

::fidl::Result fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::NoRequestNoResponse() {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
      _request_object{};
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{},
                       &_request_object);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::Result fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestNoResponse(::fidl::StringView arg) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
      _request_object{arg};
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestNoResponse>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{},
                       &_request_object);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
void fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestEmptyResponse(::fidl::WireClientCallback<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestEmptyResponse>
                               _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithAndWithoutRequestResponse::
                NoRequestEmptyResponse> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(::fidl::WireUnownedResult<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      NoRequestEmptyResponse>& result) override {
      cb_(result);
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
      _request{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

void fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestEmptyResponse(::fit::callback<void()> _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithAndWithoutRequestResponse::
                NoRequestEmptyResponse> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(::fidl::WireUnownedResult<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      NoRequestEmptyResponse>& result) override {
      if (result.ok()) {
        cb_();
      }
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
      _request{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestWithResponse(::fidl::WireClientCallback<
                          ::test_protocols::WithAndWithoutRequestResponse::
                              NoRequestWithResponse>
                              _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithAndWithoutRequestResponse::
                NoRequestWithResponse> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(::fidl::WireUnownedResult<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      NoRequestWithResponse>& result) override {
      cb_(result);
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
      _request{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

void fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestWithResponse(
        ::fit::callback<void(::fidl::WireResponse<
                             ::test_protocols::WithAndWithoutRequestResponse::
                                 NoRequestWithResponse>* response)>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithAndWithoutRequestResponse::
                NoRequestWithResponse> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(::fidl::WireUnownedResult<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      NoRequestWithResponse>& result) override {
      if (result.ok()) {
        ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::
                                 NoRequestWithResponse>* response =
            result.Unwrap();
        cb_(response);
      }
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
      _request{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestEmptyResponse(
        ::fidl::StringView arg,
        ::fidl::WireClientCallback<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestEmptyResponse>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestEmptyResponse> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(::fidl::WireUnownedResult<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      WithRequestEmptyResponse>& result) override {
      cb_(result);
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
      _request{arg};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

void fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestEmptyResponse(::fidl::StringView arg,
                             ::fit::callback<void()> _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestEmptyResponse> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(::fidl::WireUnownedResult<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      WithRequestEmptyResponse>& result) override {
      if (result.ok()) {
        cb_();
      }
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
      _request{arg};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestWithResponse(
        ::fidl::StringView arg,
        ::fidl::WireClientCallback<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestWithResponse>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestWithResponse> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(::fidl::WireUnownedResult<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      WithRequestWithResponse>& result) override {
      cb_(result);
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
      _request{arg};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

void fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestWithResponse(
        ::fidl::StringView arg,
        ::fit::callback<void(::fidl::WireResponse<
                             ::test_protocols::WithAndWithoutRequestResponse::
                                 WithRequestWithResponse>* response)>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestWithResponse> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(::fidl::WireUnownedResult<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      WithRequestWithResponse>& result) override {
      if (result.ok()) {
        ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::
                                 WithRequestWithResponse>* response =
            result.Unwrap();
        cb_(response);
      }
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
      _request{arg};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
::fidl::Result fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::NoRequestNoResponse() {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestNoResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
      _request{};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>>
      _request_message(_allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::Result fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestNoResponse(::fidl::StringView arg) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestNoResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
      _request{arg};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestNoResponse>>
      _request_message(_allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
void fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestEmptyResponse(::fidl::WireResponseContext<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestEmptyResponse>* _context) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    _client_base()->SendTwoWay(_failure, _context);
    return;
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
      _request{};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>>
      _request_message(_allocation->data, _buffer_size, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestWithResponse(::fidl::WireResponseContext<
                          ::test_protocols::WithAndWithoutRequestResponse::
                              NoRequestWithResponse>* _context) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    _client_base()->SendTwoWay(_failure, _context);
    return;
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
      _request{};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>>
      _request_message(_allocation->data, _buffer_size, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestEmptyResponse(
        ::fidl::StringView arg,
        ::fidl::WireResponseContext<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestEmptyResponse>* _context) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    _client_base()->SendTwoWay(_failure, _context);
    return;
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
      _request{arg};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>>
      _request_message(_allocation->data, _buffer_size, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestWithResponse(
        ::fidl::StringView arg,
        ::fidl::WireResponseContext<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestWithResponse>* _context) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    _client_base()->SendTwoWay(_failure, _context);
    return;
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
      _request{arg};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>>
      _request_message(_allocation->data, _buffer_size, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::NoRequestEmptyResponse() {
  return _client_base()->MakeSyncCallWith([&](std::shared_ptr<
                                              ::fidl::internal::AnyTransport>
                                                  _transport) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
        _request{};
    return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::
                                  NoRequestEmptyResponse>(
        ::fidl::UnownedClientEnd<
            ::test_protocols::WithAndWithoutRequestResponse>(
            _transport->get<::fidl::internal::ChannelTransport>()),
        &_request);
  });
}

::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::NoRequestWithResponse() {
  return _client_base()->MakeSyncCallWith([&](std::shared_ptr<
                                              ::fidl::internal::AnyTransport>
                                                  _transport) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
        _request{};
    return ::fidl::WireResult<
        ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(
        ::fidl::UnownedClientEnd<
            ::test_protocols::WithAndWithoutRequestResponse>(
            _transport->get<::fidl::internal::ChannelTransport>()),
        &_request);
  });
}

::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestEmptyResponse(::fidl::StringView arg) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestEmptyResponse>
            _request{arg};
        return ::fidl::WireResult<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestEmptyResponse>(
            ::fidl::UnownedClientEnd<
                ::test_protocols::WithAndWithoutRequestResponse>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}

::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestWithResponse(::fidl::StringView arg) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestWithResponse>
            _request{arg};
        return ::fidl::WireResult<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestWithResponse>(
            ::fidl::UnownedClientEnd<
                ::test_protocols::WithAndWithoutRequestResponse>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fidl::Result
fidl::WireSyncEventHandler<::test_protocols::WithAndWithoutRequestResponse>::
    HandleOneEvent(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                       client_end) {
  zx_status_t status = client_end.channel()->wait_one(
      ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED, ::zx::time::infinite(),
      nullptr);
  if (status != ZX_OK) {
    return ::fidl::Result::TransportError(
        status, ::fidl::internal::kErrorWaitOneFailed);
  }
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
            ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>::
            kMaxNumHandles >= x) {
      x = ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>::
          kMaxNumHandles;
    }
    if (::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
            ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>::
            kMaxNumHandles >= x) {
      x = ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>::
          kMaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  static_assert(kHandleAllocSize <= ZX_CHANNEL_MAX_MSG_HANDLES);
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> read_storage;
  std::array<zx_handle_t, kHandleAllocSize> read_handles;
  // TODO(fxbug.dev/85734) Remove this channel-specific allocation.
  std::array<fidl_channel_handle_metadata_t, kHandleAllocSize>
      read_handle_metadata;
  ::fidl::IncomingMessage msg = ::fidl::MessageRead(
      zx::unowned_channel(client_end.handle()), read_storage.view(),
      read_handles.data(), read_handle_metadata.data(), kHandleAllocSize,
      ReadOptions{.discardable = true});
  if (msg.status() == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Result::UnexpectedMessage(Unknown());
  }
  if (!msg.ok()) {
    return msg;
  }
  fidl_message_header_t* hdr = msg.header();
  switch (hdr->ordinal) {
    case ::test_protocols::
        kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>
          decoded{::std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::Result(decoded);
      }
      ::fidl::WireEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
          empty_event;
      auto* primary = &empty_event;
      OnEmptyResponse(primary);
      return ::fidl::Result::Ok();
    }
    case ::test_protocols::
        kWithAndWithoutRequestResponse_OnWithResponse_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>
          decoded{::std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::Result(decoded);
      }
      auto* primary = &decoded.PrimaryObject()->body;
      OnWithResponse(primary);
      return ::fidl::Result::Ok();
    }
    default: {
      return ::fidl::Result::UnexpectedMessage(Unknown());
    }
  }
}

std::optional<::fidl::UnbindInfo> fidl::internal::WireEventDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::
    DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::
        kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>
          decoded{std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::UnbindInfo{decoded};
      }
      if (event_handler()) {
        ::fidl::WireEvent<
            ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
            empty_event;
        auto* primary = &empty_event;
        event_handler()->OnEmptyResponse(primary);
      }
      return std::nullopt;
    }
    case ::test_protocols::
        kWithAndWithoutRequestResponse_OnWithResponse_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>
          decoded{std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::UnbindInfo{decoded};
      }
      if (event_handler()) {
        auto* primary = &decoded.PrimaryObject()->body;
        event_handler()->OnWithResponse(primary);
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::entries_[] = {
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::
                                  NoRequestNoResponse>
              empty_request;
          auto* primary = &empty_request;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestNoResponse>::Sync completer(txn);
          reinterpret_cast<::fidl::WireServer<
              ::test_protocols::WithAndWithoutRequestResponse>*>(interface)
              ->NoRequestNoResponse(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::
                                  NoRequestEmptyResponse>
              empty_request;
          auto* primary = &empty_request;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestEmptyResponse>::Sync completer(txn);
          reinterpret_cast<::fidl::WireServer<
              ::test_protocols::WithAndWithoutRequestResponse>*>(interface)
              ->NoRequestEmptyResponse(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::
                                  NoRequestWithResponse>
              empty_request;
          auto* primary = &empty_request;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestWithResponse>::Sync completer(txn);
          reinterpret_cast<::fidl::WireServer<
              ::test_protocols::WithAndWithoutRequestResponse>*>(interface)
              ->NoRequestWithResponse(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      WithRequestNoResponse>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestNoResponse>::Sync completer(txn);
          reinterpret_cast<::fidl::WireServer<
              ::test_protocols::WithAndWithoutRequestResponse>*>(interface)
              ->WithRequestNoResponse(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      WithRequestEmptyResponse>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestEmptyResponse>::Sync completer(txn);
          reinterpret_cast<::fidl::WireServer<
              ::test_protocols::WithAndWithoutRequestResponse>*>(interface)
              ->WithRequestEmptyResponse(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      WithRequestWithResponse>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestWithResponse>::Sync completer(txn);
          reinterpret_cast<::fidl::WireServer<
              ::test_protocols::WithAndWithoutRequestResponse>*>(interface)
              ->WithRequestWithResponse(primary, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::entries_end_ =
    &entries_[6];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::
    TryDispatch(::fidl::WireServer<
                    ::test_protocols::WithAndWithoutRequestResponse>* impl,
                ::fidl::IncomingMessage& msg,
                internal::IncomingTransportContext transport_context,
                ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(impl, msg, std::move(transport_context),
                                       txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::
    Dispatch(::fidl::WireServer<
                 ::test_protocols::WithAndWithoutRequestResponse>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>::
    dispatch_message(
        ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
        ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::WireServerDispatcher<
      ::test_protocols::WithAndWithoutRequestResponse>::
      Dispatch(this, std::move(msg), std::move(transport_context), txn);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::
    Reply() {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
      _response{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::
    Reply() {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
      _response{};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::
    Reply(::fidl::StringView ret) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
      _response{ret};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::
    Reply(::fidl::StringView ret) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
      _response{ret};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::
    Reply() {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
      _response{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::
    Reply() {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
      _response{};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::
    Reply(::fidl::StringView ret) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
      _response{ret};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::
    Reply(::fidl::StringView ret) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
      _response{ret};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>::
    _InitHeader() {
  fidl_init_txn_header(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::
    _InitHeader() {
  fidl_init_txn_header(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal);
}

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::
    _InitHeader() {
  fidl_init_txn_header(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::
    _InitHeader() {
  fidl_init_txn_header(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal);
}

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::
    _InitHeader() {
  fidl_init_txn_header(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>::
    _InitHeader() {
  fidl_init_txn_header(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::
    _InitHeader() {
  fidl_init_txn_header(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal);
}

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::
    _InitHeader() {
  fidl_init_txn_header(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::
    _InitHeader() {
  fidl_init_txn_header(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal);
}

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::
    _InitHeader() {
  fidl_init_txn_header(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal);
}

void ::fidl::internal::TransactionalEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>::
    _InitHeader() {
  fidl_init_txn_header(
      &header, 0,
      ::test_protocols::kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal);
}

void ::fidl::internal::TransactionalEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>::
    _InitHeader() {
  fidl_init_txn_header(
      &header, 0,
      ::test_protocols::kWithAndWithoutRequestResponse_OnWithResponse_Ordinal);
}

#ifdef __Fuchsia__

fidl::Result fidl::internal::WireWeakEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  ::fidl::internal::TransactionalEvent<
      ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
      _response{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Result fidl::internal::WireWeakBufferEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<
      ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
      _response{};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Result fidl::internal::WireEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  ::fidl::internal::TransactionalEvent<
      ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
      _response{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Result{_message};
}

fidl::Result fidl::internal::WireBufferEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<
      ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
      _response{};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Result{_message};
}

fidl::Result fidl::internal::WireWeakEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::
    OnWithResponse(::fidl::StringView ret) {
  ::fidl::internal::TransactionalEvent<
      ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>
      _response{ret};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Result fidl::internal::WireWeakBufferEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::
    OnWithResponse(::fidl::StringView ret) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<
      ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>
      _response{ret};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Result fidl::internal::WireEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::
    OnWithResponse(::fidl::StringView ret) {
  ::fidl::internal::TransactionalEvent<
      ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>
      _response{ret};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Result{_message};
}

fidl::Result fidl::internal::WireBufferEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::
    OnWithResponse(::fidl::StringView ret) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<
      ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>
      _response{ret};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Result{_message};
}

#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr uint64_t kTransitional_Request_Ordinal =
    5849263021838298888lu;

extern "C" const fidl_type_t test_protocols_TransitionalRequestRequestTable;

extern "C" const fidl_type_t test_protocols_TransitionalRequestTopResponseTable;

[[maybe_unused]] constexpr uint64_t kTransitional_OneWay_Ordinal =
    4336658926562441191lu;

extern "C" const fidl_type_t test_protocols_TransitionalOneWayRequestTable;

[[maybe_unused]] constexpr uint64_t kTransitional_Event_Ordinal =
    8507647465196374081lu;

extern "C" const fidl_type_t test_protocols_TransitionalEventRequestTable;
#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::Transitional::Request>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::Transitional> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::Transitional::Request>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::Transitional::Request>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::Transitional::Request>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetResult(outgoing);
}

::fidl::WireResult<::test_protocols::Transitional::Request>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::Transitional> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::Transitional::Request>* request,
    zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::Transitional::Request>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::Transitional::Request>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::Transitional::Request>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::Transitional::Request>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::Transitional::Request>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity =
      ::fidl::MaxSizeInChannel<::fidl::internal::TransactionalRequest<
                                   ::test_protocols::Transitional::Request>,
                               ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::Transitional::Request>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::Transitional::Request>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::Transitional::OneWay>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::Transitional> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::Transitional::OneWay>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::Transitional::OneWay>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client.handle());
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::Transitional::OneWay>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::Transitional::OneWay>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::Transitional::OneWay>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  uint32_t request_byte_capacity = buffer_size;
  uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::Transitional::OneWay>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client_end.handle());
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

::fidl::Result fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::Transitional>::OneWay(int64_t x) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>
      _request_object{x};
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::Transitional::OneWay>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{},
                       &_request_object);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
void fidl::internal::WireWeakAsyncClientImpl<::test_protocols::Transitional>::
    Request(int64_t x,
            ::fidl::WireClientCallback<::test_protocols::Transitional::Request>
                _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final : public ::fidl::WireResponseContext<
                                    ::test_protocols::Transitional::Request> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(
        ::fidl::WireUnownedResult<::test_protocols::Transitional::Request>&
            result) override {
      cb_(result);
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::Transitional::Request>
      _request{x};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::Transitional::Request>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

void fidl::internal::WireWeakAsyncClientImpl<::test_protocols::Transitional>::
    Request(int64_t x,
            ::fit::callback<void(
                ::fidl::WireResponse<::test_protocols::Transitional::Request>*
                    response)>
                _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final : public ::fidl::WireResponseContext<
                                    ::test_protocols::Transitional::Request> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(
        ::fidl::WireUnownedResult<::test_protocols::Transitional::Request>&
            result) override {
      if (result.ok()) {
        ::fidl::WireResponse<::test_protocols::Transitional::Request>*
            response = result.Unwrap();
        cb_(response);
      }
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::Transitional::Request>
      _request{x};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::Transitional::Request>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
::fidl::Result fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::Transitional>::OneWay(int64_t x) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::Transitional::OneWay>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>
      _request{x};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::Transitional::OneWay>>
      _request_message(_allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
void fidl::internal::
    WireWeakAsyncBufferClientImpl<::test_protocols::Transitional>::Request(
        int64_t x,
        ::fidl::WireResponseContext<::test_protocols::Transitional::Request>*
            _context) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::Transitional::Request>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    _client_base()->SendTwoWay(_failure, _context);
    return;
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::Transitional::Request>
      _request{x};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::Transitional::Request>>
      _request_message(_allocation->data, _buffer_size, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

::fidl::WireResult<::test_protocols::Transitional::Request>
fidl::internal::WireWeakSyncClientImpl<::test_protocols::Transitional>::Request(
    int64_t x) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::Transitional::Request>
            _request{x};
        return ::fidl::WireResult<::test_protocols::Transitional::Request>(
            ::fidl::UnownedClientEnd<::test_protocols::Transitional>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fidl::Result
fidl::WireSyncEventHandler<::test_protocols::Transitional>::HandleOneEvent(
    ::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end) {
  zx_status_t status = client_end.channel()->wait_one(
      ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED, ::zx::time::infinite(),
      nullptr);
  if (status != ZX_OK) {
    return ::fidl::Result::TransportError(
        status, ::fidl::internal::kErrorWaitOneFailed);
  }
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
            ::test_protocols::Transitional::Event>>::kMaxNumHandles >= x) {
      x = ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
          ::test_protocols::Transitional::Event>>::kMaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  static_assert(kHandleAllocSize <= ZX_CHANNEL_MAX_MSG_HANDLES);
  ::fidl::internal::InlineMessageBuffer<24> read_storage;
  std::array<zx_handle_t, kHandleAllocSize> read_handles;
  // TODO(fxbug.dev/85734) Remove this channel-specific allocation.
  std::array<fidl_channel_handle_metadata_t, kHandleAllocSize>
      read_handle_metadata;
  ::fidl::IncomingMessage msg = ::fidl::MessageRead(
      zx::unowned_channel(client_end.handle()), read_storage.view(),
      read_handles.data(), read_handle_metadata.data(), kHandleAllocSize,
      ReadOptions{.discardable = true});
  if (msg.status() == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Result::UnexpectedMessage(Unknown());
  }
  if (!msg.ok()) {
    return msg;
  }
  fidl_message_header_t* hdr = msg.header();
  switch (hdr->ordinal) {
    case ::test_protocols::kTransitional_Event_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::Transitional::Event>>
          decoded{::std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::Result(decoded);
      }
      auto* primary = &decoded.PrimaryObject()->body;
      Event(primary);
      return ::fidl::Result::Ok();
    }
    default: {
      return ::fidl::Result::UnexpectedMessage(Unknown());
    }
  }
}

std::optional<::fidl::UnbindInfo> fidl::internal::
    WireEventDispatcher<::test_protocols::Transitional>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kTransitional_Event_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::Transitional::Event>>
          decoded{std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::UnbindInfo{decoded};
      }
      if (event_handler()) {
        auto* primary = &decoded.PrimaryObject()->body;
        event_handler()->Event(primary);
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<
    ::test_protocols::Transitional>::entries_[] = {
    {
        ::test_protocols::kTransitional_Request_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::Transitional::Request>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::Transitional::Request>::Sync completer(txn);
          reinterpret_cast<::fidl::WireServer<::test_protocols::Transitional>*>(
              interface)
              ->Request(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kTransitional_OneWay_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::Transitional::OneWay>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::Transitional::OneWay>::Sync completer(txn);
          reinterpret_cast<::fidl::WireServer<::test_protocols::Transitional>*>(
              interface)
              ->OneWay(primary, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<
    ::test_protocols::Transitional>::entries_end_ = &entries_[2];

::fidl::DispatchResult fidl::internal::
    WireServerDispatcher<::test_protocols::Transitional>::TryDispatch(
        ::fidl::WireServer<::test_protocols::Transitional>* impl,
        ::fidl::IncomingMessage& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(impl, msg, std::move(transport_context),
                                       txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::Transitional>::
    Dispatch(::fidl::WireServer<::test_protocols::Transitional>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::WireServer<::test_protocols::Transitional>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::WireServerDispatcher<
      ::test_protocols::Transitional>::Dispatch(this, std::move(msg),
                                                std::move(transport_context),
                                                txn);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::Transitional::Request>::Reply(int64_t y) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::Transitional::Request>
      _response{y};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::Transitional::Request>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::Transitional::Request>::Reply(int64_t y) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::Transitional::Request>
      _response{y};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::Transitional::Request>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::Transitional::Request>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::Transitional::Request>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kTransitional_Request_Ordinal);
}

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::Transitional::Request>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kTransitional_Request_Ordinal);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::Transitional::OneWay>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kTransitional_OneWay_Ordinal);
}

void ::fidl::internal::TransactionalEvent<
    ::test_protocols::Transitional::Event>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kTransitional_Event_Ordinal);
}

#ifdef __Fuchsia__

fidl::Result fidl::internal::WireWeakEventSender<
    ::test_protocols::Transitional>::Event(int64_t x) {
  ::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>
      _response{x};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::Transitional::Event>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Result fidl::internal::WireWeakBufferEventSender<
    ::test_protocols::Transitional>::Event(int64_t x) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::Transitional::Event>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>
      _response{x};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::Transitional::Event>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Result fidl::internal::WireEventSender<
    ::test_protocols::Transitional>::Event(int64_t x) {
  ::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>
      _response{x};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::Transitional::Event>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Result{_message};
}

fidl::Result fidl::internal::WireBufferEventSender<
    ::test_protocols::Transitional>::Event(int64_t x) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::Transitional::Event>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>
      _response{x};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::Transitional::Event>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Result{_message};
}

#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr uint64_t kMethodWithUnion_UnionMethod_Ordinal =
    4124874338266649112lu;

extern "C" const fidl_type_t
    test_protocols_MethodWithUnionUnionMethodRequestTable;
#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::MethodWithUnion::UnionMethod>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::MethodWithUnion::UnionMethod>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client.handle());
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::MethodWithUnion::UnionMethod>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::MethodWithUnion::UnionMethod>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::MethodWithUnion::UnionMethod>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  uint32_t request_byte_capacity = buffer_size;
  uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::MethodWithUnion::UnionMethod>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client_end.handle());
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

::fidl::Result fidl::internal::
    WireWeakOnewayClientImpl<::test_protocols::MethodWithUnion>::UnionMethod(
        ::test_protocols::wire::TheUnion u) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::MethodWithUnion::UnionMethod>
      _request_object{u};
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::MethodWithUnion::UnionMethod>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{},
                       &_request_object);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::Result fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::MethodWithUnion>::
    UnionMethod(::test_protocols::wire::TheUnion u) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::MethodWithUnion::UnionMethod>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::MethodWithUnion::UnionMethod>
      _request{u};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::MethodWithUnion::UnionMethod>>
      _request_message(_allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fidl::Result
fidl::WireSyncEventHandler<::test_protocols::MethodWithUnion>::HandleOneEvent(
    ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client_end) {
  zx_status_t status = client_end.channel()->wait_one(
      ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED, ::zx::time::infinite(),
      nullptr);
  if (status != ZX_OK) {
    return ::fidl::Result::TransportError(
        status, ::fidl::internal::kErrorWaitOneFailed);
  }
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  static_assert(kHandleAllocSize <= ZX_CHANNEL_MAX_MSG_HANDLES);
  ::fidl::internal::InlineMessageBuffer<16> read_storage;
  std::array<zx_handle_t, kHandleAllocSize> read_handles;
  // TODO(fxbug.dev/85734) Remove this channel-specific allocation.
  std::array<fidl_channel_handle_metadata_t, kHandleAllocSize>
      read_handle_metadata;
  ::fidl::IncomingMessage msg = ::fidl::MessageRead(
      zx::unowned_channel(client_end.handle()), read_storage.view(),
      read_handles.data(), read_handle_metadata.data(), kHandleAllocSize,
      ReadOptions{.discardable = true});
  if (msg.status() == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Result::UnexpectedMessage(Unknown());
  }
  if (!msg.ok()) {
    return msg;
  }
  fidl_message_header_t* hdr = msg.header();
  switch (hdr->ordinal) {
    default: {
      return ::fidl::Result::UnexpectedMessage(Unknown());
    }
  }
}

std::optional<::fidl::UnbindInfo> fidl::internal::
    WireEventDispatcher<::test_protocols::MethodWithUnion>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<
    ::test_protocols::MethodWithUnion>::entries_[] = {
    {
        ::test_protocols::kMethodWithUnion_UnionMethod_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::MethodWithUnion::UnionMethod>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::MethodWithUnion::UnionMethod>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::MethodWithUnion>*>(interface)
              ->UnionMethod(primary, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<
    ::test_protocols::MethodWithUnion>::entries_end_ = &entries_[1];

::fidl::DispatchResult fidl::internal::
    WireServerDispatcher<::test_protocols::MethodWithUnion>::TryDispatch(
        ::fidl::WireServer<::test_protocols::MethodWithUnion>* impl,
        ::fidl::IncomingMessage& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(impl, msg, std::move(transport_context),
                                       txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::MethodWithUnion>::
    Dispatch(::fidl::WireServer<::test_protocols::MethodWithUnion>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::WireServer<::test_protocols::MethodWithUnion>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::WireServerDispatcher<
      ::test_protocols::MethodWithUnion>::Dispatch(this, std::move(msg),
                                                   std::move(transport_context),
                                                   txn);
}
#endif  // __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::MethodWithUnion::UnionMethod>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kMethodWithUnion_UnionMethod_Ordinal);
}

#ifdef __Fuchsia__

#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr uint64_t kWithProtocolEnds_ClientEnds_Ordinal =
    5870448041025163330lu;

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsRequestTable;

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsTopResponseTable;

[[maybe_unused]] constexpr uint64_t kWithProtocolEnds_ServerEnds_Ordinal =
    8115535094437022259lu;

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsRequestTable;

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsTopResponseTable;

[[maybe_unused]] constexpr uint64_t
    kWithProtocolEnds_StructContainingEnds_Ordinal = 4076866772260025813lu;

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsRequestTable;

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;
#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithProtocolEnds::ClientEnds>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ClientEnds>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ClientEnds>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetResult(outgoing);
}

::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithProtocolEnds::ClientEnds>* request,
    zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ClientEnds>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ClientEnds>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ClientEnds>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithProtocolEnds::ClientEnds>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithProtocolEnds::ClientEnds>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ClientEnds>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ClientEnds>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ClientEnds>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithProtocolEnds::ServerEnds>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ServerEnds>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ServerEnds>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetResult(outgoing);
}

::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithProtocolEnds::ServerEnds>* request,
    zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ServerEnds>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ServerEnds>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ServerEnds>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithProtocolEnds::ServerEnds>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithProtocolEnds::ServerEnds>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ServerEnds>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ServerEnds>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ServerEnds>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>*
            request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetResult(outgoing);
}

::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>* request,
        zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>*
            request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

void fidl::internal::
    WireWeakAsyncClientImpl<::test_protocols::WithProtocolEnds>::ClientEnds(
        ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in,
        ::fidl::WireClientCallback<
            ::test_protocols::WithProtocolEnds::ClientEnds>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithProtocolEnds::ClientEnds> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(
        ::fidl::WireUnownedResult<
            ::test_protocols::WithProtocolEnds::ClientEnds>& result) override {
      cb_(result);
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithProtocolEnds::ClientEnds>
      _request{std::move(in)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ClientEnds>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

void fidl::internal::
    WireWeakAsyncClientImpl<::test_protocols::WithProtocolEnds>::ClientEnds(
        ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in,
        ::fit::callback<
            void(::fidl::WireResponse<
                 ::test_protocols::WithProtocolEnds::ClientEnds>* response)>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithProtocolEnds::ClientEnds> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(
        ::fidl::WireUnownedResult<
            ::test_protocols::WithProtocolEnds::ClientEnds>& result) override {
      if (result.ok()) {
        ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>*
            response = result.Unwrap();
        cb_(response);
      }
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithProtocolEnds::ClientEnds>
      _request{std::move(in)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ClientEnds>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::
    WireWeakAsyncClientImpl<::test_protocols::WithProtocolEnds>::ServerEnds(
        ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in,
        ::fidl::WireClientCallback<
            ::test_protocols::WithProtocolEnds::ServerEnds>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithProtocolEnds::ServerEnds> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(
        ::fidl::WireUnownedResult<
            ::test_protocols::WithProtocolEnds::ServerEnds>& result) override {
      cb_(result);
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithProtocolEnds::ServerEnds>
      _request{std::move(in)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ServerEnds>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

void fidl::internal::
    WireWeakAsyncClientImpl<::test_protocols::WithProtocolEnds>::ServerEnds(
        ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in,
        ::fit::callback<
            void(::fidl::WireResponse<
                 ::test_protocols::WithProtocolEnds::ServerEnds>* response)>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithProtocolEnds::ServerEnds> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(
        ::fidl::WireUnownedResult<
            ::test_protocols::WithProtocolEnds::ServerEnds>& result) override {
      if (result.ok()) {
        ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>*
            response = result.Unwrap();
        cb_(response);
      }
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithProtocolEnds::ServerEnds>
      _request{std::move(in)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ServerEnds>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithProtocolEnds>::
    StructContainingEnds(
        ::test_protocols::wire::ProtocolEnds&& in,
        ::fidl::WireClientCallback<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithProtocolEnds::StructContainingEnds> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(::fidl::WireUnownedResult<
                  ::test_protocols::WithProtocolEnds::StructContainingEnds>&
                      result) override {
      cb_(result);
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>
      _request{std::move(in)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

void fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithProtocolEnds>::
    StructContainingEnds(
        ::test_protocols::wire::ProtocolEnds&& in,
        ::fit::callback<
            void(::fidl::WireResponse<::test_protocols::WithProtocolEnds::
                                          StructContainingEnds>* response)>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithProtocolEnds::StructContainingEnds> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(::fidl::WireUnownedResult<
                  ::test_protocols::WithProtocolEnds::StructContainingEnds>&
                      result) override {
      if (result.ok()) {
        ::fidl::WireResponse<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>*
            response = result.Unwrap();
        cb_(response);
      }
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>
      _request{std::move(in)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithProtocolEnds>::
    ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in,
               ::fidl::WireResponseContext<
                   ::test_protocols::WithProtocolEnds::ClientEnds>* _context) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithProtocolEnds::ClientEnds>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    _client_base()->SendTwoWay(_failure, _context);
    return;
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithProtocolEnds::ClientEnds>
      _request{std::move(in)};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ClientEnds>>
      _request_message(_allocation->data, _buffer_size, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithProtocolEnds>::
    ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in,
               ::fidl::WireResponseContext<
                   ::test_protocols::WithProtocolEnds::ServerEnds>* _context) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithProtocolEnds::ServerEnds>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    _client_base()->SendTwoWay(_failure, _context);
    return;
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithProtocolEnds::ServerEnds>
      _request{std::move(in)};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ServerEnds>>
      _request_message(_allocation->data, _buffer_size, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithProtocolEnds>::
    StructContainingEnds(
        ::test_protocols::wire::ProtocolEnds&& in,
        ::fidl::WireResponseContext<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>*
            _context) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    _client_base()->SendTwoWay(_failure, _context);
    return;
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>
      _request{std::move(in)};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>>
      _request_message(_allocation->data, _buffer_size, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds>
fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithProtocolEnds>::
    ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithProtocolEnds::ClientEnds>
            _request{std::move(in)};
        return ::fidl::WireResult<
            ::test_protocols::WithProtocolEnds::ClientEnds>(
            ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}

::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds>
fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithProtocolEnds>::
    ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithProtocolEnds::ServerEnds>
            _request{std::move(in)};
        return ::fidl::WireResult<
            ::test_protocols::WithProtocolEnds::ServerEnds>(
            ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}

::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>
fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithProtocolEnds>::
    StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>
            _request{std::move(in)};
        return ::fidl::WireResult<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>(
            ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fidl::Result
fidl::WireSyncEventHandler<::test_protocols::WithProtocolEnds>::HandleOneEvent(
    ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end) {
  zx_status_t status = client_end.channel()->wait_one(
      ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED, ::zx::time::infinite(),
      nullptr);
  if (status != ZX_OK) {
    return ::fidl::Result::TransportError(
        status, ::fidl::internal::kErrorWaitOneFailed);
  }
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  static_assert(kHandleAllocSize <= ZX_CHANNEL_MAX_MSG_HANDLES);
  ::fidl::internal::InlineMessageBuffer<32> read_storage;
  std::array<zx_handle_t, kHandleAllocSize> read_handles;
  // TODO(fxbug.dev/85734) Remove this channel-specific allocation.
  std::array<fidl_channel_handle_metadata_t, kHandleAllocSize>
      read_handle_metadata;
  ::fidl::IncomingMessage msg = ::fidl::MessageRead(
      zx::unowned_channel(client_end.handle()), read_storage.view(),
      read_handles.data(), read_handle_metadata.data(), kHandleAllocSize,
      ReadOptions{.discardable = true});
  if (msg.status() == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Result::UnexpectedMessage(Unknown());
  }
  if (!msg.ok()) {
    return msg;
  }
  fidl_message_header_t* hdr = msg.header();
  switch (hdr->ordinal) {
    default: {
      return ::fidl::Result::UnexpectedMessage(Unknown());
    }
  }
}

std::optional<::fidl::UnbindInfo> fidl::internal::
    WireEventDispatcher<::test_protocols::WithProtocolEnds>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<
    ::test_protocols::WithProtocolEnds>::entries_[] = {
    {
        ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::WithProtocolEnds::ClientEnds>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithProtocolEnds::ClientEnds>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::WithProtocolEnds>*>(
              interface)
              ->ClientEnds(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::WithProtocolEnds::ServerEnds>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithProtocolEnds::ServerEnds>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::WithProtocolEnds>*>(
              interface)
              ->ServerEnds(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::WithProtocolEnds::StructContainingEnds>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::WithProtocolEnds>*>(
              interface)
              ->StructContainingEnds(primary, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<
    ::test_protocols::WithProtocolEnds>::entries_end_ = &entries_[3];

::fidl::DispatchResult fidl::internal::
    WireServerDispatcher<::test_protocols::WithProtocolEnds>::TryDispatch(
        ::fidl::WireServer<::test_protocols::WithProtocolEnds>* impl,
        ::fidl::IncomingMessage& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(impl, msg, std::move(transport_context),
                                       txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::WithProtocolEnds>::
    Dispatch(::fidl::WireServer<::test_protocols::WithProtocolEnds>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::WireServer<::test_protocols::WithProtocolEnds>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::WithProtocolEnds>::
      Dispatch(this, std::move(msg), std::move(transport_context), txn);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
::fidl::Result fidl::internal::
    WireCompleterImpl<::test_protocols::WithProtocolEnds::ClientEnds>::Reply(
        ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ClientEnds>
      _response{std::move(out)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithProtocolEnds::ClientEnds>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithProtocolEnds::ClientEnds>::
    Reply(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ClientEnds>
      _response{std::move(out)};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithProtocolEnds::ClientEnds>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithProtocolEnds::ClientEnds>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
::fidl::Result fidl::internal::
    WireCompleterImpl<::test_protocols::WithProtocolEnds::ServerEnds>::Reply(
        ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ServerEnds>
      _response{std::move(out)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithProtocolEnds::ServerEnds>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithProtocolEnds::ServerEnds>::
    Reply(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ServerEnds>
      _response{std::move(out)};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithProtocolEnds::ServerEnds>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithProtocolEnds::ServerEnds>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>::
    Reply(::test_protocols::wire::ProtocolEnds&& out) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>
      _response{std::move(out)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>::
    Reply(::test_protocols::wire::ProtocolEnds&& out) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>
      _response{std::move(out)};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::ClientEnds>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal);
}

void ::fidl::WireRequest<
    ::test_protocols::WithProtocolEnds::ClientEnds>::_CloseHandles() {
  in.reset();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::ClientEnds>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal);
}

void ::fidl::WireResponse<
    ::test_protocols::WithProtocolEnds::ClientEnds>::_CloseHandles() {
  out.reset();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::ServerEnds>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal);
}

void ::fidl::WireRequest<
    ::test_protocols::WithProtocolEnds::ServerEnds>::_CloseHandles() {
  in.reset();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::ServerEnds>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal);
}

void ::fidl::WireResponse<
    ::test_protocols::WithProtocolEnds::ServerEnds>::_CloseHandles() {
  out.reset();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>::_InitHeader() {
  fidl_init_txn_header(
      &header, 0,
      ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal);
}

void ::fidl::WireRequest<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>::_CloseHandles() {
  in._CloseHandles();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>::_InitHeader() {
  fidl_init_txn_header(
      &header, 0,
      ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal);
}

void ::fidl::WireResponse<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>::_CloseHandles() {
  out._CloseHandles();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr uint64_t kManyParameters_Fifteen_Ordinal =
    6423043252952467815lu;

extern "C" const fidl_type_t test_protocols_ManyParametersFifteenRequestTable;
#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::ManyParameters::Fifteen>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ManyParameters::Fifteen>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ManyParameters::Fifteen>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client.handle());
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::ManyParameters::Fifteen>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::ManyParameters::Fifteen>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::ManyParameters::Fifteen>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  uint32_t request_byte_capacity = buffer_size;
  uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ManyParameters::Fifteen>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client_end.handle());
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

::fidl::Result fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::ManyParameters>::Fifteen(bool p1, bool p2, bool p3,
                                               bool p4, bool p5, bool p6,
                                               bool p7, bool p8, bool p9,
                                               bool p10, bool p11, bool p12,
                                               bool p13, bool p14, bool p15) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ManyParameters::Fifteen>
      _request_object{p1, p2,  p3,  p4,  p5,  p6,  p7, p8,
                      p9, p10, p11, p12, p13, p14, p15};
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ManyParameters::Fifteen>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{},
                       &_request_object);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::Result fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::ManyParameters>::Fifteen(bool p1, bool p2, bool p3,
                                               bool p4, bool p5, bool p6,
                                               bool p7, bool p8, bool p9,
                                               bool p10, bool p11, bool p12,
                                               bool p13, bool p14, bool p15) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::ManyParameters::Fifteen>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ManyParameters::Fifteen>
      _request{p1, p2,  p3,  p4,  p5,  p6,  p7, p8,
               p9, p10, p11, p12, p13, p14, p15};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ManyParameters::Fifteen>>
      _request_message(_allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fidl::Result
fidl::WireSyncEventHandler<::test_protocols::ManyParameters>::HandleOneEvent(
    ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client_end) {
  zx_status_t status = client_end.channel()->wait_one(
      ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED, ::zx::time::infinite(),
      nullptr);
  if (status != ZX_OK) {
    return ::fidl::Result::TransportError(
        status, ::fidl::internal::kErrorWaitOneFailed);
  }
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  static_assert(kHandleAllocSize <= ZX_CHANNEL_MAX_MSG_HANDLES);
  ::fidl::internal::InlineMessageBuffer<16> read_storage;
  std::array<zx_handle_t, kHandleAllocSize> read_handles;
  // TODO(fxbug.dev/85734) Remove this channel-specific allocation.
  std::array<fidl_channel_handle_metadata_t, kHandleAllocSize>
      read_handle_metadata;
  ::fidl::IncomingMessage msg = ::fidl::MessageRead(
      zx::unowned_channel(client_end.handle()), read_storage.view(),
      read_handles.data(), read_handle_metadata.data(), kHandleAllocSize,
      ReadOptions{.discardable = true});
  if (msg.status() == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Result::UnexpectedMessage(Unknown());
  }
  if (!msg.ok()) {
    return msg;
  }
  fidl_message_header_t* hdr = msg.header();
  switch (hdr->ordinal) {
    default: {
      return ::fidl::Result::UnexpectedMessage(Unknown());
    }
  }
}

std::optional<::fidl::UnbindInfo> fidl::internal::
    WireEventDispatcher<::test_protocols::ManyParameters>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<
    ::test_protocols::ManyParameters>::entries_[] = {
    {
        ::test_protocols::kManyParameters_Fifteen_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::ManyParameters::Fifteen>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::ManyParameters::Fifteen>::Sync completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::ManyParameters>*>(interface)
              ->Fifteen(primary, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<
    ::test_protocols::ManyParameters>::entries_end_ = &entries_[1];

::fidl::DispatchResult fidl::internal::
    WireServerDispatcher<::test_protocols::ManyParameters>::TryDispatch(
        ::fidl::WireServer<::test_protocols::ManyParameters>* impl,
        ::fidl::IncomingMessage& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(impl, msg, std::move(transport_context),
                                       txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::ManyParameters>::
    Dispatch(::fidl::WireServer<::test_protocols::ManyParameters>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::WireServer<::test_protocols::ManyParameters>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::WireServerDispatcher<
      ::test_protocols::ManyParameters>::Dispatch(this, std::move(msg),
                                                  std::move(transport_context),
                                                  txn);
}
#endif  // __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::ManyParameters::Fifteen>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kManyParameters_Fifteen_Ordinal);
}

#ifdef __Fuchsia__

#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr uint64_t kWithErrorSyntax_ResponseAsStruct_Ordinal =
    268248568430741139lu;

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;

[[maybe_unused]] constexpr uint64_t kWithErrorSyntax_ErrorAsPrimitive_Ordinal =
    6930994461233198567lu;

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;

[[maybe_unused]] constexpr uint64_t kWithErrorSyntax_ErrorAsEnum_Ordinal =
    5491891352371277635lu;

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;

[[maybe_unused]] constexpr uint64_t kWithErrorSyntax_HandleInResult_Ordinal =
    1371676333068455103lu;

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;
#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ResponseAsStruct>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetResult(outgoing);
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ResponseAsStruct>* request,
        zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ResponseAsStruct>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetResult(outgoing);
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* request,
        zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithErrorSyntax::ErrorAsEnum>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetResult(outgoing);
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithErrorSyntax::ErrorAsEnum>* request,
    zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ErrorAsEnum>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::HandleInResult>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::HandleInResult>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::HandleInResult>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetResult(outgoing);
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::HandleInResult>* request,
        zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::HandleInResult>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::HandleInResult>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::HandleInResult>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::HandleInResult>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithErrorSyntax::HandleInResult>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::HandleInResult>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::HandleInResult>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::HandleInResult>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

void fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithErrorSyntax>::
    ResponseAsStruct(::fidl::WireClientCallback<
                     ::test_protocols::WithErrorSyntax::ResponseAsStruct>
                         _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithErrorSyntax::ResponseAsStruct> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(::fidl::WireUnownedResult<
                  ::test_protocols::WithErrorSyntax::ResponseAsStruct>& result)
        override {
      cb_(result);
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>
      _request{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

void fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithErrorSyntax>::
    ResponseAsStruct(
        ::fit::callback<void(
            ::fidl::WireResponse<
                ::test_protocols::WithErrorSyntax::ResponseAsStruct>* response)>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithErrorSyntax::ResponseAsStruct> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(::fidl::WireUnownedResult<
                  ::test_protocols::WithErrorSyntax::ResponseAsStruct>& result)
        override {
      if (result.ok()) {
        ::fidl::WireResponse<
            ::test_protocols::WithErrorSyntax::ResponseAsStruct>* response =
            result.Unwrap();
        cb_(response);
      }
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>
      _request{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithErrorSyntax>::
    ErrorAsPrimitive(::fidl::WireClientCallback<
                     ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
                         _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(::fidl::WireUnownedResult<
                  ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>& result)
        override {
      cb_(result);
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
      _request{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

void fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithErrorSyntax>::
    ErrorAsPrimitive(
        ::fit::callback<void(
            ::fidl::WireResponse<
                ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* response)>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(::fidl::WireUnownedResult<
                  ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>& result)
        override {
      if (result.ok()) {
        ::fidl::WireResponse<
            ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* response =
            result.Unwrap();
        cb_(response);
      }
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
      _request{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::
    WireWeakAsyncClientImpl<::test_protocols::WithErrorSyntax>::ErrorAsEnum(
        ::fidl::WireClientCallback<
            ::test_protocols::WithErrorSyntax::ErrorAsEnum>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithErrorSyntax::ErrorAsEnum> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(
        ::fidl::WireUnownedResult<
            ::test_protocols::WithErrorSyntax::ErrorAsEnum>& result) override {
      cb_(result);
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>
      _request{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

void fidl::internal::
    WireWeakAsyncClientImpl<::test_protocols::WithErrorSyntax>::ErrorAsEnum(
        ::fit::callback<
            void(::fidl::WireResponse<
                 ::test_protocols::WithErrorSyntax::ErrorAsEnum>* response)>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithErrorSyntax::ErrorAsEnum> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(
        ::fidl::WireUnownedResult<
            ::test_protocols::WithErrorSyntax::ErrorAsEnum>& result) override {
      if (result.ok()) {
        ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>*
            response = result.Unwrap();
        cb_(response);
      }
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>
      _request{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::
    WireWeakAsyncClientImpl<::test_protocols::WithErrorSyntax>::HandleInResult(
        ::fidl::WireClientCallback<
            ::test_protocols::WithErrorSyntax::HandleInResult>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithErrorSyntax::HandleInResult> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(::fidl::WireUnownedResult<
                  ::test_protocols::WithErrorSyntax::HandleInResult>& result)
        override {
      cb_(result);
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::HandleInResult>
      _request{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::HandleInResult>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

void fidl::internal::
    WireWeakAsyncClientImpl<::test_protocols::WithErrorSyntax>::HandleInResult(
        ::fit::callback<
            void(::fidl::WireResponse<
                 ::test_protocols::WithErrorSyntax::HandleInResult>* response)>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::WithErrorSyntax::HandleInResult> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(::fidl::WireUnownedResult<
                  ::test_protocols::WithErrorSyntax::HandleInResult>& result)
        override {
      if (result.ok()) {
        ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>*
            response = result.Unwrap();
        cb_(response);
      }
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::HandleInResult>
      _request{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::HandleInResult>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithErrorSyntax>::
    ResponseAsStruct(
        ::fidl::WireResponseContext<
            ::test_protocols::WithErrorSyntax::ResponseAsStruct>* _context) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    _client_base()->SendTwoWay(_failure, _context);
    return;
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>
      _request{};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>>
      _request_message(_allocation->data, _buffer_size, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithErrorSyntax>::
    ErrorAsPrimitive(
        ::fidl::WireResponseContext<
            ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* _context) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    _client_base()->SendTwoWay(_failure, _context);
    return;
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
      _request{};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
      _request_message(_allocation->data, _buffer_size, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithErrorSyntax>::
    ErrorAsEnum(::fidl::WireResponseContext<
                ::test_protocols::WithErrorSyntax::ErrorAsEnum>* _context) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    _client_base()->SendTwoWay(_failure, _context);
    return;
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>
      _request{};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>>
      _request_message(_allocation->data, _buffer_size, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithErrorSyntax>::
    HandleInResult(
        ::fidl::WireResponseContext<
            ::test_protocols::WithErrorSyntax::HandleInResult>* _context) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithErrorSyntax::HandleInResult>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    _client_base()->SendTwoWay(_failure, _context);
    return;
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::HandleInResult>
      _request{};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::HandleInResult>>
      _request_message(_allocation->data, _buffer_size, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::WithErrorSyntax>::ResponseAsStruct() {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ResponseAsStruct>
            _request{};
        return ::fidl::WireResult<
            ::test_protocols::WithErrorSyntax::ResponseAsStruct>(
            ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::WithErrorSyntax>::ErrorAsPrimitive() {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
            _request{};
        return ::fidl::WireResult<
            ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(
            ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::WithErrorSyntax>::ErrorAsEnum() {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ErrorAsEnum>
            _request{};
        return ::fidl::WireResult<
            ::test_protocols::WithErrorSyntax::ErrorAsEnum>(
            ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::WithErrorSyntax>::HandleInResult() {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::HandleInResult>
            _request{};
        return ::fidl::WireResult<
            ::test_protocols::WithErrorSyntax::HandleInResult>(
            ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fidl::Result
fidl::WireSyncEventHandler<::test_protocols::WithErrorSyntax>::HandleOneEvent(
    ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end) {
  zx_status_t status = client_end.channel()->wait_one(
      ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED, ::zx::time::infinite(),
      nullptr);
  if (status != ZX_OK) {
    return ::fidl::Result::TransportError(
        status, ::fidl::internal::kErrorWaitOneFailed);
  }
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  static_assert(kHandleAllocSize <= ZX_CHANNEL_MAX_MSG_HANDLES);
  ::fidl::internal::InlineMessageBuffer<64> read_storage;
  std::array<zx_handle_t, kHandleAllocSize> read_handles;
  // TODO(fxbug.dev/85734) Remove this channel-specific allocation.
  std::array<fidl_channel_handle_metadata_t, kHandleAllocSize>
      read_handle_metadata;
  ::fidl::IncomingMessage msg = ::fidl::MessageRead(
      zx::unowned_channel(client_end.handle()), read_storage.view(),
      read_handles.data(), read_handle_metadata.data(), kHandleAllocSize,
      ReadOptions{.discardable = true});
  if (msg.status() == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Result::UnexpectedMessage(Unknown());
  }
  if (!msg.ok()) {
    return msg;
  }
  fidl_message_header_t* hdr = msg.header();
  switch (hdr->ordinal) {
    default: {
      return ::fidl::Result::UnexpectedMessage(Unknown());
    }
  }
}

std::optional<::fidl::UnbindInfo> fidl::internal::
    WireEventDispatcher<::test_protocols::WithErrorSyntax>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<
    ::test_protocols::WithErrorSyntax>::entries_[] = {
    {
        ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::WireRequest<
              ::test_protocols::WithErrorSyntax::ResponseAsStruct>
              empty_request;
          auto* primary = &empty_request;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithErrorSyntax::ResponseAsStruct>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::WithErrorSyntax>*>(interface)
              ->ResponseAsStruct(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::WireRequest<
              ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
              empty_request;
          auto* primary = &empty_request;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::WithErrorSyntax>*>(interface)
              ->ErrorAsPrimitive(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::WireRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>
              empty_request;
          auto* primary = &empty_request;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithErrorSyntax::ErrorAsEnum>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::WithErrorSyntax>*>(interface)
              ->ErrorAsEnum(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::WireRequest<::test_protocols::WithErrorSyntax::HandleInResult>
              empty_request;
          auto* primary = &empty_request;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithErrorSyntax::HandleInResult>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::WithErrorSyntax>*>(interface)
              ->HandleInResult(primary, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<
    ::test_protocols::WithErrorSyntax>::entries_end_ = &entries_[4];

::fidl::DispatchResult fidl::internal::
    WireServerDispatcher<::test_protocols::WithErrorSyntax>::TryDispatch(
        ::fidl::WireServer<::test_protocols::WithErrorSyntax>* impl,
        ::fidl::IncomingMessage& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(impl, msg, std::move(transport_context),
                                       txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::WithErrorSyntax>::
    Dispatch(::fidl::WireServer<::test_protocols::WithErrorSyntax>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::WireServer<::test_protocols::WithErrorSyntax>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::WireServerDispatcher<
      ::test_protocols::WithErrorSyntax>::Dispatch(this, std::move(msg),
                                                   std::move(transport_context),
                                                   txn);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    Reply(
        ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>
      _response{result};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    ReplySuccess(int64_t a, int64_t b, int64_t c) {
  ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse _response;
  _response.a = std::move(a);
  _response.b = std::move(b);
  _response.c = std::move(c);
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::
          WithResponse(
              ::fidl::ObjectView<::test_protocols::wire::
                                     WithErrorSyntaxResponseAsStructResponse>::
                  FromExternal(&_response)));
}

::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    ReplyError(uint32_t error) {
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::WithErr(
          std::move(error)));
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    Reply(
        ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>
      _response{result};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    ReplySuccess(int64_t a, int64_t b, int64_t c) {
  ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse response;
  response.a = std::move(a);
  response.b = std::move(b);
  response.c = std::move(c);
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::
          WithResponse(
              ::fidl::ObjectView<::test_protocols::wire::
                                     WithErrorSyntaxResponseAsStructResponse>::
                  FromExternal(&response)));
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    ReplyError(uint32_t error) {
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::WithErr(
          std::move(error)));
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::
    Reply(
        ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
      _response{result};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::ReplySuccess() {
  ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse _response;
  return Reply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::
                   WithResponse(std::move(_response)));
}

::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::
    ReplyError(uint32_t error) {
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::WithErr(
          std::move(error)));
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::
    Reply(
        ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
      _response{result};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::ReplySuccess() {
  ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse response;
  return Reply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::
                   WithResponse(std::move(response)));
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::
    ReplyError(uint32_t error) {
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::WithErr(
          std::move(error)));
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
::fidl::Result fidl::internal::
    WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum>::Reply(
        ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>
      _response{result};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>::ReplySuccess() {
  ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse _response;
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithResponse(
          std::move(_response)));
}

::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>::
    ReplyError(::test_protocols::wire::ErrorEnum error) {
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithErr(
          std::move(error)));
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>::
    Reply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>
      _response{result};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>::ReplySuccess() {
  ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse response;
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithResponse(
          std::move(response)));
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>::
    ReplyError(::test_protocols::wire::ErrorEnum error) {
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithErr(
          std::move(error)));
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
::fidl::Result fidl::internal::
    WireCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult>::Reply(
        ::test_protocols::wire::WithErrorSyntaxHandleInResultResult result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::HandleInResult>
      _response{std::move(result)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::HandleInResult>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::HandleInResult>::
    ReplySuccess(::zx::handle&& h) {
  ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse _response;
  _response.h = std::move(h);
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithResponse(
          std::move(_response)));
}

::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::HandleInResult>::ReplyError(uint32_t
                                                                       error) {
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithErr(
          std::move(error)));
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::HandleInResult>::
    Reply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::HandleInResult>
      _response{std::move(result)};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithErrorSyntax::HandleInResult>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::HandleInResult>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::HandleInResult>::
    ReplySuccess(::zx::handle&& h) {
  ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse response;
  response.h = std::move(h);
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithResponse(
          std::move(response)));
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::HandleInResult>::ReplyError(uint32_t
                                                                       error) {
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithErr(
          std::move(error)));
}
#endif  // __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>::_InitHeader() {
  fidl_init_txn_header(
      &header, 0, ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal);
}

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>::_InitHeader() {
  fidl_init_txn_header(
      &header, 0, ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::_InitHeader() {
  fidl_init_txn_header(
      &header, 0, ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal);
}

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::_InitHeader() {
  fidl_init_txn_header(
      &header, 0, ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal);
}

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::HandleInResult>::_InitHeader() {
  fidl_init_txn_header(
      &header, 0, ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal);
}

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::HandleInResult>::_InitHeader() {
  fidl_init_txn_header(
      &header, 0, ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal);
}

void ::fidl::WireResponse<
    ::test_protocols::WithErrorSyntax::HandleInResult>::_CloseHandles() {
  result._CloseHandles();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr uint64_t kDiscoverableProtocol_Method_Ordinal =
    3455873048082739435lu;
#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::DiscoverableProtocol::Method>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::DiscoverableProtocol::Method>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::DiscoverableProtocol::Method>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client.handle());
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

::fidl::Result fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::DiscoverableProtocol>::Method() {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::DiscoverableProtocol::Method>
      _request_object{};
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::DiscoverableProtocol::Method>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{},
                       &_request_object);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::Result fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::DiscoverableProtocol>::Method() {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::DiscoverableProtocol::Method>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::DiscoverableProtocol::Method>
      _request{};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::DiscoverableProtocol::Method>>
      _request_message(_allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fidl::Result
fidl::WireSyncEventHandler<::test_protocols::DiscoverableProtocol>::
    HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol>
            client_end) {
  zx_status_t status = client_end.channel()->wait_one(
      ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED, ::zx::time::infinite(),
      nullptr);
  if (status != ZX_OK) {
    return ::fidl::Result::TransportError(
        status, ::fidl::internal::kErrorWaitOneFailed);
  }
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  static_assert(kHandleAllocSize <= ZX_CHANNEL_MAX_MSG_HANDLES);
  ::fidl::internal::InlineMessageBuffer<16> read_storage;
  std::array<zx_handle_t, kHandleAllocSize> read_handles;
  // TODO(fxbug.dev/85734) Remove this channel-specific allocation.
  std::array<fidl_channel_handle_metadata_t, kHandleAllocSize>
      read_handle_metadata;
  ::fidl::IncomingMessage msg = ::fidl::MessageRead(
      zx::unowned_channel(client_end.handle()), read_storage.view(),
      read_handles.data(), read_handle_metadata.data(), kHandleAllocSize,
      ReadOptions{.discardable = true});
  if (msg.status() == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Result::UnexpectedMessage(Unknown());
  }
  if (!msg.ok()) {
    return msg;
  }
  fidl_message_header_t* hdr = msg.header();
  switch (hdr->ordinal) {
    default: {
      return ::fidl::Result::UnexpectedMessage(Unknown());
    }
  }
}

std::optional<::fidl::UnbindInfo> fidl::internal::
    WireEventDispatcher<::test_protocols::DiscoverableProtocol>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<
    ::test_protocols::DiscoverableProtocol>::entries_[] = {
    {
        ::test_protocols::kDiscoverableProtocol_Method_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::WireRequest<::test_protocols::DiscoverableProtocol::Method>
              empty_request;
          auto* primary = &empty_request;
          ::fidl::internal::WireCompleter<
              ::test_protocols::DiscoverableProtocol::Method>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::DiscoverableProtocol>*>(
              interface)
              ->Method(primary, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<
    ::test_protocols::DiscoverableProtocol>::entries_end_ = &entries_[1];

::fidl::DispatchResult fidl::internal::
    WireServerDispatcher<::test_protocols::DiscoverableProtocol>::TryDispatch(
        ::fidl::WireServer<::test_protocols::DiscoverableProtocol>* impl,
        ::fidl::IncomingMessage& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(impl, msg, std::move(transport_context),
                                       txn, entries_, entries_end_);
}

void fidl::internal::
    WireServerDispatcher<::test_protocols::DiscoverableProtocol>::Dispatch(
        ::fidl::WireServer<::test_protocols::DiscoverableProtocol>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::WireServer<::test_protocols::DiscoverableProtocol>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::WireServerDispatcher<
      ::test_protocols::DiscoverableProtocol>::Dispatch(this, std::move(msg),
                                                        std::move(
                                                            transport_context),
                                                        txn);
}
#endif  // __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::DiscoverableProtocol::Method>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kDiscoverableProtocol_Method_Ordinal);
}

#ifdef __Fuchsia__

#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr uint64_t kChannelProtocol_MethodA_Ordinal =
    3155008840945527714lu;

extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodARequestTable;

[[maybe_unused]] constexpr uint64_t kChannelProtocol_EventA_Ordinal =
    2220452875311597006lu;

extern "C" const fidl_type_t test_protocols_ChannelProtocolEventARequestTable;

[[maybe_unused]] constexpr uint64_t kChannelProtocol_MethodB_Ordinal =
    8903004957800778182lu;

extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBRequestTable;

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodBTopResponseTable;

[[maybe_unused]] constexpr uint64_t kChannelProtocol_TakeHandle_Ordinal =
    591935489944717925lu;

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolTakeHandleRequestTable;

[[maybe_unused]] constexpr uint64_t kChannelProtocol_MutateSocket_Ordinal =
    7411742788430590287lu;

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketRequestTable;

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketTopResponseTable;
#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::ChannelProtocol::MethodA>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::MethodA>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MethodA>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client.handle());
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodA>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::ChannelProtocol::MethodA>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::ChannelProtocol::MethodA>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  uint32_t request_byte_capacity = buffer_size;
  uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MethodA>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client_end.handle());
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::MethodB>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MethodB>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MethodB>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetResult(outgoing);
}

::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::MethodB>* request,
    zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MethodB>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MethodB>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodB>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::ChannelProtocol::MethodB>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::ChannelProtocol::MethodB>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity =
      ::fidl::MaxSizeInChannel<::fidl::internal::TransactionalRequest<
                                   ::test_protocols::ChannelProtocol::MethodB>,
                               ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MethodB>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MethodB>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::TakeHandle>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::TakeHandle>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::TakeHandle>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetResult(outgoing);
}

::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::TakeHandle>* request,
    zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::TakeHandle>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::TakeHandle>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::TakeHandle>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::ChannelProtocol::TakeHandle>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::ChannelProtocol::TakeHandle>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::TakeHandle>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::TakeHandle>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::TakeHandle>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::MutateSocket>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MutateSocket>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MutateSocket>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetResult(outgoing);
}

::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::MutateSocket>* request,
    zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MutateSocket>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MutateSocket>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetResult(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MutateSocket>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::ChannelProtocol::MutateSocket>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::ChannelProtocol::MutateSocket>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Result::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MutateSocket>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MutateSocket>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MutateSocket>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Result::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

::fidl::Result fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::ChannelProtocol>::MethodA(int64_t a, int64_t b) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ChannelProtocol::MethodA>
      _request_object{a, b};
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MethodA>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{},
                       &_request_object);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
void fidl::internal::
    WireWeakAsyncClientImpl<::test_protocols::ChannelProtocol>::MethodB(
        int64_t a, int64_t b,
        ::fidl::WireClientCallback<::test_protocols::ChannelProtocol::MethodB>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::ChannelProtocol::MethodB> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(
        ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodB>&
            result) override {
      cb_(result);
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ChannelProtocol::MethodB>
      _request{a, b};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MethodB>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

void fidl::internal::
    WireWeakAsyncClientImpl<::test_protocols::ChannelProtocol>::MethodB(
        int64_t a, int64_t b,
        ::fit::callback<void(
            ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>*
                response)>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::ChannelProtocol::MethodB> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(
        ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodB>&
            result) override {
      if (result.ok()) {
        ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>*
            response = result.Unwrap();
        cb_(response);
      }
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ChannelProtocol::MethodB>
      _request{a, b};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MethodB>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::
    WireWeakAsyncClientImpl<::test_protocols::ChannelProtocol>::TakeHandle(
        ::zx::handle&& h, ::fidl::WireClientCallback<
                              ::test_protocols::ChannelProtocol::TakeHandle>
                              _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::ChannelProtocol::TakeHandle> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(
        ::fidl::WireUnownedResult<
            ::test_protocols::ChannelProtocol::TakeHandle>& result) override {
      cb_(result);
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ChannelProtocol::TakeHandle>
      _request{std::move(h)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::TakeHandle>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

void fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::ChannelProtocol>::TakeHandle(::zx::handle&& h,
                                                   ::fit::callback<void()>
                                                       _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::ChannelProtocol::TakeHandle> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(
        ::fidl::WireUnownedResult<
            ::test_protocols::ChannelProtocol::TakeHandle>& result) override {
      if (result.ok()) {
        cb_();
      }
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ChannelProtocol::TakeHandle>
      _request{std::move(h)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::TakeHandle>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::
    WireWeakAsyncClientImpl<::test_protocols::ChannelProtocol>::MutateSocket(
        ::zx::socket&& a, ::fidl::WireClientCallback<
                              ::test_protocols::ChannelProtocol::MutateSocket>
                              _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::ChannelProtocol::MutateSocket> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(
        ::fidl::WireUnownedResult<
            ::test_protocols::ChannelProtocol::MutateSocket>& result) override {
      cb_(result);
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ChannelProtocol::MutateSocket>
      _request{std::move(a)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MutateSocket>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

void fidl::internal::
    WireWeakAsyncClientImpl<::test_protocols::ChannelProtocol>::MutateSocket(
        ::zx::socket&& a,
        ::fit::callback<
            void(::fidl::WireResponse<
                 ::test_protocols::ChannelProtocol::MutateSocket>* response)>
            _cb) {
  using Callback = decltype(_cb);
  class ResponseContext final
      : public ::fidl::WireResponseContext<
            ::test_protocols::ChannelProtocol::MutateSocket> {
   public:
    ResponseContext(Callback cb) : cb_(std::move(cb)) {}

    void OnResult(
        ::fidl::WireUnownedResult<
            ::test_protocols::ChannelProtocol::MutateSocket>& result) override {
      if (result.ok()) {
        ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>*
            response = result.Unwrap();
        cb_(response);
      }
      delete this;
    }

   private:
    Callback cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ChannelProtocol::MutateSocket>
      _request{std::move(a)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MutateSocket>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{}, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
::fidl::Result fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::ChannelProtocol>::MethodA(int64_t a, int64_t b) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::ChannelProtocol::MethodA>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ChannelProtocol::MethodA>
      _request{a, b};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MethodA>>
      _request_message(_allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
void fidl::internal::
    WireWeakAsyncBufferClientImpl<::test_protocols::ChannelProtocol>::MethodB(
        int64_t a, int64_t b,
        ::fidl::WireResponseContext<::test_protocols::ChannelProtocol::MethodB>*
            _context) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::ChannelProtocol::MethodB>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    _client_base()->SendTwoWay(_failure, _context);
    return;
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ChannelProtocol::MethodB>
      _request{a, b};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MethodB>>
      _request_message(_allocation->data, _buffer_size, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::ChannelProtocol>::
    TakeHandle(::zx::handle&& h,
               ::fidl::WireResponseContext<
                   ::test_protocols::ChannelProtocol::TakeHandle>* _context) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::ChannelProtocol::TakeHandle>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    _client_base()->SendTwoWay(_failure, _context);
    return;
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ChannelProtocol::TakeHandle>
      _request{std::move(h)};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::TakeHandle>>
      _request_message(_allocation->data, _buffer_size, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}
void fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::ChannelProtocol>::
    MutateSocket(
        ::zx::socket&& a,
        ::fidl::WireResponseContext<
            ::test_protocols::ChannelProtocol::MutateSocket>* _context) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::ChannelProtocol::MutateSocket>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    _client_base()->SendTwoWay(_failure, _context);
    return;
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ChannelProtocol::MutateSocket>
      _request{std::move(a)};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MutateSocket>>
      _request_message(_allocation->data, _buffer_size, &_request);
  _client_base()->SendTwoWay(_request_message.GetOutgoingMessage(), _context);
}

::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::ChannelProtocol>::MethodB(int64_t a, int64_t b) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::ChannelProtocol::MethodB>
            _request{a, b};
        return ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>(
            ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}

::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::ChannelProtocol>::TakeHandle(::zx::handle&& h) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::ChannelProtocol::TakeHandle>
            _request{std::move(h)};
        return ::fidl::WireResult<
            ::test_protocols::ChannelProtocol::TakeHandle>(
            ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}

::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::ChannelProtocol>::MutateSocket(::zx::socket&& a) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::ChannelProtocol::MutateSocket>
            _request{std::move(a)};
        return ::fidl::WireResult<
            ::test_protocols::ChannelProtocol::MutateSocket>(
            ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fidl::Result
fidl::WireSyncEventHandler<::test_protocols::ChannelProtocol>::HandleOneEvent(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end) {
  zx_status_t status = client_end.channel()->wait_one(
      ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED, ::zx::time::infinite(),
      nullptr);
  if (status != ZX_OK) {
    return ::fidl::Result::TransportError(
        status, ::fidl::internal::kErrorWaitOneFailed);
  }
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
            ::test_protocols::ChannelProtocol::EventA>>::kMaxNumHandles >= x) {
      x = ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
          ::test_protocols::ChannelProtocol::EventA>>::kMaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  static_assert(kHandleAllocSize <= ZX_CHANNEL_MAX_MSG_HANDLES);
  ::fidl::internal::InlineMessageBuffer<32> read_storage;
  std::array<zx_handle_t, kHandleAllocSize> read_handles;
  // TODO(fxbug.dev/85734) Remove this channel-specific allocation.
  std::array<fidl_channel_handle_metadata_t, kHandleAllocSize>
      read_handle_metadata;
  ::fidl::IncomingMessage msg = ::fidl::MessageRead(
      zx::unowned_channel(client_end.handle()), read_storage.view(),
      read_handles.data(), read_handle_metadata.data(), kHandleAllocSize,
      ReadOptions{.discardable = true});
  if (msg.status() == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Result::UnexpectedMessage(Unknown());
  }
  if (!msg.ok()) {
    return msg;
  }
  fidl_message_header_t* hdr = msg.header();
  switch (hdr->ordinal) {
    case ::test_protocols::kChannelProtocol_EventA_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::ChannelProtocol::EventA>>
          decoded{::std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::Result(decoded);
      }
      auto* primary = &decoded.PrimaryObject()->body;
      EventA(primary);
      return ::fidl::Result::Ok();
    }
    default: {
      return ::fidl::Result::UnexpectedMessage(Unknown());
    }
  }
}

std::optional<::fidl::UnbindInfo> fidl::internal::
    WireEventDispatcher<::test_protocols::ChannelProtocol>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kChannelProtocol_EventA_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::ChannelProtocol::EventA>>
          decoded{std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::UnbindInfo{decoded};
      }
      if (event_handler()) {
        auto* primary = &decoded.PrimaryObject()->body;
        event_handler()->EventA(primary);
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<
    ::test_protocols::ChannelProtocol>::entries_[] = {
    {
        ::test_protocols::kChannelProtocol_MethodA_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::ChannelProtocol::MethodA>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::ChannelProtocol::MethodA>::Sync completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::ChannelProtocol>*>(interface)
              ->MethodA(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kChannelProtocol_MethodB_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::ChannelProtocol::MethodB>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::ChannelProtocol::MethodB>::Sync completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::ChannelProtocol>*>(interface)
              ->MethodB(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kChannelProtocol_TakeHandle_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::ChannelProtocol::TakeHandle>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::ChannelProtocol::TakeHandle>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::ChannelProtocol>*>(interface)
              ->TakeHandle(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kChannelProtocol_MutateSocket_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::ChannelProtocol::MutateSocket>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::ChannelProtocol::MutateSocket>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::ChannelProtocol>*>(interface)
              ->MutateSocket(primary, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<
    ::test_protocols::ChannelProtocol>::entries_end_ = &entries_[4];

::fidl::DispatchResult fidl::internal::
    WireServerDispatcher<::test_protocols::ChannelProtocol>::TryDispatch(
        ::fidl::WireServer<::test_protocols::ChannelProtocol>* impl,
        ::fidl::IncomingMessage& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(impl, msg, std::move(transport_context),
                                       txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::ChannelProtocol>::
    Dispatch(::fidl::WireServer<::test_protocols::ChannelProtocol>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::WireServer<::test_protocols::ChannelProtocol>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::WireServerDispatcher<
      ::test_protocols::ChannelProtocol>::Dispatch(this, std::move(msg),
                                                   std::move(transport_context),
                                                   txn);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::ChannelProtocol::MethodB>::Reply(int64_t result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MethodB>
      _response{result};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::ChannelProtocol::MethodB>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::ChannelProtocol::MethodB>::Reply(int64_t result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MethodB>
      _response{result};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::ChannelProtocol::MethodB>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::ChannelProtocol::MethodB>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::ChannelProtocol::TakeHandle>::Reply() {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::TakeHandle>
      _response{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::ChannelProtocol::TakeHandle>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::ChannelProtocol::TakeHandle>::Reply() {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::TakeHandle>
      _response{};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::ChannelProtocol::TakeHandle>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::ChannelProtocol::TakeHandle>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
::fidl::Result fidl::internal::WireCompleterImpl<
    ::test_protocols::ChannelProtocol::MutateSocket>::Reply(::zx::socket&& b) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MutateSocket>
      _response{std::move(b)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::ChannelProtocol::MutateSocket>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

::fidl::Result fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::ChannelProtocol::MutateSocket>::Reply(::zx::socket&& b) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MutateSocket>
      _response{std::move(b)};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::ChannelProtocol::MutateSocket>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::ChannelProtocol::MutateSocket>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::MethodA>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kChannelProtocol_MethodA_Ordinal);
}

void ::fidl::internal::TransactionalEvent<
    ::test_protocols::ChannelProtocol::EventA>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kChannelProtocol_EventA_Ordinal);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::MethodB>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kChannelProtocol_MethodB_Ordinal);
}

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::ChannelProtocol::MethodB>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kChannelProtocol_MethodB_Ordinal);
}

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::TakeHandle>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kChannelProtocol_TakeHandle_Ordinal);
}

void ::fidl::WireRequest<
    ::test_protocols::ChannelProtocol::TakeHandle>::_CloseHandles() {
  h.reset();
}
#endif  // __Fuchsia__

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::ChannelProtocol::TakeHandle>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kChannelProtocol_TakeHandle_Ordinal);
}

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::MutateSocket>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kChannelProtocol_MutateSocket_Ordinal);
}

void ::fidl::WireRequest<
    ::test_protocols::ChannelProtocol::MutateSocket>::_CloseHandles() {
  a.reset();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::ChannelProtocol::MutateSocket>::_InitHeader() {
  fidl_init_txn_header(&header, 0,
                       ::test_protocols::kChannelProtocol_MutateSocket_Ordinal);
}

void ::fidl::WireResponse<
    ::test_protocols::ChannelProtocol::MutateSocket>::_CloseHandles() {
  b.reset();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

fidl::Result fidl::internal::WireWeakEventSender<
    ::test_protocols::ChannelProtocol>::EventA(int64_t a, int64_t b) {
  ::fidl::internal::TransactionalEvent<
      ::test_protocols::ChannelProtocol::EventA>
      _response{a, b};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::ChannelProtocol::EventA>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Result fidl::internal::WireWeakBufferEventSender<
    ::test_protocols::ChannelProtocol>::EventA(int64_t a, int64_t b) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::ChannelProtocol::EventA>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<
      ::test_protocols::ChannelProtocol::EventA>
      _response{a, b};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::ChannelProtocol::EventA>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Result fidl::internal::WireEventSender<
    ::test_protocols::ChannelProtocol>::EventA(int64_t a, int64_t b) {
  ::fidl::internal::TransactionalEvent<
      ::test_protocols::ChannelProtocol::EventA>
      _response{a, b};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::ChannelProtocol::EventA>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Result{_message};
}

fidl::Result fidl::internal::WireBufferEventSender<
    ::test_protocols::ChannelProtocol>::EventA(int64_t a, int64_t b) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::ChannelProtocol::EventA>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<
      ::test_protocols::ChannelProtocol::EventA>
      _response{a, b};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::ChannelProtocol::EventA>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Result{_message};
}

#endif  // __Fuchsia__
