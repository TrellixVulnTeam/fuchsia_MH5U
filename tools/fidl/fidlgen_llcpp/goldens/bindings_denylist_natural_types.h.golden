// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <fidl/test.bindingsdenylist/cpp/common_types.h>
#include <fidl/test.bindingsdenylist/cpp/markers.h>
#include <lib/fidl/cpp/coding_traits.h>
#include <lib/fidl/cpp/unified_messaging.h>

#include <cinttypes>
#include <string>

#ifdef __Fuchsia__

#include <lib/zx/channel.h>

#endif  // __Fuchsia__

#include <fidl/test.dependent/cpp/natural_types.h>

namespace test_bindingsdenylist {
class MemberOnlyAppearsInImportingLibrary;

class OnlyAppearsInImportingLibrary;

class DenyEachBinding_OnlyDenySyzkaller_Response;

class DenyEachBindingOnlyDenySyzkallerTopResponse;

class DenyEachBinding_OnlyDenyRust_Response;

class DenyEachBindingOnlyDenyRustTopResponse;

class DenyEachBinding_OnlyDenyLibfuzzer_Response;

class DenyEachBindingOnlyDenyLibfuzzerTopResponse;

class DenyEachBinding_OnlyDenyGo_Response;

class DenyEachBindingOnlyDenyGoTopResponse;

class DenyEachBinding_OnlyDenyDart_Response;

class DenyEachBindingOnlyDenyDartTopResponse;

class DenyEachBindingOnlyDenySyzkallerRequest;

class DenyEachBindingOnlyDenyRustRequest;

class DenyEachBindingOnlyDenyLibfuzzerRequest;

class DenyEachBindingOnlyDenyGoRequest;

class DenyEachBindingOnlyDenyDartRequest;

class OnlyLlcpp;

class DenyEachBinding_OnlyDenySyzkaller_Result;

class DenyEachBinding_OnlyDenyRust_Result;

class DenyEachBinding_OnlyDenyLibfuzzer_Result;

class DenyEachBinding_OnlyDenyGo_Result;

class DenyEachBinding_OnlyDenyDart_Result;

extern "C" const fidl_type_t test_bindingsdenylist_OnlyLlcppTable;

class OnlyLlcpp final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kX = 1,  // 0x1
  };

  // Create an unknown value of this union.
  OnlyLlcpp() : storage_(std::make_shared<Storage_>()) {}

  OnlyLlcpp(OnlyLlcpp&&) noexcept = default;
  OnlyLlcpp& operator=(OnlyLlcpp&&) noexcept = default;
  OnlyLlcpp(const OnlyLlcpp& other) noexcept
      : OnlyLlcpp(other.CloneStorage_()) {}
  OnlyLlcpp& operator=(const OnlyLlcpp& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const OnlyLlcpp& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const OnlyLlcpp& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_bindingsdenylist::OnlyLlcpp::Tag Which() const {
    return OnlyLlcpp::IndexToTag(storage_->index());
  }
  static OnlyLlcpp WithX(uint32_t val) {
    return OnlyLlcpp(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> x() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> x() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_bindingsdenylist::OnlyLlcpp>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 2>
      kMembers = {std::nullopt, std::nullopt};

  explicit OnlyLlcpp(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::test_bindingsdenylist::OnlyLlcpp::Tag tag) {
    switch (tag) {
      case ::test_bindingsdenylist::OnlyLlcpp::Tag::kX:
        return 1;
    }
  }

  static constexpr ::test_bindingsdenylist::OnlyLlcpp::Tag IndexToTag(
      size_t index) {
    switch (index) {
      case 1:
        return ::test_bindingsdenylist::OnlyLlcpp::Tag::kX;
      // TODO: what's the right thing to do here?
      default:
        return ::test_bindingsdenylist::OnlyLlcpp::Tag::kX;
    }
  }
};

extern "C" const fidl_type_t
    test_bindingsdenylist_MemberOnlyAppearsInImportingLibraryTable;

class MemberOnlyAppearsInImportingLibrary final {
 private:
  struct Storage_;

 public:
  MemberOnlyAppearsInImportingLibrary(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  MemberOnlyAppearsInImportingLibrary(bool a) noexcept
      : storage_({.a = std::move(a)}) {}
  MemberOnlyAppearsInImportingLibrary()
      : MemberOnlyAppearsInImportingLibrary(Storage_{}) {}

  MemberOnlyAppearsInImportingLibrary(
      MemberOnlyAppearsInImportingLibrary&&) noexcept = default;
  MemberOnlyAppearsInImportingLibrary& operator=(
      MemberOnlyAppearsInImportingLibrary&&) noexcept = default;
  MemberOnlyAppearsInImportingLibrary(
      const MemberOnlyAppearsInImportingLibrary& other) noexcept
      : MemberOnlyAppearsInImportingLibrary(other.CloneStorage_()) {}
  MemberOnlyAppearsInImportingLibrary& operator=(
      const MemberOnlyAppearsInImportingLibrary& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const MemberOnlyAppearsInImportingLibrary& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary, 1,
        1>::Equal(this, &other);
  }
  bool operator!=(
      const MemberOnlyAppearsInImportingLibrary& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary, 1,
        1>::Equal(this, &other);
  }

  bool a() const { return storage_.a; }

  bool& a() { return storage_.a; }

 private:
  struct Storage_ final {
    bool a{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary, 1, 1>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, bool>{
          &Storage_::a, 0, 0});
};

extern "C" const fidl_type_t
    test_bindingsdenylist_OnlyAppearsInImportingLibraryTable;

class OnlyAppearsInImportingLibrary final {
 private:
  struct Storage_;

 public:
  OnlyAppearsInImportingLibrary(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  OnlyAppearsInImportingLibrary(
      ::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary
          member_only_appears_in_importing_library) noexcept
      : storage_({.member_only_appears_in_importing_library =
                      std::move(member_only_appears_in_importing_library)}) {}
  OnlyAppearsInImportingLibrary() : OnlyAppearsInImportingLibrary(Storage_{}) {}

  OnlyAppearsInImportingLibrary(OnlyAppearsInImportingLibrary&&) noexcept =
      default;
  OnlyAppearsInImportingLibrary& operator=(
      OnlyAppearsInImportingLibrary&&) noexcept = default;
  OnlyAppearsInImportingLibrary(
      const OnlyAppearsInImportingLibrary& other) noexcept
      : OnlyAppearsInImportingLibrary(other.CloneStorage_()) {}
  OnlyAppearsInImportingLibrary& operator=(
      const OnlyAppearsInImportingLibrary& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const OnlyAppearsInImportingLibrary& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::OnlyAppearsInImportingLibrary, 1,
        1>::Equal(this, &other);
  }
  bool operator!=(const OnlyAppearsInImportingLibrary& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::OnlyAppearsInImportingLibrary, 1,
        1>::Equal(this, &other);
  }

  const ::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary&
  member_only_appears_in_importing_library() const {
    return storage_.member_only_appears_in_importing_library;
  }

  ::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary&
  member_only_appears_in_importing_library() {
    return storage_.member_only_appears_in_importing_library;
  }

 private:
  struct Storage_ final {
    ::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary
        member_only_appears_in_importing_library{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_bindingsdenylist::OnlyAppearsInImportingLibrary, 1, 1>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_bindingsdenylist::OnlyAppearsInImportingLibrary>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_,
          ::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary>{
          &Storage_::member_only_appears_in_importing_library, 0, 0});
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenySyzkaller_ResponseTable;

class DenyEachBinding_OnlyDenySyzkaller_Response final {
 private:
  struct Storage_;

 public:
  DenyEachBinding_OnlyDenySyzkaller_Response(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  DenyEachBinding_OnlyDenySyzkaller_Response(int32_t b) noexcept
      : storage_({.b = std::move(b)}) {}
  DenyEachBinding_OnlyDenySyzkaller_Response()
      : DenyEachBinding_OnlyDenySyzkaller_Response(Storage_{}) {}

  DenyEachBinding_OnlyDenySyzkaller_Response(
      DenyEachBinding_OnlyDenySyzkaller_Response&&) noexcept = default;
  DenyEachBinding_OnlyDenySyzkaller_Response& operator=(
      DenyEachBinding_OnlyDenySyzkaller_Response&&) noexcept = default;
  DenyEachBinding_OnlyDenySyzkaller_Response(
      const DenyEachBinding_OnlyDenySyzkaller_Response& other) noexcept
      : DenyEachBinding_OnlyDenySyzkaller_Response(other.CloneStorage_()) {}
  DenyEachBinding_OnlyDenySyzkaller_Response& operator=(
      const DenyEachBinding_OnlyDenySyzkaller_Response& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBinding_OnlyDenySyzkaller_Response& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Response, 4,
        4>::Equal(this, &other);
  }
  bool operator!=(
      const DenyEachBinding_OnlyDenySyzkaller_Response& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Response, 4,
        4>::Equal(this, &other);
  }

  int32_t b() const { return storage_.b; }

  int32_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    int32_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Response, 4,
      4>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Response>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int32_t>{
          &Storage_::b, 0, 0});
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenySyzkaller_ResultTable;

class DenyEachBinding_OnlyDenySyzkaller_Result final {
 private:
  using Storage_ = cpp17::variant<
      cpp17::monostate,
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Response,
      uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  // Create an unknown value of this union.
  DenyEachBinding_OnlyDenySyzkaller_Result()
      : storage_(std::make_shared<Storage_>()) {}

  DenyEachBinding_OnlyDenySyzkaller_Result(
      DenyEachBinding_OnlyDenySyzkaller_Result&&) noexcept = default;
  DenyEachBinding_OnlyDenySyzkaller_Result& operator=(
      DenyEachBinding_OnlyDenySyzkaller_Result&&) noexcept = default;
  DenyEachBinding_OnlyDenySyzkaller_Result(
      const DenyEachBinding_OnlyDenySyzkaller_Result& other) noexcept
      : DenyEachBinding_OnlyDenySyzkaller_Result(other.CloneStorage_()) {}
  DenyEachBinding_OnlyDenySyzkaller_Result& operator=(
      const DenyEachBinding_OnlyDenySyzkaller_Result& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBinding_OnlyDenySyzkaller_Result& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(
      const DenyEachBinding_OnlyDenySyzkaller_Result& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result::
      Tag
      Which() const {
    return DenyEachBinding_OnlyDenySyzkaller_Result::IndexToTag(
        storage_->index());
  }
  static DenyEachBinding_OnlyDenySyzkaller_Result WithResponse(
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Response val) {
    return DenyEachBinding_OnlyDenySyzkaller_Result(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> response() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static DenyEachBinding_OnlyDenySyzkaller_Result WithErr(uint32_t val) {
    return DenyEachBinding_OnlyDenySyzkaller_Result(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> err() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 3>
      kMembers = {std::nullopt, std::nullopt, std::nullopt};

  explicit DenyEachBinding_OnlyDenySyzkaller_Result(
      std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result::Tag
          tag) {
    switch (tag) {
      case ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result::
          Tag::kResponse:
        return 1;
      case ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result::
          Tag::kErr:
        return 2;
    }
  }

  static constexpr ::test_bindingsdenylist::
      DenyEachBinding_OnlyDenySyzkaller_Result::Tag
      IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_bindingsdenylist::
            DenyEachBinding_OnlyDenySyzkaller_Result::Tag::kResponse;
      case 2:
        return ::test_bindingsdenylist::
            DenyEachBinding_OnlyDenySyzkaller_Result::Tag::kErr;
      // TODO: what's the right thing to do here?
      default:
        return ::test_bindingsdenylist::
            DenyEachBinding_OnlyDenySyzkaller_Result::Tag::kResponse;
    }
  }
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenySyzkallerTopResponseTable;

class DenyEachBindingOnlyDenySyzkallerTopResponse final {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenySyzkallerTopResponse(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  DenyEachBindingOnlyDenySyzkallerTopResponse(
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result
          result) noexcept
      : storage_({.result = std::move(result)}) {}
  DenyEachBindingOnlyDenySyzkallerTopResponse()
      : DenyEachBindingOnlyDenySyzkallerTopResponse(Storage_{}) {}

  DenyEachBindingOnlyDenySyzkallerTopResponse(
      DenyEachBindingOnlyDenySyzkallerTopResponse&&) noexcept = default;
  DenyEachBindingOnlyDenySyzkallerTopResponse& operator=(
      DenyEachBindingOnlyDenySyzkallerTopResponse&&) noexcept = default;
  DenyEachBindingOnlyDenySyzkallerTopResponse(
      const DenyEachBindingOnlyDenySyzkallerTopResponse& other) noexcept
      : DenyEachBindingOnlyDenySyzkallerTopResponse(other.CloneStorage_()) {}
  DenyEachBindingOnlyDenySyzkallerTopResponse& operator=(
      const DenyEachBindingOnlyDenySyzkallerTopResponse& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBindingOnlyDenySyzkallerTopResponse& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerTopResponse,
        24, 16>::Equal(this, &other);
  }
  bool operator!=(
      const DenyEachBindingOnlyDenySyzkallerTopResponse& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerTopResponse,
        24, 16>::Equal(this, &other);
  }

  const ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result&
  result() const {
    return storage_.result;
  }

  ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result& result() {
    return storage_.result;
  }

 private:
  struct Storage_ final {
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result result{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerTopResponse, 24,
      16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerTopResponse>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_,
          ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result>{
          &Storage_::result, 0, 0});
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyRust_ResponseTable;

class DenyEachBinding_OnlyDenyRust_Response final {
 private:
  struct Storage_;

 public:
  DenyEachBinding_OnlyDenyRust_Response(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  DenyEachBinding_OnlyDenyRust_Response(int32_t b) noexcept
      : storage_({.b = std::move(b)}) {}
  DenyEachBinding_OnlyDenyRust_Response()
      : DenyEachBinding_OnlyDenyRust_Response(Storage_{}) {}

  DenyEachBinding_OnlyDenyRust_Response(
      DenyEachBinding_OnlyDenyRust_Response&&) noexcept = default;
  DenyEachBinding_OnlyDenyRust_Response& operator=(
      DenyEachBinding_OnlyDenyRust_Response&&) noexcept = default;
  DenyEachBinding_OnlyDenyRust_Response(
      const DenyEachBinding_OnlyDenyRust_Response& other) noexcept
      : DenyEachBinding_OnlyDenyRust_Response(other.CloneStorage_()) {}
  DenyEachBinding_OnlyDenyRust_Response& operator=(
      const DenyEachBinding_OnlyDenyRust_Response& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBinding_OnlyDenyRust_Response& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Response, 4,
        4>::Equal(this, &other);
  }
  bool operator!=(
      const DenyEachBinding_OnlyDenyRust_Response& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Response, 4,
        4>::Equal(this, &other);
  }

  int32_t b() const { return storage_.b; }

  int32_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    int32_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Response, 4, 4>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Response>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int32_t>{
          &Storage_::b, 0, 0});
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyRust_ResultTable;

class DenyEachBinding_OnlyDenyRust_Result final {
 private:
  using Storage_ = cpp17::variant<
      cpp17::monostate,
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Response, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  // Create an unknown value of this union.
  DenyEachBinding_OnlyDenyRust_Result()
      : storage_(std::make_shared<Storage_>()) {}

  DenyEachBinding_OnlyDenyRust_Result(
      DenyEachBinding_OnlyDenyRust_Result&&) noexcept = default;
  DenyEachBinding_OnlyDenyRust_Result& operator=(
      DenyEachBinding_OnlyDenyRust_Result&&) noexcept = default;
  DenyEachBinding_OnlyDenyRust_Result(
      const DenyEachBinding_OnlyDenyRust_Result& other) noexcept
      : DenyEachBinding_OnlyDenyRust_Result(other.CloneStorage_()) {}
  DenyEachBinding_OnlyDenyRust_Result& operator=(
      const DenyEachBinding_OnlyDenyRust_Result& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBinding_OnlyDenyRust_Result& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(
      const DenyEachBinding_OnlyDenyRust_Result& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result::Tag
  Which() const {
    return DenyEachBinding_OnlyDenyRust_Result::IndexToTag(storage_->index());
  }
  static DenyEachBinding_OnlyDenyRust_Result WithResponse(
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Response val) {
    return DenyEachBinding_OnlyDenyRust_Result(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> response() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static DenyEachBinding_OnlyDenyRust_Result WithErr(uint32_t val) {
    return DenyEachBinding_OnlyDenyRust_Result(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> err() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 3>
      kMembers = {std::nullopt, std::nullopt, std::nullopt};

  explicit DenyEachBinding_OnlyDenyRust_Result(
      std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result::Tag tag) {
    switch (tag) {
      case ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result::Tag::
          kResponse:
        return 1;
      case ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result::Tag::
          kErr:
        return 2;
    }
  }

  static constexpr ::test_bindingsdenylist::
      DenyEachBinding_OnlyDenyRust_Result::Tag
      IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result::
            Tag::kResponse;
      case 2:
        return ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result::
            Tag::kErr;
      // TODO: what's the right thing to do here?
      default:
        return ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result::
            Tag::kResponse;
    }
  }
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenyRustTopResponseTable;

class DenyEachBindingOnlyDenyRustTopResponse final {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenyRustTopResponse(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  DenyEachBindingOnlyDenyRustTopResponse(
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result
          result) noexcept
      : storage_({.result = std::move(result)}) {}
  DenyEachBindingOnlyDenyRustTopResponse()
      : DenyEachBindingOnlyDenyRustTopResponse(Storage_{}) {}

  DenyEachBindingOnlyDenyRustTopResponse(
      DenyEachBindingOnlyDenyRustTopResponse&&) noexcept = default;
  DenyEachBindingOnlyDenyRustTopResponse& operator=(
      DenyEachBindingOnlyDenyRustTopResponse&&) noexcept = default;
  DenyEachBindingOnlyDenyRustTopResponse(
      const DenyEachBindingOnlyDenyRustTopResponse& other) noexcept
      : DenyEachBindingOnlyDenyRustTopResponse(other.CloneStorage_()) {}
  DenyEachBindingOnlyDenyRustTopResponse& operator=(
      const DenyEachBindingOnlyDenyRustTopResponse& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBindingOnlyDenyRustTopResponse& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustTopResponse, 24,
        16>::Equal(this, &other);
  }
  bool operator!=(
      const DenyEachBindingOnlyDenyRustTopResponse& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustTopResponse, 24,
        16>::Equal(this, &other);
  }

  const ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result& result()
      const {
    return storage_.result;
  }

  ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result& result() {
    return storage_.result;
  }

 private:
  struct Storage_ final {
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result result{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustTopResponse, 24, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustTopResponse>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_,
          ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result>{
          &Storage_::result, 0, 0});
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyLibfuzzer_ResponseTable;

class DenyEachBinding_OnlyDenyLibfuzzer_Response final {
 private:
  struct Storage_;

 public:
  DenyEachBinding_OnlyDenyLibfuzzer_Response(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  DenyEachBinding_OnlyDenyLibfuzzer_Response(int32_t b) noexcept
      : storage_({.b = std::move(b)}) {}
  DenyEachBinding_OnlyDenyLibfuzzer_Response()
      : DenyEachBinding_OnlyDenyLibfuzzer_Response(Storage_{}) {}

  DenyEachBinding_OnlyDenyLibfuzzer_Response(
      DenyEachBinding_OnlyDenyLibfuzzer_Response&&) noexcept = default;
  DenyEachBinding_OnlyDenyLibfuzzer_Response& operator=(
      DenyEachBinding_OnlyDenyLibfuzzer_Response&&) noexcept = default;
  DenyEachBinding_OnlyDenyLibfuzzer_Response(
      const DenyEachBinding_OnlyDenyLibfuzzer_Response& other) noexcept
      : DenyEachBinding_OnlyDenyLibfuzzer_Response(other.CloneStorage_()) {}
  DenyEachBinding_OnlyDenyLibfuzzer_Response& operator=(
      const DenyEachBinding_OnlyDenyLibfuzzer_Response& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBinding_OnlyDenyLibfuzzer_Response& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Response, 4,
        4>::Equal(this, &other);
  }
  bool operator!=(
      const DenyEachBinding_OnlyDenyLibfuzzer_Response& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Response, 4,
        4>::Equal(this, &other);
  }

  int32_t b() const { return storage_.b; }

  int32_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    int32_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Response, 4,
      4>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Response>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int32_t>{
          &Storage_::b, 0, 0});
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyLibfuzzer_ResultTable;

class DenyEachBinding_OnlyDenyLibfuzzer_Result final {
 private:
  using Storage_ = cpp17::variant<
      cpp17::monostate,
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Response,
      uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  // Create an unknown value of this union.
  DenyEachBinding_OnlyDenyLibfuzzer_Result()
      : storage_(std::make_shared<Storage_>()) {}

  DenyEachBinding_OnlyDenyLibfuzzer_Result(
      DenyEachBinding_OnlyDenyLibfuzzer_Result&&) noexcept = default;
  DenyEachBinding_OnlyDenyLibfuzzer_Result& operator=(
      DenyEachBinding_OnlyDenyLibfuzzer_Result&&) noexcept = default;
  DenyEachBinding_OnlyDenyLibfuzzer_Result(
      const DenyEachBinding_OnlyDenyLibfuzzer_Result& other) noexcept
      : DenyEachBinding_OnlyDenyLibfuzzer_Result(other.CloneStorage_()) {}
  DenyEachBinding_OnlyDenyLibfuzzer_Result& operator=(
      const DenyEachBinding_OnlyDenyLibfuzzer_Result& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBinding_OnlyDenyLibfuzzer_Result& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(
      const DenyEachBinding_OnlyDenyLibfuzzer_Result& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Result::
      Tag
      Which() const {
    return DenyEachBinding_OnlyDenyLibfuzzer_Result::IndexToTag(
        storage_->index());
  }
  static DenyEachBinding_OnlyDenyLibfuzzer_Result WithResponse(
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Response val) {
    return DenyEachBinding_OnlyDenyLibfuzzer_Result(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> response() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static DenyEachBinding_OnlyDenyLibfuzzer_Result WithErr(uint32_t val) {
    return DenyEachBinding_OnlyDenyLibfuzzer_Result(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> err() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Result>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 3>
      kMembers = {std::nullopt, std::nullopt, std::nullopt};

  explicit DenyEachBinding_OnlyDenyLibfuzzer_Result(
      std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Result::Tag
          tag) {
    switch (tag) {
      case ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Result::
          Tag::kResponse:
        return 1;
      case ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Result::
          Tag::kErr:
        return 2;
    }
  }

  static constexpr ::test_bindingsdenylist::
      DenyEachBinding_OnlyDenyLibfuzzer_Result::Tag
      IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_bindingsdenylist::
            DenyEachBinding_OnlyDenyLibfuzzer_Result::Tag::kResponse;
      case 2:
        return ::test_bindingsdenylist::
            DenyEachBinding_OnlyDenyLibfuzzer_Result::Tag::kErr;
      // TODO: what's the right thing to do here?
      default:
        return ::test_bindingsdenylist::
            DenyEachBinding_OnlyDenyLibfuzzer_Result::Tag::kResponse;
    }
  }
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenyLibfuzzerTopResponseTable;

class DenyEachBindingOnlyDenyLibfuzzerTopResponse final {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenyLibfuzzerTopResponse(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  DenyEachBindingOnlyDenyLibfuzzerTopResponse(
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Result
          result) noexcept
      : storage_({.result = std::move(result)}) {}
  DenyEachBindingOnlyDenyLibfuzzerTopResponse()
      : DenyEachBindingOnlyDenyLibfuzzerTopResponse(Storage_{}) {}

  DenyEachBindingOnlyDenyLibfuzzerTopResponse(
      DenyEachBindingOnlyDenyLibfuzzerTopResponse&&) noexcept = default;
  DenyEachBindingOnlyDenyLibfuzzerTopResponse& operator=(
      DenyEachBindingOnlyDenyLibfuzzerTopResponse&&) noexcept = default;
  DenyEachBindingOnlyDenyLibfuzzerTopResponse(
      const DenyEachBindingOnlyDenyLibfuzzerTopResponse& other) noexcept
      : DenyEachBindingOnlyDenyLibfuzzerTopResponse(other.CloneStorage_()) {}
  DenyEachBindingOnlyDenyLibfuzzerTopResponse& operator=(
      const DenyEachBindingOnlyDenyLibfuzzerTopResponse& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBindingOnlyDenyLibfuzzerTopResponse& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenyLibfuzzerTopResponse,
        24, 16>::Equal(this, &other);
  }
  bool operator!=(
      const DenyEachBindingOnlyDenyLibfuzzerTopResponse& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenyLibfuzzerTopResponse,
        24, 16>::Equal(this, &other);
  }

  const ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Result&
  result() const {
    return storage_.result;
  }

  ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Result& result() {
    return storage_.result;
  }

 private:
  struct Storage_ final {
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Result result{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenyLibfuzzerTopResponse, 24,
      16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenyLibfuzzerTopResponse>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_,
          ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Result>{
          &Storage_::result, 0, 0});
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyGo_ResponseTable;

class DenyEachBinding_OnlyDenyGo_Response final {
 private:
  struct Storage_;

 public:
  DenyEachBinding_OnlyDenyGo_Response(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  DenyEachBinding_OnlyDenyGo_Response(int32_t b) noexcept
      : storage_({.b = std::move(b)}) {}
  DenyEachBinding_OnlyDenyGo_Response()
      : DenyEachBinding_OnlyDenyGo_Response(Storage_{}) {}

  DenyEachBinding_OnlyDenyGo_Response(
      DenyEachBinding_OnlyDenyGo_Response&&) noexcept = default;
  DenyEachBinding_OnlyDenyGo_Response& operator=(
      DenyEachBinding_OnlyDenyGo_Response&&) noexcept = default;
  DenyEachBinding_OnlyDenyGo_Response(
      const DenyEachBinding_OnlyDenyGo_Response& other) noexcept
      : DenyEachBinding_OnlyDenyGo_Response(other.CloneStorage_()) {}
  DenyEachBinding_OnlyDenyGo_Response& operator=(
      const DenyEachBinding_OnlyDenyGo_Response& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBinding_OnlyDenyGo_Response& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Response, 4,
        4>::Equal(this, &other);
  }
  bool operator!=(
      const DenyEachBinding_OnlyDenyGo_Response& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Response, 4,
        4>::Equal(this, &other);
  }

  int32_t b() const { return storage_.b; }

  int32_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    int32_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Response, 4, 4>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Response>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int32_t>{
          &Storage_::b, 0, 0});
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyGo_ResultTable;

class DenyEachBinding_OnlyDenyGo_Result final {
 private:
  using Storage_ = cpp17::variant<
      cpp17::monostate,
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Response, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  // Create an unknown value of this union.
  DenyEachBinding_OnlyDenyGo_Result()
      : storage_(std::make_shared<Storage_>()) {}

  DenyEachBinding_OnlyDenyGo_Result(
      DenyEachBinding_OnlyDenyGo_Result&&) noexcept = default;
  DenyEachBinding_OnlyDenyGo_Result& operator=(
      DenyEachBinding_OnlyDenyGo_Result&&) noexcept = default;
  DenyEachBinding_OnlyDenyGo_Result(
      const DenyEachBinding_OnlyDenyGo_Result& other) noexcept
      : DenyEachBinding_OnlyDenyGo_Result(other.CloneStorage_()) {}
  DenyEachBinding_OnlyDenyGo_Result& operator=(
      const DenyEachBinding_OnlyDenyGo_Result& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBinding_OnlyDenyGo_Result& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(
      const DenyEachBinding_OnlyDenyGo_Result& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result::Tag
  Which() const {
    return DenyEachBinding_OnlyDenyGo_Result::IndexToTag(storage_->index());
  }
  static DenyEachBinding_OnlyDenyGo_Result WithResponse(
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Response val) {
    return DenyEachBinding_OnlyDenyGo_Result(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> response() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static DenyEachBinding_OnlyDenyGo_Result WithErr(uint32_t val) {
    return DenyEachBinding_OnlyDenyGo_Result(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> err() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 3>
      kMembers = {std::nullopt, std::nullopt, std::nullopt};

  explicit DenyEachBinding_OnlyDenyGo_Result(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result::Tag tag) {
    switch (tag) {
      case ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result::Tag::
          kResponse:
        return 1;
      case ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result::Tag::
          kErr:
        return 2;
    }
  }

  static constexpr ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result::
      Tag
      IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result::Tag::
            kResponse;
      case 2:
        return ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result::Tag::
            kErr;
      // TODO: what's the right thing to do here?
      default:
        return ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result::Tag::
            kResponse;
    }
  }
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenyGoTopResponseTable;

class DenyEachBindingOnlyDenyGoTopResponse final {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenyGoTopResponse(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  DenyEachBindingOnlyDenyGoTopResponse(
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result
          result) noexcept
      : storage_({.result = std::move(result)}) {}
  DenyEachBindingOnlyDenyGoTopResponse()
      : DenyEachBindingOnlyDenyGoTopResponse(Storage_{}) {}

  DenyEachBindingOnlyDenyGoTopResponse(
      DenyEachBindingOnlyDenyGoTopResponse&&) noexcept = default;
  DenyEachBindingOnlyDenyGoTopResponse& operator=(
      DenyEachBindingOnlyDenyGoTopResponse&&) noexcept = default;
  DenyEachBindingOnlyDenyGoTopResponse(
      const DenyEachBindingOnlyDenyGoTopResponse& other) noexcept
      : DenyEachBindingOnlyDenyGoTopResponse(other.CloneStorage_()) {}
  DenyEachBindingOnlyDenyGoTopResponse& operator=(
      const DenyEachBindingOnlyDenyGoTopResponse& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBindingOnlyDenyGoTopResponse& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenyGoTopResponse, 24,
        16>::Equal(this, &other);
  }
  bool operator!=(
      const DenyEachBindingOnlyDenyGoTopResponse& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenyGoTopResponse, 24,
        16>::Equal(this, &other);
  }

  const ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result& result()
      const {
    return storage_.result;
  }

  ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result& result() {
    return storage_.result;
  }

 private:
  struct Storage_ final {
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result result{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenyGoTopResponse, 24, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenyGoTopResponse>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result>{
          &Storage_::result, 0, 0});
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyDart_ResponseTable;

class DenyEachBinding_OnlyDenyDart_Response final {
 private:
  struct Storage_;

 public:
  DenyEachBinding_OnlyDenyDart_Response(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  DenyEachBinding_OnlyDenyDart_Response(int32_t b) noexcept
      : storage_({.b = std::move(b)}) {}
  DenyEachBinding_OnlyDenyDart_Response()
      : DenyEachBinding_OnlyDenyDart_Response(Storage_{}) {}

  DenyEachBinding_OnlyDenyDart_Response(
      DenyEachBinding_OnlyDenyDart_Response&&) noexcept = default;
  DenyEachBinding_OnlyDenyDart_Response& operator=(
      DenyEachBinding_OnlyDenyDart_Response&&) noexcept = default;
  DenyEachBinding_OnlyDenyDart_Response(
      const DenyEachBinding_OnlyDenyDart_Response& other) noexcept
      : DenyEachBinding_OnlyDenyDart_Response(other.CloneStorage_()) {}
  DenyEachBinding_OnlyDenyDart_Response& operator=(
      const DenyEachBinding_OnlyDenyDart_Response& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBinding_OnlyDenyDart_Response& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Response, 4,
        4>::Equal(this, &other);
  }
  bool operator!=(
      const DenyEachBinding_OnlyDenyDart_Response& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Response, 4,
        4>::Equal(this, &other);
  }

  int32_t b() const { return storage_.b; }

  int32_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    int32_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Response, 4, 4>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Response>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int32_t>{
          &Storage_::b, 0, 0});
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyDart_ResultTable;

class DenyEachBinding_OnlyDenyDart_Result final {
 private:
  using Storage_ = cpp17::variant<
      cpp17::monostate,
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Response, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  // Create an unknown value of this union.
  DenyEachBinding_OnlyDenyDart_Result()
      : storage_(std::make_shared<Storage_>()) {}

  DenyEachBinding_OnlyDenyDart_Result(
      DenyEachBinding_OnlyDenyDart_Result&&) noexcept = default;
  DenyEachBinding_OnlyDenyDart_Result& operator=(
      DenyEachBinding_OnlyDenyDart_Result&&) noexcept = default;
  DenyEachBinding_OnlyDenyDart_Result(
      const DenyEachBinding_OnlyDenyDart_Result& other) noexcept
      : DenyEachBinding_OnlyDenyDart_Result(other.CloneStorage_()) {}
  DenyEachBinding_OnlyDenyDart_Result& operator=(
      const DenyEachBinding_OnlyDenyDart_Result& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBinding_OnlyDenyDart_Result& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(
      const DenyEachBinding_OnlyDenyDart_Result& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result::Tag
  Which() const {
    return DenyEachBinding_OnlyDenyDart_Result::IndexToTag(storage_->index());
  }
  static DenyEachBinding_OnlyDenyDart_Result WithResponse(
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Response val) {
    return DenyEachBinding_OnlyDenyDart_Result(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> response() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static DenyEachBinding_OnlyDenyDart_Result WithErr(uint32_t val) {
    return DenyEachBinding_OnlyDenyDart_Result(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> err() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 3>
      kMembers = {std::nullopt, std::nullopt, std::nullopt};

  explicit DenyEachBinding_OnlyDenyDart_Result(
      std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result::Tag tag) {
    switch (tag) {
      case ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result::Tag::
          kResponse:
        return 1;
      case ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result::Tag::
          kErr:
        return 2;
    }
  }

  static constexpr ::test_bindingsdenylist::
      DenyEachBinding_OnlyDenyDart_Result::Tag
      IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result::
            Tag::kResponse;
      case 2:
        return ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result::
            Tag::kErr;
      // TODO: what's the right thing to do here?
      default:
        return ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result::
            Tag::kResponse;
    }
  }
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenyDartTopResponseTable;

class DenyEachBindingOnlyDenyDartTopResponse final {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenyDartTopResponse(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  DenyEachBindingOnlyDenyDartTopResponse(
      ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result
          result) noexcept
      : storage_({.result = std::move(result)}) {}
  DenyEachBindingOnlyDenyDartTopResponse()
      : DenyEachBindingOnlyDenyDartTopResponse(Storage_{}) {}

  DenyEachBindingOnlyDenyDartTopResponse(
      DenyEachBindingOnlyDenyDartTopResponse&&) noexcept = default;
  DenyEachBindingOnlyDenyDartTopResponse& operator=(
      DenyEachBindingOnlyDenyDartTopResponse&&) noexcept = default;
  DenyEachBindingOnlyDenyDartTopResponse(
      const DenyEachBindingOnlyDenyDartTopResponse& other) noexcept
      : DenyEachBindingOnlyDenyDartTopResponse(other.CloneStorage_()) {}
  DenyEachBindingOnlyDenyDartTopResponse& operator=(
      const DenyEachBindingOnlyDenyDartTopResponse& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBindingOnlyDenyDartTopResponse& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartTopResponse, 24,
        16>::Equal(this, &other);
  }
  bool operator!=(
      const DenyEachBindingOnlyDenyDartTopResponse& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartTopResponse, 24,
        16>::Equal(this, &other);
  }

  const ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result& result()
      const {
    return storage_.result;
  }

  ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result& result() {
    return storage_.result;
  }

 private:
  struct Storage_ final {
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result result{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartTopResponse, 24, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartTopResponse>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_,
          ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result>{
          &Storage_::result, 0, 0});
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenySyzkallerRequestTable;

class DenyEachBindingOnlyDenySyzkallerRequest final {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenySyzkallerRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  DenyEachBindingOnlyDenySyzkallerRequest(bool a) noexcept
      : storage_({.a = std::move(a)}) {}
  DenyEachBindingOnlyDenySyzkallerRequest()
      : DenyEachBindingOnlyDenySyzkallerRequest(Storage_{}) {}

  DenyEachBindingOnlyDenySyzkallerRequest(
      DenyEachBindingOnlyDenySyzkallerRequest&&) noexcept = default;
  DenyEachBindingOnlyDenySyzkallerRequest& operator=(
      DenyEachBindingOnlyDenySyzkallerRequest&&) noexcept = default;
  DenyEachBindingOnlyDenySyzkallerRequest(
      const DenyEachBindingOnlyDenySyzkallerRequest& other) noexcept
      : DenyEachBindingOnlyDenySyzkallerRequest(other.CloneStorage_()) {}
  DenyEachBindingOnlyDenySyzkallerRequest& operator=(
      const DenyEachBindingOnlyDenySyzkallerRequest& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBindingOnlyDenySyzkallerRequest& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerRequest, 1,
        1>::Equal(this, &other);
  }
  bool operator!=(
      const DenyEachBindingOnlyDenySyzkallerRequest& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerRequest, 1,
        1>::Equal(this, &other);
  }

  bool a() const { return storage_.a; }

  bool& a() { return storage_.a; }

 private:
  struct Storage_ final {
    bool a{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerRequest, 1, 1>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerRequest>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, bool>{
          &Storage_::a, 0, 0});
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenyRustRequestTable;

class DenyEachBindingOnlyDenyRustRequest final {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenyRustRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  DenyEachBindingOnlyDenyRustRequest(bool a) noexcept
      : storage_({.a = std::move(a)}) {}
  DenyEachBindingOnlyDenyRustRequest()
      : DenyEachBindingOnlyDenyRustRequest(Storage_{}) {}

  DenyEachBindingOnlyDenyRustRequest(
      DenyEachBindingOnlyDenyRustRequest&&) noexcept = default;
  DenyEachBindingOnlyDenyRustRequest& operator=(
      DenyEachBindingOnlyDenyRustRequest&&) noexcept = default;
  DenyEachBindingOnlyDenyRustRequest(
      const DenyEachBindingOnlyDenyRustRequest& other) noexcept
      : DenyEachBindingOnlyDenyRustRequest(other.CloneStorage_()) {}
  DenyEachBindingOnlyDenyRustRequest& operator=(
      const DenyEachBindingOnlyDenyRustRequest& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBindingOnlyDenyRustRequest& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustRequest, 1,
        1>::Equal(this, &other);
  }
  bool operator!=(
      const DenyEachBindingOnlyDenyRustRequest& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustRequest, 1,
        1>::Equal(this, &other);
  }

  bool a() const { return storage_.a; }

  bool& a() { return storage_.a; }

 private:
  struct Storage_ final {
    bool a{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustRequest, 1, 1>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustRequest>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, bool>{
          &Storage_::a, 0, 0});
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenyLibfuzzerRequestTable;

class DenyEachBindingOnlyDenyLibfuzzerRequest final {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenyLibfuzzerRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  DenyEachBindingOnlyDenyLibfuzzerRequest(bool a) noexcept
      : storage_({.a = std::move(a)}) {}
  DenyEachBindingOnlyDenyLibfuzzerRequest()
      : DenyEachBindingOnlyDenyLibfuzzerRequest(Storage_{}) {}

  DenyEachBindingOnlyDenyLibfuzzerRequest(
      DenyEachBindingOnlyDenyLibfuzzerRequest&&) noexcept = default;
  DenyEachBindingOnlyDenyLibfuzzerRequest& operator=(
      DenyEachBindingOnlyDenyLibfuzzerRequest&&) noexcept = default;
  DenyEachBindingOnlyDenyLibfuzzerRequest(
      const DenyEachBindingOnlyDenyLibfuzzerRequest& other) noexcept
      : DenyEachBindingOnlyDenyLibfuzzerRequest(other.CloneStorage_()) {}
  DenyEachBindingOnlyDenyLibfuzzerRequest& operator=(
      const DenyEachBindingOnlyDenyLibfuzzerRequest& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBindingOnlyDenyLibfuzzerRequest& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenyLibfuzzerRequest, 1,
        1>::Equal(this, &other);
  }
  bool operator!=(
      const DenyEachBindingOnlyDenyLibfuzzerRequest& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenyLibfuzzerRequest, 1,
        1>::Equal(this, &other);
  }

  bool a() const { return storage_.a; }

  bool& a() { return storage_.a; }

 private:
  struct Storage_ final {
    bool a{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenyLibfuzzerRequest, 1, 1>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenyLibfuzzerRequest>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, bool>{
          &Storage_::a, 0, 0});
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenyGoRequestTable;

class DenyEachBindingOnlyDenyGoRequest final {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenyGoRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  DenyEachBindingOnlyDenyGoRequest(bool a) noexcept
      : storage_({.a = std::move(a)}) {}
  DenyEachBindingOnlyDenyGoRequest()
      : DenyEachBindingOnlyDenyGoRequest(Storage_{}) {}

  DenyEachBindingOnlyDenyGoRequest(
      DenyEachBindingOnlyDenyGoRequest&&) noexcept = default;
  DenyEachBindingOnlyDenyGoRequest& operator=(
      DenyEachBindingOnlyDenyGoRequest&&) noexcept = default;
  DenyEachBindingOnlyDenyGoRequest(
      const DenyEachBindingOnlyDenyGoRequest& other) noexcept
      : DenyEachBindingOnlyDenyGoRequest(other.CloneStorage_()) {}
  DenyEachBindingOnlyDenyGoRequest& operator=(
      const DenyEachBindingOnlyDenyGoRequest& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBindingOnlyDenyGoRequest& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenyGoRequest, 1,
        1>::Equal(this, &other);
  }
  bool operator!=(
      const DenyEachBindingOnlyDenyGoRequest& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenyGoRequest, 1,
        1>::Equal(this, &other);
  }

  bool a() const { return storage_.a; }

  bool& a() { return storage_.a; }

 private:
  struct Storage_ final {
    bool a{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenyGoRequest, 1, 1>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenyGoRequest>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, bool>{
          &Storage_::a, 0, 0});
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenyDartRequestTable;

class DenyEachBindingOnlyDenyDartRequest final {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenyDartRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  DenyEachBindingOnlyDenyDartRequest(bool a) noexcept
      : storage_({.a = std::move(a)}) {}
  DenyEachBindingOnlyDenyDartRequest()
      : DenyEachBindingOnlyDenyDartRequest(Storage_{}) {}

  DenyEachBindingOnlyDenyDartRequest(
      DenyEachBindingOnlyDenyDartRequest&&) noexcept = default;
  DenyEachBindingOnlyDenyDartRequest& operator=(
      DenyEachBindingOnlyDenyDartRequest&&) noexcept = default;
  DenyEachBindingOnlyDenyDartRequest(
      const DenyEachBindingOnlyDenyDartRequest& other) noexcept
      : DenyEachBindingOnlyDenyDartRequest(other.CloneStorage_()) {}
  DenyEachBindingOnlyDenyDartRequest& operator=(
      const DenyEachBindingOnlyDenyDartRequest& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const DenyEachBindingOnlyDenyDartRequest& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartRequest, 1,
        1>::Equal(this, &other);
  }
  bool operator!=(
      const DenyEachBindingOnlyDenyDartRequest& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartRequest, 1,
        1>::Equal(this, &other);
  }

  bool a() const { return storage_.a; }

  bool& a() { return storage_.a; }

 private:
  struct Storage_ final {
    bool a{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartRequest, 1, 1>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartRequest>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, bool>{
          &Storage_::a, 0, 0});
};

constexpr uint32_t AllBindings = 0u;

}  // namespace test_bindingsdenylist
namespace fidl {

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_bindingsdenylist_MemberOnlyAppearsInImportingLibraryTable;

template <>
struct IsFidlType<::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_bindingsdenylist_MemberOnlyAppearsInImportingLibraryTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary, 1, 1> {
};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary>
    : public internal::BoolConstant<
          !HasPadding<::test_bindingsdenylist::
                          MemberOnlyAppearsInImportingLibrary>::value &&
          internal::NaturalIsMemcpyCompatible<bool>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_bindingsdenylist_OnlyAppearsInImportingLibraryTable;

template <>
struct IsFidlType<::test_bindingsdenylist::OnlyAppearsInImportingLibrary>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_bindingsdenylist::OnlyAppearsInImportingLibrary>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_bindingsdenylist_OnlyAppearsInImportingLibraryTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::OnlyAppearsInImportingLibrary>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_bindingsdenylist::OnlyAppearsInImportingLibrary, 1, 1> {
};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_bindingsdenylist::OnlyAppearsInImportingLibrary>
    : public internal::BoolConstant<
          !HasPadding<
              ::test_bindingsdenylist::OnlyAppearsInImportingLibrary>::value &&
          internal::NaturalIsMemcpyCompatible<
              ::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary>::
              value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenySyzkaller_ResponseTable;

template <>
struct IsFidlType<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Response>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Response>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_bindingsdenylist_DenyEachBinding_OnlyDenySyzkaller_ResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Response>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Response,
          4, 4> {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Response>
    : public internal::BoolConstant<
          !HasPadding<::test_bindingsdenylist::
                          DenyEachBinding_OnlyDenySyzkaller_Response>::value &&
          internal::NaturalIsMemcpyCompatible<int32_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenySyzkallerTopResponseTable;

template <>
struct IsFidlType<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_bindingsdenylist_DenyEachBindingOnlyDenySyzkallerTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerTopResponse>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerTopResponse,
          24, 16> {};

template <>
struct HasPadding<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerTopResponse>
    : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerTopResponse>
    : public internal::BoolConstant<
          !HasPadding<::test_bindingsdenylist::
                          DenyEachBindingOnlyDenySyzkallerTopResponse>::value &&
          internal::NaturalIsMemcpyCompatible<
              ::test_bindingsdenylist::
                  DenyEachBinding_OnlyDenySyzkaller_Result>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyRust_ResponseTable;

template <>
struct IsFidlType<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Response>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Response>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_bindingsdenylist_DenyEachBinding_OnlyDenyRust_ResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Response>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Response,
                4, 4> {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Response>
    : public internal::BoolConstant<
          !HasPadding<::test_bindingsdenylist::
                          DenyEachBinding_OnlyDenyRust_Response>::value &&
          internal::NaturalIsMemcpyCompatible<int32_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenyRustTopResponseTable;

template <>
struct IsFidlType<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_bindingsdenylist_DenyEachBindingOnlyDenyRustTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustTopResponse>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustTopResponse,
                24, 16> {};

template <>
struct HasPadding<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustTopResponse>
    : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustTopResponse>
    : public internal::BoolConstant<
          !HasPadding<::test_bindingsdenylist::
                          DenyEachBindingOnlyDenyRustTopResponse>::value &&
          internal::NaturalIsMemcpyCompatible<
              ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result>::
              value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyLibfuzzer_ResponseTable;

template <>
struct IsFidlType<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Response>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Response>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_bindingsdenylist_DenyEachBinding_OnlyDenyLibfuzzer_ResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Response>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Response,
          4, 4> {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Response>
    : public internal::BoolConstant<
          !HasPadding<::test_bindingsdenylist::
                          DenyEachBinding_OnlyDenyLibfuzzer_Response>::value &&
          internal::NaturalIsMemcpyCompatible<int32_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenyLibfuzzerTopResponseTable;

template <>
struct IsFidlType<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyLibfuzzerTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyLibfuzzerTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_bindingsdenylist_DenyEachBindingOnlyDenyLibfuzzerTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyLibfuzzerTopResponse>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_bindingsdenylist::DenyEachBindingOnlyDenyLibfuzzerTopResponse,
          24, 16> {};

template <>
struct HasPadding<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyLibfuzzerTopResponse>
    : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyLibfuzzerTopResponse>
    : public internal::BoolConstant<
          !HasPadding<::test_bindingsdenylist::
                          DenyEachBindingOnlyDenyLibfuzzerTopResponse>::value &&
          internal::NaturalIsMemcpyCompatible<
              ::test_bindingsdenylist::
                  DenyEachBinding_OnlyDenyLibfuzzer_Result>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyGo_ResponseTable;

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Response>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Response>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_bindingsdenylist_DenyEachBinding_OnlyDenyGo_ResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Response>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Response, 4, 4> {
};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Response>
    : public internal::BoolConstant<
          !HasPadding<::test_bindingsdenylist::
                          DenyEachBinding_OnlyDenyGo_Response>::value &&
          internal::NaturalIsMemcpyCompatible<int32_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenyGoTopResponseTable;

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyGoTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_bindingsdenylist_DenyEachBindingOnlyDenyGoTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyGoTopResponse>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_bindingsdenylist::DenyEachBindingOnlyDenyGoTopResponse,
                24, 16> {};

template <>
struct HasPadding<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoTopResponse>
    : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyGoTopResponse>
    : public internal::BoolConstant<
          !HasPadding<::test_bindingsdenylist::
                          DenyEachBindingOnlyDenyGoTopResponse>::value &&
          internal::NaturalIsMemcpyCompatible<
              ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result>::
              value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyDart_ResponseTable;

template <>
struct IsFidlType<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Response>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Response>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_bindingsdenylist_DenyEachBinding_OnlyDenyDart_ResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Response>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Response,
                4, 4> {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Response>
    : public internal::BoolConstant<
          !HasPadding<::test_bindingsdenylist::
                          DenyEachBinding_OnlyDenyDart_Response>::value &&
          internal::NaturalIsMemcpyCompatible<int32_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenyDartTopResponseTable;

template <>
struct IsFidlType<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_bindingsdenylist_DenyEachBindingOnlyDenyDartTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartTopResponse>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartTopResponse,
                24, 16> {};

template <>
struct HasPadding<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartTopResponse>
    : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartTopResponse>
    : public internal::BoolConstant<
          !HasPadding<::test_bindingsdenylist::
                          DenyEachBindingOnlyDenyDartTopResponse>::value &&
          internal::NaturalIsMemcpyCompatible<
              ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result>::
              value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenySyzkallerRequestTable;

template <>
struct IsFidlType<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_bindingsdenylist_DenyEachBindingOnlyDenySyzkallerRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerRequest>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerRequest, 1,
          1> {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerRequest>
    : public internal::BoolConstant<
          !HasPadding<::test_bindingsdenylist::
                          DenyEachBindingOnlyDenySyzkallerRequest>::value &&
          internal::NaturalIsMemcpyCompatible<bool>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenyRustRequestTable;

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_bindingsdenylist_DenyEachBindingOnlyDenyRustRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustRequest>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustRequest, 1, 1> {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustRequest>
    : public internal::BoolConstant<
          !HasPadding<::test_bindingsdenylist::
                          DenyEachBindingOnlyDenyRustRequest>::value &&
          internal::NaturalIsMemcpyCompatible<bool>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenyLibfuzzerRequestTable;

template <>
struct IsFidlType<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyLibfuzzerRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyLibfuzzerRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_bindingsdenylist_DenyEachBindingOnlyDenyLibfuzzerRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyLibfuzzerRequest>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_bindingsdenylist::DenyEachBindingOnlyDenyLibfuzzerRequest, 1,
          1> {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyLibfuzzerRequest>
    : public internal::BoolConstant<
          !HasPadding<::test_bindingsdenylist::
                          DenyEachBindingOnlyDenyLibfuzzerRequest>::value &&
          internal::NaturalIsMemcpyCompatible<bool>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenyGoRequestTable;

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyGoRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_bindingsdenylist_DenyEachBindingOnlyDenyGoRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyGoRequest>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_bindingsdenylist::DenyEachBindingOnlyDenyGoRequest, 1, 1> {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyGoRequest>
    : public internal::BoolConstant<
          !HasPadding<::test_bindingsdenylist::
                          DenyEachBindingOnlyDenyGoRequest>::value &&
          internal::NaturalIsMemcpyCompatible<bool>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBindingOnlyDenyDartRequestTable;

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_bindingsdenylist_DenyEachBindingOnlyDenyDartRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartRequest>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartRequest, 1, 1> {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartRequest>
    : public internal::BoolConstant<
          !HasPadding<::test_bindingsdenylist::
                          DenyEachBindingOnlyDenyDartRequest>::value &&
          internal::NaturalIsMemcpyCompatible<bool>::value> {};

#endif  // __Fuchsia__

template <>
struct IsFidlType<::test_bindingsdenylist::OnlyLlcpp> : public std::true_type {
};
template <>
struct IsUnion<::test_bindingsdenylist::OnlyLlcpp> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_bindingsdenylist::OnlyLlcpp> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_bindingsdenylist::OnlyLlcpp> {};

template <>
struct IsFidlType<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result>
    : public std::true_type {};
template <>
struct IsUnion<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result>
    : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result>
    final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result> {};

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result>
    : public std::true_type {};
template <>
struct IsUnion<::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result>
    : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result>
    final : public ::fidl::internal::NaturalUnionCodingTraits<
                ::test_bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result> {
};

template <>
struct IsFidlType<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Result>
    : public std::true_type {};
template <>
struct IsUnion<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Result>
    : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Result>
    final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Result> {};

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result>
    : public std::true_type {};
template <>
struct IsUnion<::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result>
    : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result>
    final : public ::fidl::internal::NaturalUnionCodingTraits<
                ::test_bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result> {};

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result>
    : public std::true_type {};
template <>
struct IsUnion<::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result>
    : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<
    ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result>
    final : public ::fidl::internal::NaturalUnionCodingTraits<
                ::test_bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result> {
};

}  // namespace fidl
