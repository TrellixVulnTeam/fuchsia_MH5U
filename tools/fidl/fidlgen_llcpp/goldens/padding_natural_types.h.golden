// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <fidl/test.padding/cpp/common_types.h>
#include <fidl/test.padding/cpp/markers.h>
#include <lib/fidl/cpp/coding_traits.h>
#include <lib/fidl/cpp/unified_messaging.h>

#include <cinttypes>
#include <string>

#ifdef __Fuchsia__

#endif  // __Fuchsia__

namespace test_padding {
class Padding7ByteMiddle;

class Padding7ByteEnd;

class Padding6ByteMiddle;

class Padding6ByteEnd;

class Padding5ByteMiddle;

class Padding5ByteEnd;

class Padding4ByteMiddle;

class Padding4ByteEnd;

class Padding4ByteAlignmentLength12;

class Padding3ByteMiddle;

class Padding3ByteEnd;

class Padding2ByteMiddle;

class Padding2ByteEnd;

class Padding2ByteAlignmentLength6;

class Padding1ByteMiddle;

class Padding1ByteEnd;

extern "C" const fidl_type_t test_padding_Padding7ByteMiddleTable;

class Padding7ByteMiddle final {
 private:
  struct Storage_;

 public:
  Padding7ByteMiddle(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  Padding7ByteMiddle(uint8_t a, uint64_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding7ByteMiddle() : Padding7ByteMiddle(Storage_{}) {}

  Padding7ByteMiddle(Padding7ByteMiddle&&) noexcept = default;
  Padding7ByteMiddle& operator=(Padding7ByteMiddle&&) noexcept = default;
  Padding7ByteMiddle(const Padding7ByteMiddle& other) noexcept
      : Padding7ByteMiddle(other.CloneStorage_()) {}
  Padding7ByteMiddle& operator=(const Padding7ByteMiddle& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Padding7ByteMiddle& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding7ByteMiddle, 16, 16>::Equal(this, &other);
  }
  bool operator!=(const Padding7ByteMiddle& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding7ByteMiddle, 16, 16>::Equal(this, &other);
  }

  uint8_t a() const { return storage_.a; }

  uint8_t& a() { return storage_.a; }

  uint64_t b() const { return storage_.b; }

  uint64_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    uint8_t a{};
    uint64_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_padding::Padding7ByteMiddle, 16, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_padding::Padding7ByteMiddle>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_, uint8_t>{&Storage_::a, 0,
                                                               0},
      ::fidl::internal::NaturalStructMember<Storage_, uint64_t>{&Storage_::b, 8,
                                                                8});
};

extern "C" const fidl_type_t test_padding_Padding7ByteEndTable;

class Padding7ByteEnd final {
 private:
  struct Storage_;

 public:
  Padding7ByteEnd(Storage_ storage) noexcept : storage_(std::move(storage)) {}
  Padding7ByteEnd(uint64_t a, uint8_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding7ByteEnd() : Padding7ByteEnd(Storage_{}) {}

  Padding7ByteEnd(Padding7ByteEnd&&) noexcept = default;
  Padding7ByteEnd& operator=(Padding7ByteEnd&&) noexcept = default;
  Padding7ByteEnd(const Padding7ByteEnd& other) noexcept
      : Padding7ByteEnd(other.CloneStorage_()) {}
  Padding7ByteEnd& operator=(const Padding7ByteEnd& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Padding7ByteEnd& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding7ByteEnd, 16, 16>::Equal(this, &other);
  }
  bool operator!=(const Padding7ByteEnd& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding7ByteEnd, 16, 16>::Equal(this, &other);
  }

  uint64_t a() const { return storage_.a; }

  uint64_t& a() { return storage_.a; }

  uint8_t b() const { return storage_.b; }

  uint8_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    uint64_t a{};
    uint8_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_padding::Padding7ByteEnd, 16, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_padding::Padding7ByteEnd>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_, uint64_t>{&Storage_::a, 0,
                                                                0},
      ::fidl::internal::NaturalStructMember<Storage_, uint8_t>{&Storage_::b, 8,
                                                               8});
};

extern "C" const fidl_type_t test_padding_Padding6ByteMiddleTable;

class Padding6ByteMiddle final {
 private:
  struct Storage_;

 public:
  Padding6ByteMiddle(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  Padding6ByteMiddle(uint16_t a, uint64_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding6ByteMiddle() : Padding6ByteMiddle(Storage_{}) {}

  Padding6ByteMiddle(Padding6ByteMiddle&&) noexcept = default;
  Padding6ByteMiddle& operator=(Padding6ByteMiddle&&) noexcept = default;
  Padding6ByteMiddle(const Padding6ByteMiddle& other) noexcept
      : Padding6ByteMiddle(other.CloneStorage_()) {}
  Padding6ByteMiddle& operator=(const Padding6ByteMiddle& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Padding6ByteMiddle& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding6ByteMiddle, 16, 16>::Equal(this, &other);
  }
  bool operator!=(const Padding6ByteMiddle& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding6ByteMiddle, 16, 16>::Equal(this, &other);
  }

  uint16_t a() const { return storage_.a; }

  uint16_t& a() { return storage_.a; }

  uint64_t b() const { return storage_.b; }

  uint64_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    uint16_t a{};
    uint64_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_padding::Padding6ByteMiddle, 16, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_padding::Padding6ByteMiddle>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_, uint16_t>{&Storage_::a, 0,
                                                                0},
      ::fidl::internal::NaturalStructMember<Storage_, uint64_t>{&Storage_::b, 8,
                                                                8});
};

extern "C" const fidl_type_t test_padding_Padding6ByteEndTable;

class Padding6ByteEnd final {
 private:
  struct Storage_;

 public:
  Padding6ByteEnd(Storage_ storage) noexcept : storage_(std::move(storage)) {}
  Padding6ByteEnd(uint64_t a, uint16_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding6ByteEnd() : Padding6ByteEnd(Storage_{}) {}

  Padding6ByteEnd(Padding6ByteEnd&&) noexcept = default;
  Padding6ByteEnd& operator=(Padding6ByteEnd&&) noexcept = default;
  Padding6ByteEnd(const Padding6ByteEnd& other) noexcept
      : Padding6ByteEnd(other.CloneStorage_()) {}
  Padding6ByteEnd& operator=(const Padding6ByteEnd& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Padding6ByteEnd& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding6ByteEnd, 16, 16>::Equal(this, &other);
  }
  bool operator!=(const Padding6ByteEnd& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding6ByteEnd, 16, 16>::Equal(this, &other);
  }

  uint64_t a() const { return storage_.a; }

  uint64_t& a() { return storage_.a; }

  uint16_t b() const { return storage_.b; }

  uint16_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    uint64_t a{};
    uint16_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_padding::Padding6ByteEnd, 16, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_padding::Padding6ByteEnd>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_, uint64_t>{&Storage_::a, 0,
                                                                0},
      ::fidl::internal::NaturalStructMember<Storage_, uint16_t>{&Storage_::b, 8,
                                                                8});
};

extern "C" const fidl_type_t test_padding_Padding5ByteMiddleTable;

class Padding5ByteMiddle final {
 private:
  struct Storage_;

 public:
  Padding5ByteMiddle(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  Padding5ByteMiddle(uint16_t a, uint8_t b, uint64_t c) noexcept
      : storage_({.a = std::move(a), .b = std::move(b), .c = std::move(c)}) {}
  Padding5ByteMiddle() : Padding5ByteMiddle(Storage_{}) {}

  Padding5ByteMiddle(Padding5ByteMiddle&&) noexcept = default;
  Padding5ByteMiddle& operator=(Padding5ByteMiddle&&) noexcept = default;
  Padding5ByteMiddle(const Padding5ByteMiddle& other) noexcept
      : Padding5ByteMiddle(other.CloneStorage_()) {}
  Padding5ByteMiddle& operator=(const Padding5ByteMiddle& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Padding5ByteMiddle& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding5ByteMiddle, 16, 16>::Equal(this, &other);
  }
  bool operator!=(const Padding5ByteMiddle& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding5ByteMiddle, 16, 16>::Equal(this, &other);
  }

  uint16_t a() const { return storage_.a; }

  uint16_t& a() { return storage_.a; }

  uint8_t b() const { return storage_.b; }

  uint8_t& b() { return storage_.b; }

  uint64_t c() const { return storage_.c; }

  uint64_t& c() { return storage_.c; }

 private:
  struct Storage_ final {
    uint16_t a{};
    uint8_t b{};
    uint64_t c{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_padding::Padding5ByteMiddle, 16, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_padding::Padding5ByteMiddle>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_, uint16_t>{&Storage_::a, 0,
                                                                0},
      ::fidl::internal::NaturalStructMember<Storage_, uint8_t>{&Storage_::b, 2,
                                                               2},
      ::fidl::internal::NaturalStructMember<Storage_, uint64_t>{&Storage_::c, 8,
                                                                8});
};

extern "C" const fidl_type_t test_padding_Padding5ByteEndTable;

class Padding5ByteEnd final {
 private:
  struct Storage_;

 public:
  Padding5ByteEnd(Storage_ storage) noexcept : storage_(std::move(storage)) {}
  Padding5ByteEnd(uint64_t a, uint16_t b, uint8_t c) noexcept
      : storage_({.a = std::move(a), .b = std::move(b), .c = std::move(c)}) {}
  Padding5ByteEnd() : Padding5ByteEnd(Storage_{}) {}

  Padding5ByteEnd(Padding5ByteEnd&&) noexcept = default;
  Padding5ByteEnd& operator=(Padding5ByteEnd&&) noexcept = default;
  Padding5ByteEnd(const Padding5ByteEnd& other) noexcept
      : Padding5ByteEnd(other.CloneStorage_()) {}
  Padding5ByteEnd& operator=(const Padding5ByteEnd& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Padding5ByteEnd& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding5ByteEnd, 16, 16>::Equal(this, &other);
  }
  bool operator!=(const Padding5ByteEnd& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding5ByteEnd, 16, 16>::Equal(this, &other);
  }

  uint64_t a() const { return storage_.a; }

  uint64_t& a() { return storage_.a; }

  uint16_t b() const { return storage_.b; }

  uint16_t& b() { return storage_.b; }

  uint8_t c() const { return storage_.c; }

  uint8_t& c() { return storage_.c; }

 private:
  struct Storage_ final {
    uint64_t a{};
    uint16_t b{};
    uint8_t c{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_padding::Padding5ByteEnd, 16, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_padding::Padding5ByteEnd>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_, uint64_t>{&Storage_::a, 0,
                                                                0},
      ::fidl::internal::NaturalStructMember<Storage_, uint16_t>{&Storage_::b, 8,
                                                                8},
      ::fidl::internal::NaturalStructMember<Storage_, uint8_t>{&Storage_::c, 10,
                                                               10});
};

extern "C" const fidl_type_t test_padding_Padding4ByteMiddleTable;

class Padding4ByteMiddle final {
 private:
  struct Storage_;

 public:
  Padding4ByteMiddle(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  Padding4ByteMiddle(uint32_t a, uint64_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding4ByteMiddle() : Padding4ByteMiddle(Storage_{}) {}

  Padding4ByteMiddle(Padding4ByteMiddle&&) noexcept = default;
  Padding4ByteMiddle& operator=(Padding4ByteMiddle&&) noexcept = default;
  Padding4ByteMiddle(const Padding4ByteMiddle& other) noexcept
      : Padding4ByteMiddle(other.CloneStorage_()) {}
  Padding4ByteMiddle& operator=(const Padding4ByteMiddle& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Padding4ByteMiddle& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding4ByteMiddle, 16, 16>::Equal(this, &other);
  }
  bool operator!=(const Padding4ByteMiddle& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding4ByteMiddle, 16, 16>::Equal(this, &other);
  }

  uint32_t a() const { return storage_.a; }

  uint32_t& a() { return storage_.a; }

  uint64_t b() const { return storage_.b; }

  uint64_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    uint32_t a{};
    uint64_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_padding::Padding4ByteMiddle, 16, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_padding::Padding4ByteMiddle>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_, uint32_t>{&Storage_::a, 0,
                                                                0},
      ::fidl::internal::NaturalStructMember<Storage_, uint64_t>{&Storage_::b, 8,
                                                                8});
};

extern "C" const fidl_type_t test_padding_Padding4ByteEndTable;

class Padding4ByteEnd final {
 private:
  struct Storage_;

 public:
  Padding4ByteEnd(Storage_ storage) noexcept : storage_(std::move(storage)) {}
  Padding4ByteEnd(uint64_t a, uint32_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding4ByteEnd() : Padding4ByteEnd(Storage_{}) {}

  Padding4ByteEnd(Padding4ByteEnd&&) noexcept = default;
  Padding4ByteEnd& operator=(Padding4ByteEnd&&) noexcept = default;
  Padding4ByteEnd(const Padding4ByteEnd& other) noexcept
      : Padding4ByteEnd(other.CloneStorage_()) {}
  Padding4ByteEnd& operator=(const Padding4ByteEnd& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Padding4ByteEnd& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding4ByteEnd, 16, 16>::Equal(this, &other);
  }
  bool operator!=(const Padding4ByteEnd& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding4ByteEnd, 16, 16>::Equal(this, &other);
  }

  uint64_t a() const { return storage_.a; }

  uint64_t& a() { return storage_.a; }

  uint32_t b() const { return storage_.b; }

  uint32_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    uint64_t a{};
    uint32_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_padding::Padding4ByteEnd, 16, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_padding::Padding4ByteEnd>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_, uint64_t>{&Storage_::a, 0,
                                                                0},
      ::fidl::internal::NaturalStructMember<Storage_, uint32_t>{&Storage_::b, 8,
                                                                8});
};

extern "C" const fidl_type_t test_padding_Padding4ByteAlignmentLength12Table;

class Padding4ByteAlignmentLength12 final {
 private:
  struct Storage_;

 public:
  Padding4ByteAlignmentLength12(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  Padding4ByteAlignmentLength12(uint32_t a, uint8_t b, uint16_t c,
                                uint16_t d) noexcept
      : storage_({.a = std::move(a),
                  .b = std::move(b),
                  .c = std::move(c),
                  .d = std::move(d)}) {}
  Padding4ByteAlignmentLength12() : Padding4ByteAlignmentLength12(Storage_{}) {}

  Padding4ByteAlignmentLength12(Padding4ByteAlignmentLength12&&) noexcept =
      default;
  Padding4ByteAlignmentLength12& operator=(
      Padding4ByteAlignmentLength12&&) noexcept = default;
  Padding4ByteAlignmentLength12(
      const Padding4ByteAlignmentLength12& other) noexcept
      : Padding4ByteAlignmentLength12(other.CloneStorage_()) {}
  Padding4ByteAlignmentLength12& operator=(
      const Padding4ByteAlignmentLength12& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Padding4ByteAlignmentLength12& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding4ByteAlignmentLength12, 12, 12>::Equal(this,
                                                                      &other);
  }
  bool operator!=(const Padding4ByteAlignmentLength12& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding4ByteAlignmentLength12, 12, 12>::Equal(this,
                                                                      &other);
  }

  uint32_t a() const { return storage_.a; }

  uint32_t& a() { return storage_.a; }

  uint8_t b() const { return storage_.b; }

  uint8_t& b() { return storage_.b; }

  uint16_t c() const { return storage_.c; }

  uint16_t& c() { return storage_.c; }

  uint16_t d() const { return storage_.d; }

  uint16_t& d() { return storage_.d; }

 private:
  struct Storage_ final {
    uint32_t a{};
    uint8_t b{};
    uint16_t c{};
    uint16_t d{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_padding::Padding4ByteAlignmentLength12, 12, 12>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_padding::Padding4ByteAlignmentLength12>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_, uint32_t>{&Storage_::a, 0,
                                                                0},
      ::fidl::internal::NaturalStructMember<Storage_, uint8_t>{&Storage_::b, 4,
                                                               4},
      ::fidl::internal::NaturalStructMember<Storage_, uint16_t>{&Storage_::c, 6,
                                                                6},
      ::fidl::internal::NaturalStructMember<Storage_, uint16_t>{&Storage_::d, 8,
                                                                8});
};

extern "C" const fidl_type_t test_padding_Padding3ByteMiddleTable;

class Padding3ByteMiddle final {
 private:
  struct Storage_;

 public:
  Padding3ByteMiddle(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  Padding3ByteMiddle(uint8_t a, uint32_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding3ByteMiddle() : Padding3ByteMiddle(Storage_{}) {}

  Padding3ByteMiddle(Padding3ByteMiddle&&) noexcept = default;
  Padding3ByteMiddle& operator=(Padding3ByteMiddle&&) noexcept = default;
  Padding3ByteMiddle(const Padding3ByteMiddle& other) noexcept
      : Padding3ByteMiddle(other.CloneStorage_()) {}
  Padding3ByteMiddle& operator=(const Padding3ByteMiddle& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Padding3ByteMiddle& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding3ByteMiddle, 8, 8>::Equal(this, &other);
  }
  bool operator!=(const Padding3ByteMiddle& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding3ByteMiddle, 8, 8>::Equal(this, &other);
  }

  uint8_t a() const { return storage_.a; }

  uint8_t& a() { return storage_.a; }

  uint32_t b() const { return storage_.b; }

  uint32_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    uint8_t a{};
    uint32_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_padding::Padding3ByteMiddle, 8, 8>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_padding::Padding3ByteMiddle>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_, uint8_t>{&Storage_::a, 0,
                                                               0},
      ::fidl::internal::NaturalStructMember<Storage_, uint32_t>{&Storage_::b, 4,
                                                                4});
};

extern "C" const fidl_type_t test_padding_Padding3ByteEndTable;

class Padding3ByteEnd final {
 private:
  struct Storage_;

 public:
  Padding3ByteEnd(Storage_ storage) noexcept : storage_(std::move(storage)) {}
  Padding3ByteEnd(uint32_t a, uint8_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding3ByteEnd() : Padding3ByteEnd(Storage_{}) {}

  Padding3ByteEnd(Padding3ByteEnd&&) noexcept = default;
  Padding3ByteEnd& operator=(Padding3ByteEnd&&) noexcept = default;
  Padding3ByteEnd(const Padding3ByteEnd& other) noexcept
      : Padding3ByteEnd(other.CloneStorage_()) {}
  Padding3ByteEnd& operator=(const Padding3ByteEnd& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Padding3ByteEnd& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding3ByteEnd, 8, 8>::Equal(this, &other);
  }
  bool operator!=(const Padding3ByteEnd& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding3ByteEnd, 8, 8>::Equal(this, &other);
  }

  uint32_t a() const { return storage_.a; }

  uint32_t& a() { return storage_.a; }

  uint8_t b() const { return storage_.b; }

  uint8_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    uint32_t a{};
    uint8_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_padding::Padding3ByteEnd, 8, 8>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_padding::Padding3ByteEnd>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_, uint32_t>{&Storage_::a, 0,
                                                                0},
      ::fidl::internal::NaturalStructMember<Storage_, uint8_t>{&Storage_::b, 4,
                                                               4});
};

extern "C" const fidl_type_t test_padding_Padding2ByteMiddleTable;

class Padding2ByteMiddle final {
 private:
  struct Storage_;

 public:
  Padding2ByteMiddle(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  Padding2ByteMiddle(uint16_t a, uint32_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding2ByteMiddle() : Padding2ByteMiddle(Storage_{}) {}

  Padding2ByteMiddle(Padding2ByteMiddle&&) noexcept = default;
  Padding2ByteMiddle& operator=(Padding2ByteMiddle&&) noexcept = default;
  Padding2ByteMiddle(const Padding2ByteMiddle& other) noexcept
      : Padding2ByteMiddle(other.CloneStorage_()) {}
  Padding2ByteMiddle& operator=(const Padding2ByteMiddle& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Padding2ByteMiddle& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding2ByteMiddle, 8, 8>::Equal(this, &other);
  }
  bool operator!=(const Padding2ByteMiddle& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding2ByteMiddle, 8, 8>::Equal(this, &other);
  }

  uint16_t a() const { return storage_.a; }

  uint16_t& a() { return storage_.a; }

  uint32_t b() const { return storage_.b; }

  uint32_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    uint16_t a{};
    uint32_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_padding::Padding2ByteMiddle, 8, 8>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_padding::Padding2ByteMiddle>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_, uint16_t>{&Storage_::a, 0,
                                                                0},
      ::fidl::internal::NaturalStructMember<Storage_, uint32_t>{&Storage_::b, 4,
                                                                4});
};

extern "C" const fidl_type_t test_padding_Padding2ByteEndTable;

class Padding2ByteEnd final {
 private:
  struct Storage_;

 public:
  Padding2ByteEnd(Storage_ storage) noexcept : storage_(std::move(storage)) {}
  Padding2ByteEnd(uint32_t a, uint16_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding2ByteEnd() : Padding2ByteEnd(Storage_{}) {}

  Padding2ByteEnd(Padding2ByteEnd&&) noexcept = default;
  Padding2ByteEnd& operator=(Padding2ByteEnd&&) noexcept = default;
  Padding2ByteEnd(const Padding2ByteEnd& other) noexcept
      : Padding2ByteEnd(other.CloneStorage_()) {}
  Padding2ByteEnd& operator=(const Padding2ByteEnd& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Padding2ByteEnd& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding2ByteEnd, 8, 8>::Equal(this, &other);
  }
  bool operator!=(const Padding2ByteEnd& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding2ByteEnd, 8, 8>::Equal(this, &other);
  }

  uint32_t a() const { return storage_.a; }

  uint32_t& a() { return storage_.a; }

  uint16_t b() const { return storage_.b; }

  uint16_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    uint32_t a{};
    uint16_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_padding::Padding2ByteEnd, 8, 8>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_padding::Padding2ByteEnd>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_, uint32_t>{&Storage_::a, 0,
                                                                0},
      ::fidl::internal::NaturalStructMember<Storage_, uint16_t>{&Storage_::b, 4,
                                                                4});
};

extern "C" const fidl_type_t test_padding_Padding2ByteAlignmentLength6Table;

class Padding2ByteAlignmentLength6 final {
 private:
  struct Storage_;

 public:
  Padding2ByteAlignmentLength6(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  Padding2ByteAlignmentLength6(uint8_t a, uint16_t b, uint8_t c) noexcept
      : storage_({.a = std::move(a), .b = std::move(b), .c = std::move(c)}) {}
  Padding2ByteAlignmentLength6() : Padding2ByteAlignmentLength6(Storage_{}) {}

  Padding2ByteAlignmentLength6(Padding2ByteAlignmentLength6&&) noexcept =
      default;
  Padding2ByteAlignmentLength6& operator=(
      Padding2ByteAlignmentLength6&&) noexcept = default;
  Padding2ByteAlignmentLength6(
      const Padding2ByteAlignmentLength6& other) noexcept
      : Padding2ByteAlignmentLength6(other.CloneStorage_()) {}
  Padding2ByteAlignmentLength6& operator=(
      const Padding2ByteAlignmentLength6& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Padding2ByteAlignmentLength6& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding2ByteAlignmentLength6, 6, 6>::Equal(this,
                                                                   &other);
  }
  bool operator!=(const Padding2ByteAlignmentLength6& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding2ByteAlignmentLength6, 6, 6>::Equal(this,
                                                                   &other);
  }

  uint8_t a() const { return storage_.a; }

  uint8_t& a() { return storage_.a; }

  uint16_t b() const { return storage_.b; }

  uint16_t& b() { return storage_.b; }

  uint8_t c() const { return storage_.c; }

  uint8_t& c() { return storage_.c; }

 private:
  struct Storage_ final {
    uint8_t a{};
    uint16_t b{};
    uint8_t c{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_padding::Padding2ByteAlignmentLength6, 6, 6>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_padding::Padding2ByteAlignmentLength6>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_, uint8_t>{&Storage_::a, 0,
                                                               0},
      ::fidl::internal::NaturalStructMember<Storage_, uint16_t>{&Storage_::b, 2,
                                                                2},
      ::fidl::internal::NaturalStructMember<Storage_, uint8_t>{&Storage_::c, 4,
                                                               4});
};

extern "C" const fidl_type_t test_padding_Padding1ByteMiddleTable;

class Padding1ByteMiddle final {
 private:
  struct Storage_;

 public:
  Padding1ByteMiddle(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  Padding1ByteMiddle(uint8_t a, uint16_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding1ByteMiddle() : Padding1ByteMiddle(Storage_{}) {}

  Padding1ByteMiddle(Padding1ByteMiddle&&) noexcept = default;
  Padding1ByteMiddle& operator=(Padding1ByteMiddle&&) noexcept = default;
  Padding1ByteMiddle(const Padding1ByteMiddle& other) noexcept
      : Padding1ByteMiddle(other.CloneStorage_()) {}
  Padding1ByteMiddle& operator=(const Padding1ByteMiddle& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Padding1ByteMiddle& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding1ByteMiddle, 4, 4>::Equal(this, &other);
  }
  bool operator!=(const Padding1ByteMiddle& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding1ByteMiddle, 4, 4>::Equal(this, &other);
  }

  uint8_t a() const { return storage_.a; }

  uint8_t& a() { return storage_.a; }

  uint16_t b() const { return storage_.b; }

  uint16_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    uint8_t a{};
    uint16_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_padding::Padding1ByteMiddle, 4, 4>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_padding::Padding1ByteMiddle>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_, uint8_t>{&Storage_::a, 0,
                                                               0},
      ::fidl::internal::NaturalStructMember<Storage_, uint16_t>{&Storage_::b, 2,
                                                                2});
};

extern "C" const fidl_type_t test_padding_Padding1ByteEndTable;

class Padding1ByteEnd final {
 private:
  struct Storage_;

 public:
  Padding1ByteEnd(Storage_ storage) noexcept : storage_(std::move(storage)) {}
  Padding1ByteEnd(uint16_t a, uint8_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding1ByteEnd() : Padding1ByteEnd(Storage_{}) {}

  Padding1ByteEnd(Padding1ByteEnd&&) noexcept = default;
  Padding1ByteEnd& operator=(Padding1ByteEnd&&) noexcept = default;
  Padding1ByteEnd(const Padding1ByteEnd& other) noexcept
      : Padding1ByteEnd(other.CloneStorage_()) {}
  Padding1ByteEnd& operator=(const Padding1ByteEnd& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Padding1ByteEnd& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding1ByteEnd, 4, 4>::Equal(this, &other);
  }
  bool operator!=(const Padding1ByteEnd& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_padding::Padding1ByteEnd, 4, 4>::Equal(this, &other);
  }

  uint16_t a() const { return storage_.a; }

  uint16_t& a() { return storage_.a; }

  uint8_t b() const { return storage_.b; }

  uint8_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    uint16_t a{};
    uint8_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_padding::Padding1ByteEnd, 4, 4>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_padding::Padding1ByteEnd>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_, uint16_t>{&Storage_::a, 0,
                                                                0},
      ::fidl::internal::NaturalStructMember<Storage_, uint8_t>{&Storage_::b, 2,
                                                               2});
};

}  // namespace test_padding
namespace fidl {

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding7ByteMiddleTable;

template <>
struct IsFidlType<::test_padding::Padding7ByteMiddle> : public std::true_type {
};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding7ByteMiddle> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding7ByteMiddleTable;
};

template <>
struct internal::NaturalCodingTraits<::test_padding::Padding7ByteMiddle> final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_padding::Padding7ByteMiddle, 16, 16> {};

template <>
struct HasPadding<::test_padding::Padding7ByteMiddle> : public std::true_type {
};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_padding::Padding7ByteMiddle>
    : public internal::BoolConstant<
          !HasPadding<::test_padding::Padding7ByteMiddle>::value &&
          internal::NaturalIsMemcpyCompatible<uint8_t>::value &&
          internal::NaturalIsMemcpyCompatible<uint64_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding7ByteEndTable;

template <>
struct IsFidlType<::test_padding::Padding7ByteEnd> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding7ByteEnd> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding7ByteEndTable;
};

template <>
struct internal::NaturalCodingTraits<::test_padding::Padding7ByteEnd> final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_padding::Padding7ByteEnd, 16, 16> {};

template <>
struct HasPadding<::test_padding::Padding7ByteEnd> : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_padding::Padding7ByteEnd>
    : public internal::BoolConstant<
          !HasPadding<::test_padding::Padding7ByteEnd>::value &&
          internal::NaturalIsMemcpyCompatible<uint64_t>::value &&
          internal::NaturalIsMemcpyCompatible<uint8_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding6ByteMiddleTable;

template <>
struct IsFidlType<::test_padding::Padding6ByteMiddle> : public std::true_type {
};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding6ByteMiddle> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding6ByteMiddleTable;
};

template <>
struct internal::NaturalCodingTraits<::test_padding::Padding6ByteMiddle> final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_padding::Padding6ByteMiddle, 16, 16> {};

template <>
struct HasPadding<::test_padding::Padding6ByteMiddle> : public std::true_type {
};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_padding::Padding6ByteMiddle>
    : public internal::BoolConstant<
          !HasPadding<::test_padding::Padding6ByteMiddle>::value &&
          internal::NaturalIsMemcpyCompatible<uint16_t>::value &&
          internal::NaturalIsMemcpyCompatible<uint64_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding6ByteEndTable;

template <>
struct IsFidlType<::test_padding::Padding6ByteEnd> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding6ByteEnd> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding6ByteEndTable;
};

template <>
struct internal::NaturalCodingTraits<::test_padding::Padding6ByteEnd> final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_padding::Padding6ByteEnd, 16, 16> {};

template <>
struct HasPadding<::test_padding::Padding6ByteEnd> : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_padding::Padding6ByteEnd>
    : public internal::BoolConstant<
          !HasPadding<::test_padding::Padding6ByteEnd>::value &&
          internal::NaturalIsMemcpyCompatible<uint64_t>::value &&
          internal::NaturalIsMemcpyCompatible<uint16_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding5ByteMiddleTable;

template <>
struct IsFidlType<::test_padding::Padding5ByteMiddle> : public std::true_type {
};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding5ByteMiddle> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding5ByteMiddleTable;
};

template <>
struct internal::NaturalCodingTraits<::test_padding::Padding5ByteMiddle> final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_padding::Padding5ByteMiddle, 16, 16> {};

template <>
struct HasPadding<::test_padding::Padding5ByteMiddle> : public std::true_type {
};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_padding::Padding5ByteMiddle>
    : public internal::BoolConstant<
          !HasPadding<::test_padding::Padding5ByteMiddle>::value &&
          internal::NaturalIsMemcpyCompatible<uint16_t>::value &&
          internal::NaturalIsMemcpyCompatible<uint8_t>::value &&
          internal::NaturalIsMemcpyCompatible<uint64_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding5ByteEndTable;

template <>
struct IsFidlType<::test_padding::Padding5ByteEnd> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding5ByteEnd> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding5ByteEndTable;
};

template <>
struct internal::NaturalCodingTraits<::test_padding::Padding5ByteEnd> final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_padding::Padding5ByteEnd, 16, 16> {};

template <>
struct HasPadding<::test_padding::Padding5ByteEnd> : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_padding::Padding5ByteEnd>
    : public internal::BoolConstant<
          !HasPadding<::test_padding::Padding5ByteEnd>::value &&
          internal::NaturalIsMemcpyCompatible<uint64_t>::value &&
          internal::NaturalIsMemcpyCompatible<uint16_t>::value &&
          internal::NaturalIsMemcpyCompatible<uint8_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding4ByteMiddleTable;

template <>
struct IsFidlType<::test_padding::Padding4ByteMiddle> : public std::true_type {
};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding4ByteMiddle> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding4ByteMiddleTable;
};

template <>
struct internal::NaturalCodingTraits<::test_padding::Padding4ByteMiddle> final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_padding::Padding4ByteMiddle, 16, 16> {};

template <>
struct HasPadding<::test_padding::Padding4ByteMiddle> : public std::true_type {
};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_padding::Padding4ByteMiddle>
    : public internal::BoolConstant<
          !HasPadding<::test_padding::Padding4ByteMiddle>::value &&
          internal::NaturalIsMemcpyCompatible<uint32_t>::value &&
          internal::NaturalIsMemcpyCompatible<uint64_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding4ByteEndTable;

template <>
struct IsFidlType<::test_padding::Padding4ByteEnd> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding4ByteEnd> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding4ByteEndTable;
};

template <>
struct internal::NaturalCodingTraits<::test_padding::Padding4ByteEnd> final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_padding::Padding4ByteEnd, 16, 16> {};

template <>
struct HasPadding<::test_padding::Padding4ByteEnd> : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_padding::Padding4ByteEnd>
    : public internal::BoolConstant<
          !HasPadding<::test_padding::Padding4ByteEnd>::value &&
          internal::NaturalIsMemcpyCompatible<uint64_t>::value &&
          internal::NaturalIsMemcpyCompatible<uint32_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding4ByteAlignmentLength12Table;

template <>
struct IsFidlType<::test_padding::Padding4ByteAlignmentLength12>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_padding::Padding4ByteAlignmentLength12>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding4ByteAlignmentLength12Table;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_padding::Padding4ByteAlignmentLength12>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_padding::Padding4ByteAlignmentLength12, 12, 12> {};

template <>
struct HasPadding<::test_padding::Padding4ByteAlignmentLength12>
    : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_padding::Padding4ByteAlignmentLength12>
    : public internal::BoolConstant<
          !HasPadding<::test_padding::Padding4ByteAlignmentLength12>::value &&
          internal::NaturalIsMemcpyCompatible<uint32_t>::value &&
          internal::NaturalIsMemcpyCompatible<uint8_t>::value &&
          internal::NaturalIsMemcpyCompatible<uint16_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding3ByteMiddleTable;

template <>
struct IsFidlType<::test_padding::Padding3ByteMiddle> : public std::true_type {
};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding3ByteMiddle> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding3ByteMiddleTable;
};

template <>
struct internal::NaturalCodingTraits<::test_padding::Padding3ByteMiddle> final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_padding::Padding3ByteMiddle, 8, 8> {};

template <>
struct HasPadding<::test_padding::Padding3ByteMiddle> : public std::true_type {
};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_padding::Padding3ByteMiddle>
    : public internal::BoolConstant<
          !HasPadding<::test_padding::Padding3ByteMiddle>::value &&
          internal::NaturalIsMemcpyCompatible<uint8_t>::value &&
          internal::NaturalIsMemcpyCompatible<uint32_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding3ByteEndTable;

template <>
struct IsFidlType<::test_padding::Padding3ByteEnd> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding3ByteEnd> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding3ByteEndTable;
};

template <>
struct internal::NaturalCodingTraits<::test_padding::Padding3ByteEnd> final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_padding::Padding3ByteEnd, 8, 8> {};

template <>
struct HasPadding<::test_padding::Padding3ByteEnd> : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_padding::Padding3ByteEnd>
    : public internal::BoolConstant<
          !HasPadding<::test_padding::Padding3ByteEnd>::value &&
          internal::NaturalIsMemcpyCompatible<uint32_t>::value &&
          internal::NaturalIsMemcpyCompatible<uint8_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding2ByteMiddleTable;

template <>
struct IsFidlType<::test_padding::Padding2ByteMiddle> : public std::true_type {
};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding2ByteMiddle> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding2ByteMiddleTable;
};

template <>
struct internal::NaturalCodingTraits<::test_padding::Padding2ByteMiddle> final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_padding::Padding2ByteMiddle, 8, 8> {};

template <>
struct HasPadding<::test_padding::Padding2ByteMiddle> : public std::true_type {
};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_padding::Padding2ByteMiddle>
    : public internal::BoolConstant<
          !HasPadding<::test_padding::Padding2ByteMiddle>::value &&
          internal::NaturalIsMemcpyCompatible<uint16_t>::value &&
          internal::NaturalIsMemcpyCompatible<uint32_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding2ByteEndTable;

template <>
struct IsFidlType<::test_padding::Padding2ByteEnd> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding2ByteEnd> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding2ByteEndTable;
};

template <>
struct internal::NaturalCodingTraits<::test_padding::Padding2ByteEnd> final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_padding::Padding2ByteEnd, 8, 8> {};

template <>
struct HasPadding<::test_padding::Padding2ByteEnd> : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_padding::Padding2ByteEnd>
    : public internal::BoolConstant<
          !HasPadding<::test_padding::Padding2ByteEnd>::value &&
          internal::NaturalIsMemcpyCompatible<uint32_t>::value &&
          internal::NaturalIsMemcpyCompatible<uint16_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding2ByteAlignmentLength6Table;

template <>
struct IsFidlType<::test_padding::Padding2ByteAlignmentLength6>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_padding::Padding2ByteAlignmentLength6>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding2ByteAlignmentLength6Table;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_padding::Padding2ByteAlignmentLength6>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_padding::Padding2ByteAlignmentLength6, 6, 6> {};

template <>
struct HasPadding<::test_padding::Padding2ByteAlignmentLength6>
    : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_padding::Padding2ByteAlignmentLength6>
    : public internal::BoolConstant<
          !HasPadding<::test_padding::Padding2ByteAlignmentLength6>::value &&
          internal::NaturalIsMemcpyCompatible<uint8_t>::value &&
          internal::NaturalIsMemcpyCompatible<uint16_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding1ByteMiddleTable;

template <>
struct IsFidlType<::test_padding::Padding1ByteMiddle> : public std::true_type {
};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding1ByteMiddle> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding1ByteMiddleTable;
};

template <>
struct internal::NaturalCodingTraits<::test_padding::Padding1ByteMiddle> final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_padding::Padding1ByteMiddle, 4, 4> {};

template <>
struct HasPadding<::test_padding::Padding1ByteMiddle> : public std::true_type {
};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_padding::Padding1ByteMiddle>
    : public internal::BoolConstant<
          !HasPadding<::test_padding::Padding1ByteMiddle>::value &&
          internal::NaturalIsMemcpyCompatible<uint8_t>::value &&
          internal::NaturalIsMemcpyCompatible<uint16_t>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding1ByteEndTable;

template <>
struct IsFidlType<::test_padding::Padding1ByteEnd> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding1ByteEnd> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding1ByteEndTable;
};

template <>
struct internal::NaturalCodingTraits<::test_padding::Padding1ByteEnd> final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_padding::Padding1ByteEnd, 4, 4> {};

template <>
struct HasPadding<::test_padding::Padding1ByteEnd> : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_padding::Padding1ByteEnd>
    : public internal::BoolConstant<
          !HasPadding<::test_padding::Padding1ByteEnd>::value &&
          internal::NaturalIsMemcpyCompatible<uint16_t>::value &&
          internal::NaturalIsMemcpyCompatible<uint8_t>::value> {};

#endif  // __Fuchsia__

}  // namespace fidl
