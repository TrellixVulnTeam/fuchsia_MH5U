// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/envelope.h>
#include <lib/fidl/llcpp/message.h>
#include <lib/fidl/llcpp/message_storage.h>
#include <lib/fidl/llcpp/object_view.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/wire_types.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>
#ifdef __Fuchsia__

#endif  // __Fuchsia__

#include <fidl/test.unionsandwich/cpp/common_types.h>
#include <fidl/test.unionsandwich/cpp/markers.h>

namespace test_unionsandwich {
namespace wire {
struct SandwichUnionSize8Alignment4;

struct SandwichUnionSize36Alignment4;

struct SandwichUnionSize12Alignment4;

struct StructSize16Alignment8;

struct SandwichUnionSize24Alignment8;

class UnionSize8Alignment4;

class UnionSize36Alignment4;

class UnionSize12Alignment4;

class UnionSize24Alignment8;

extern "C" const fidl_type_t test_unionsandwich_UnionSize8Alignment4Table;

class UnionSize8Alignment4 {
 public:
  UnionSize8Alignment4()
      : ordinal_(
            ::test_unionsandwich::wire::UnionSize8Alignment4::Ordinal::Invalid),
        envelope_ {}
  {}

  UnionSize8Alignment4(const UnionSize8Alignment4&) = default;
  UnionSize8Alignment4& operator=(const UnionSize8Alignment4&) = default;
  UnionSize8Alignment4(UnionSize8Alignment4&&) = default;
  UnionSize8Alignment4& operator=(UnionSize8Alignment4&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kVariant = 1,  // 0x1
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_unionsandwich::wire::UnionSize8Alignment4::Ordinal::Invalid;
  }

  bool is_variant() const {
    return ordinal_ ==
           ::test_unionsandwich::wire::UnionSize8Alignment4::Ordinal::kVariant;
  }
  static UnionSize8Alignment4 WithVariant(uint32_t val) {
    UnionSize8Alignment4 result;
    result.set_variant(std::move(val));
    return result;
  }

  void set_variant(uint32_t elem) {
    ordinal_ =
        ::test_unionsandwich::wire::UnionSize8Alignment4::Ordinal::kVariant;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& variant() {
    ZX_ASSERT(
        ordinal_ ==
        ::test_unionsandwich::wire::UnionSize8Alignment4::Ordinal::kVariant);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& variant() const {
    ZX_ASSERT(
        ordinal_ ==
        ::test_unionsandwich::wire::UnionSize8Alignment4::Ordinal::kVariant);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_unionsandwich::wire::UnionSize8Alignment4::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unionsandwich::wire::UnionSize8Alignment4::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kVariant = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unionsandwich::wire::UnionSize8Alignment4::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t test_unionsandwich_UnionSize36Alignment4Table;

class UnionSize36Alignment4 {
 public:
  UnionSize36Alignment4()
      : ordinal_(::test_unionsandwich::wire::UnionSize36Alignment4::Ordinal::
                     Invalid),
        envelope_ {}
  {}

  UnionSize36Alignment4(const UnionSize36Alignment4&) = default;
  UnionSize36Alignment4& operator=(const UnionSize36Alignment4&) = default;
  UnionSize36Alignment4(UnionSize36Alignment4&&) = default;
  UnionSize36Alignment4& operator=(UnionSize36Alignment4&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kVariant = 1,  // 0x1
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_unionsandwich::wire::UnionSize36Alignment4::Ordinal::Invalid;
  }

  bool is_variant() const {
    return ordinal_ ==
           ::test_unionsandwich::wire::UnionSize36Alignment4::Ordinal::kVariant;
  }
  static UnionSize36Alignment4 WithVariant(
      ::fidl::ObjectView<::fidl::Array<uint8_t, 32>> val) {
    UnionSize36Alignment4 result;
    result.set_variant(val);
    return result;
  }

  template <typename... Args>
  static UnionSize36Alignment4 WithVariant(::fidl::AnyArena& allocator,
                                           Args&&... args) {
    UnionSize36Alignment4 result;
    result.set_variant(::fidl::ObjectView<::fidl::Array<uint8_t, 32>>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_variant(::fidl::ObjectView<::fidl::Array<uint8_t, 32>> elem) {
    ordinal_ =
        ::test_unionsandwich::wire::UnionSize36Alignment4::Ordinal::kVariant;
    envelope_.As<::fidl::Array<uint8_t, 32>>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_variant(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ =
        ::test_unionsandwich::wire::UnionSize36Alignment4::Ordinal::kVariant;
    set_variant(::fidl::ObjectView<::fidl::Array<uint8_t, 32>>(
        allocator, std::forward<Args>(args)...));
  }

  ::fidl::Array<uint8_t, 32>& variant() {
    ZX_ASSERT(
        ordinal_ ==
        ::test_unionsandwich::wire::UnionSize36Alignment4::Ordinal::kVariant);
    return envelope_.As<::fidl::Array<uint8_t, 32>>().get_data();
  }
  const ::fidl::Array<uint8_t, 32>& variant() const {
    ZX_ASSERT(
        ordinal_ ==
        ::test_unionsandwich::wire::UnionSize36Alignment4::Ordinal::kVariant);
    return envelope_.As<::fidl::Array<uint8_t, 32>>().get_data();
  }
  ::test_unionsandwich::wire::UnionSize36Alignment4::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unionsandwich::wire::UnionSize36Alignment4::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kVariant = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unionsandwich::wire::UnionSize36Alignment4::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t test_unionsandwich_UnionSize12Alignment4Table;

class UnionSize12Alignment4 {
 public:
  UnionSize12Alignment4()
      : ordinal_(::test_unionsandwich::wire::UnionSize12Alignment4::Ordinal::
                     Invalid),
        envelope_ {}
  {}

  UnionSize12Alignment4(const UnionSize12Alignment4&) = default;
  UnionSize12Alignment4& operator=(const UnionSize12Alignment4&) = default;
  UnionSize12Alignment4(UnionSize12Alignment4&&) = default;
  UnionSize12Alignment4& operator=(UnionSize12Alignment4&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kVariant = 1,  // 0x1
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_unionsandwich::wire::UnionSize12Alignment4::Ordinal::Invalid;
  }

  bool is_variant() const {
    return ordinal_ ==
           ::test_unionsandwich::wire::UnionSize12Alignment4::Ordinal::kVariant;
  }
  static UnionSize12Alignment4 WithVariant(
      ::fidl::ObjectView<::fidl::Array<uint8_t, 6>> val) {
    UnionSize12Alignment4 result;
    result.set_variant(val);
    return result;
  }

  template <typename... Args>
  static UnionSize12Alignment4 WithVariant(::fidl::AnyArena& allocator,
                                           Args&&... args) {
    UnionSize12Alignment4 result;
    result.set_variant(::fidl::ObjectView<::fidl::Array<uint8_t, 6>>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_variant(::fidl::ObjectView<::fidl::Array<uint8_t, 6>> elem) {
    ordinal_ =
        ::test_unionsandwich::wire::UnionSize12Alignment4::Ordinal::kVariant;
    envelope_.As<::fidl::Array<uint8_t, 6>>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_variant(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ =
        ::test_unionsandwich::wire::UnionSize12Alignment4::Ordinal::kVariant;
    set_variant(::fidl::ObjectView<::fidl::Array<uint8_t, 6>>(
        allocator, std::forward<Args>(args)...));
  }

  ::fidl::Array<uint8_t, 6>& variant() {
    ZX_ASSERT(
        ordinal_ ==
        ::test_unionsandwich::wire::UnionSize12Alignment4::Ordinal::kVariant);
    return envelope_.As<::fidl::Array<uint8_t, 6>>().get_data();
  }
  const ::fidl::Array<uint8_t, 6>& variant() const {
    ZX_ASSERT(
        ordinal_ ==
        ::test_unionsandwich::wire::UnionSize12Alignment4::Ordinal::kVariant);
    return envelope_.As<::fidl::Array<uint8_t, 6>>().get_data();
  }
  ::test_unionsandwich::wire::UnionSize12Alignment4::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unionsandwich::wire::UnionSize12Alignment4::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kVariant = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unionsandwich::wire::UnionSize12Alignment4::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t test_unionsandwich_UnionSize24Alignment8Table;

class UnionSize24Alignment8 {
 public:
  UnionSize24Alignment8()
      : ordinal_(::test_unionsandwich::wire::UnionSize24Alignment8::Ordinal::
                     Invalid),
        envelope_ {}
  {}

  UnionSize24Alignment8(const UnionSize24Alignment8&) = default;
  UnionSize24Alignment8& operator=(const UnionSize24Alignment8&) = default;
  UnionSize24Alignment8(UnionSize24Alignment8&&) = default;
  UnionSize24Alignment8& operator=(UnionSize24Alignment8&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kVariant = 1,  // 0x1
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_unionsandwich::wire::UnionSize24Alignment8::Ordinal::Invalid;
  }

  bool is_variant() const {
    return ordinal_ ==
           ::test_unionsandwich::wire::UnionSize24Alignment8::Ordinal::kVariant;
  }
  static UnionSize24Alignment8 WithVariant(
      ::fidl::ObjectView<::test_unionsandwich::wire::StructSize16Alignment8>
          val) {
    UnionSize24Alignment8 result;
    result.set_variant(val);
    return result;
  }

  template <typename... Args>
  static UnionSize24Alignment8 WithVariant(::fidl::AnyArena& allocator,
                                           Args&&... args) {
    UnionSize24Alignment8 result;
    result.set_variant(
        ::fidl::ObjectView<::test_unionsandwich::wire::StructSize16Alignment8>(
            allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_variant(
      ::fidl::ObjectView<::test_unionsandwich::wire::StructSize16Alignment8>
          elem) {
    ordinal_ =
        ::test_unionsandwich::wire::UnionSize24Alignment8::Ordinal::kVariant;
    envelope_.As<::test_unionsandwich::wire::StructSize16Alignment8>().set_data(
        std::move(elem));
  }

  template <typename... Args>
  void set_variant(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ =
        ::test_unionsandwich::wire::UnionSize24Alignment8::Ordinal::kVariant;
    set_variant(
        ::fidl::ObjectView<::test_unionsandwich::wire::StructSize16Alignment8>(
            allocator, std::forward<Args>(args)...));
  }

  ::test_unionsandwich::wire::StructSize16Alignment8& variant() {
    ZX_ASSERT(
        ordinal_ ==
        ::test_unionsandwich::wire::UnionSize24Alignment8::Ordinal::kVariant);
    return envelope_.As<::test_unionsandwich::wire::StructSize16Alignment8>()
        .get_data();
  }
  const ::test_unionsandwich::wire::StructSize16Alignment8& variant() const {
    ZX_ASSERT(
        ordinal_ ==
        ::test_unionsandwich::wire::UnionSize24Alignment8::Ordinal::kVariant);
    return envelope_.As<::test_unionsandwich::wire::StructSize16Alignment8>()
        .get_data();
  }
  ::test_unionsandwich::wire::UnionSize24Alignment8::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unionsandwich::wire::UnionSize24Alignment8::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kVariant = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unionsandwich::wire::UnionSize24Alignment8::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_unionsandwich_SandwichUnionSize8Alignment4Table;

struct SandwichUnionSize8Alignment4 {
  uint32_t before = {};

  ::test_unionsandwich::wire::UnionSize8Alignment4 union_ = {};

  uint32_t after = {};
};

extern "C" const fidl_type_t
    test_unionsandwich_SandwichUnionSize36Alignment4Table;

struct SandwichUnionSize36Alignment4 {
  uint32_t before = {};

  ::test_unionsandwich::wire::UnionSize36Alignment4 union_ = {};

  uint32_t after = {};
};

extern "C" const fidl_type_t
    test_unionsandwich_SandwichUnionSize12Alignment4Table;

struct SandwichUnionSize12Alignment4 {
  uint32_t before = {};

  ::test_unionsandwich::wire::UnionSize12Alignment4 union_ = {};

  int32_t after = {};
};

extern "C" const fidl_type_t test_unionsandwich_StructSize16Alignment8Table;

struct StructSize16Alignment8 {
  uint64_t f1 = {};

  uint64_t f2 = {};
};

extern "C" const fidl_type_t
    test_unionsandwich_SandwichUnionSize24Alignment8Table;

struct SandwichUnionSize24Alignment8 {
  uint32_t before = {};

  ::test_unionsandwich::wire::UnionSize24Alignment8 union_ = {};

  uint32_t after = {};
};

}  // namespace wire
}  // namespace test_unionsandwich
namespace fidl {

template <>
struct TypeTraits<::test_unionsandwich::wire::SandwichUnionSize8Alignment4> {
  static constexpr const fidl_type_t* kType =
      &::test_unionsandwich::wire::
          test_unionsandwich_SandwichUnionSize8Alignment4Table;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 32;
  static constexpr uint32_t kPrimarySizeV1 = 40;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unionsandwich::wire::SandwichUnionSize8Alignment4>
    : public std::true_type {};
template <>
struct IsStruct<::test_unionsandwich::wire::SandwichUnionSize8Alignment4>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_unionsandwich::wire::SandwichUnionSize8Alignment4>);
static_assert(offsetof(::test_unionsandwich::wire::SandwichUnionSize8Alignment4,
                       before) == 0);
static_assert(offsetof(::test_unionsandwich::wire::SandwichUnionSize8Alignment4,
                       union_) == 8);
static_assert(offsetof(::test_unionsandwich::wire::SandwichUnionSize8Alignment4,
                       after) == 24);
static_assert(
    sizeof(::test_unionsandwich::wire::SandwichUnionSize8Alignment4) ==
    TypeTraits<::test_unionsandwich::wire::SandwichUnionSize8Alignment4>::
        kPrimarySize);

template <>
struct TypeTraits<::test_unionsandwich::wire::SandwichUnionSize36Alignment4> {
  static constexpr const fidl_type_t* kType =
      &::test_unionsandwich::wire::
          test_unionsandwich_SandwichUnionSize36Alignment4Table;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 32;
  static constexpr uint32_t kPrimarySizeV1 = 40;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 32;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unionsandwich::wire::SandwichUnionSize36Alignment4>
    : public std::true_type {};
template <>
struct IsStruct<::test_unionsandwich::wire::SandwichUnionSize36Alignment4>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_unionsandwich::wire::SandwichUnionSize36Alignment4>);
static_assert(
    offsetof(::test_unionsandwich::wire::SandwichUnionSize36Alignment4,
             before) == 0);
static_assert(
    offsetof(::test_unionsandwich::wire::SandwichUnionSize36Alignment4,
             union_) == 8);
static_assert(
    offsetof(::test_unionsandwich::wire::SandwichUnionSize36Alignment4,
             after) == 24);
static_assert(
    sizeof(::test_unionsandwich::wire::SandwichUnionSize36Alignment4) ==
    TypeTraits<::test_unionsandwich::wire::SandwichUnionSize36Alignment4>::
        kPrimarySize);

template <>
struct TypeTraits<::test_unionsandwich::wire::SandwichUnionSize12Alignment4> {
  static constexpr const fidl_type_t* kType =
      &::test_unionsandwich::wire::
          test_unionsandwich_SandwichUnionSize12Alignment4Table;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 32;
  static constexpr uint32_t kPrimarySizeV1 = 40;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unionsandwich::wire::SandwichUnionSize12Alignment4>
    : public std::true_type {};
template <>
struct IsStruct<::test_unionsandwich::wire::SandwichUnionSize12Alignment4>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_unionsandwich::wire::SandwichUnionSize12Alignment4>);
static_assert(
    offsetof(::test_unionsandwich::wire::SandwichUnionSize12Alignment4,
             before) == 0);
static_assert(
    offsetof(::test_unionsandwich::wire::SandwichUnionSize12Alignment4,
             union_) == 8);
static_assert(
    offsetof(::test_unionsandwich::wire::SandwichUnionSize12Alignment4,
             after) == 24);
static_assert(
    sizeof(::test_unionsandwich::wire::SandwichUnionSize12Alignment4) ==
    TypeTraits<::test_unionsandwich::wire::SandwichUnionSize12Alignment4>::
        kPrimarySize);

template <>
struct TypeTraits<::test_unionsandwich::wire::StructSize16Alignment8> {
  static constexpr const fidl_type_t* kType =
      &::test_unionsandwich::wire::
          test_unionsandwich_StructSize16Alignment8Table;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unionsandwich::wire::StructSize16Alignment8>
    : public std::true_type {};
template <>
struct IsStruct<::test_unionsandwich::wire::StructSize16Alignment8>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_unionsandwich::wire::StructSize16Alignment8>);
static_assert(offsetof(::test_unionsandwich::wire::StructSize16Alignment8,
                       f1) == 0);
static_assert(offsetof(::test_unionsandwich::wire::StructSize16Alignment8,
                       f2) == 8);
static_assert(sizeof(::test_unionsandwich::wire::StructSize16Alignment8) ==
              TypeTraits<::test_unionsandwich::wire::StructSize16Alignment8>::
                  kPrimarySize);

template <>
struct TypeTraits<::test_unionsandwich::wire::SandwichUnionSize24Alignment8> {
  static constexpr const fidl_type_t* kType =
      &::test_unionsandwich::wire::
          test_unionsandwich_SandwichUnionSize24Alignment8Table;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 32;
  static constexpr uint32_t kPrimarySizeV1 = 40;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 16;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unionsandwich::wire::SandwichUnionSize24Alignment8>
    : public std::true_type {};
template <>
struct IsStruct<::test_unionsandwich::wire::SandwichUnionSize24Alignment8>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_unionsandwich::wire::SandwichUnionSize24Alignment8>);
static_assert(
    offsetof(::test_unionsandwich::wire::SandwichUnionSize24Alignment8,
             before) == 0);
static_assert(
    offsetof(::test_unionsandwich::wire::SandwichUnionSize24Alignment8,
             union_) == 8);
static_assert(
    offsetof(::test_unionsandwich::wire::SandwichUnionSize24Alignment8,
             after) == 24);
static_assert(
    sizeof(::test_unionsandwich::wire::SandwichUnionSize24Alignment8) ==
    TypeTraits<::test_unionsandwich::wire::SandwichUnionSize24Alignment8>::
        kPrimarySize);

template <>
struct TypeTraits<::test_unionsandwich::wire::UnionSize8Alignment4> {
  static constexpr const fidl_type_t* kType =
      &::test_unionsandwich::wire::test_unionsandwich_UnionSize8Alignment4Table;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unionsandwich::wire::UnionSize8Alignment4>
    : public std::true_type {};
template <>
struct IsUnion<::test_unionsandwich::wire::UnionSize8Alignment4>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_unionsandwich::wire::UnionSize8Alignment4>);

template <>
struct TypeTraits<::test_unionsandwich::wire::UnionSize36Alignment4> {
  static constexpr const fidl_type_t* kType =
      &::test_unionsandwich::wire::
          test_unionsandwich_UnionSize36Alignment4Table;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 32;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unionsandwich::wire::UnionSize36Alignment4>
    : public std::true_type {};
template <>
struct IsUnion<::test_unionsandwich::wire::UnionSize36Alignment4>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_unionsandwich::wire::UnionSize36Alignment4>);

template <>
struct TypeTraits<::test_unionsandwich::wire::UnionSize12Alignment4> {
  static constexpr const fidl_type_t* kType =
      &::test_unionsandwich::wire::
          test_unionsandwich_UnionSize12Alignment4Table;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unionsandwich::wire::UnionSize12Alignment4>
    : public std::true_type {};
template <>
struct IsUnion<::test_unionsandwich::wire::UnionSize12Alignment4>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_unionsandwich::wire::UnionSize12Alignment4>);

template <>
struct TypeTraits<::test_unionsandwich::wire::UnionSize24Alignment8> {
  static constexpr const fidl_type_t* kType =
      &::test_unionsandwich::wire::
          test_unionsandwich_UnionSize24Alignment8Table;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 16;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unionsandwich::wire::UnionSize24Alignment8>
    : public std::true_type {};
template <>
struct IsUnion<::test_unionsandwich::wire::UnionSize24Alignment8>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_unionsandwich::wire::UnionSize24Alignment8>);

}  // namespace fidl
