// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/llcpp/traits.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>

namespace test_anonymous {
// |Flags| is flexible, hence may contain unknown members not
// defined in the FIDL schema.
class Flags final {
 public:
  constexpr Flags() = default;

  // Constructs an instance of |Flags| from an underlying primitive value,
  // preserving any bit member not defined in the FIDL schema.
  explicit constexpr Flags(uint16_t value) : value_(value) {}
  const static Flags kInline;
  const static Flags kMask;

  explicit constexpr inline operator uint16_t() const { return value_; }
  explicit constexpr inline operator bool() const {
    return static_cast<bool>(value_);
  }
  constexpr inline bool operator==(const Flags& other) const {
    return value_ == other.value_;
  }
  constexpr inline bool operator!=(const Flags& other) const {
    return value_ != other.value_;
  }
  constexpr inline Flags operator~() const;
  constexpr inline Flags operator|(const Flags& other) const;
  constexpr inline Flags operator&(const Flags& other) const;
  constexpr inline Flags operator^(const Flags& other) const;
  constexpr inline void operator|=(const Flags& other);
  constexpr inline void operator&=(const Flags& other);
  constexpr inline void operator^=(const Flags& other);

  // Constructs an instance of |Flags| from an underlying primitive value
  // if the primitive does not contain any unknown members not defined in the
  // FIDL schema. Otherwise, returns |cpp17::nullopt|.
  constexpr inline static cpp17::optional<Flags> TryFrom(uint16_t value) {
    if (value & ~kMask.value_) {
      return cpp17::nullopt;
    }
    return Flags(value & Flags::kMask.value_);
  }

  // Constructs an instance of |Flags| from an underlying primitive value,
  // clearing any bit member not defined in the FIDL schema.
  constexpr inline static Flags TruncatingUnknown(uint16_t value) {
    return Flags(value & Flags::kMask.value_);
  }
  constexpr inline Flags unknown_bits() const {
    return *this & Flags(~kMask.value_);
  }
  constexpr inline bool has_unknown_bits() const {
    return static_cast<bool>(unknown_bits());
  }

 private:
  uint16_t value_ = 0;
};
constexpr const ::test_anonymous::Flags Flags::kInline =
    ::test_anonymous::Flags(1u);
constexpr const ::test_anonymous::Flags Flags::kMask =
    ::test_anonymous::Flags(1u);

constexpr inline ::test_anonymous::Flags Flags::operator~() const {
  return ::test_anonymous::Flags(
      static_cast<uint16_t>(~this->value_ & kMask.value_));
}

constexpr inline ::test_anonymous::Flags Flags::operator|(
    const ::test_anonymous::Flags& other) const {
  return ::test_anonymous::Flags(
      static_cast<uint16_t>(this->value_ | other.value_));
}

constexpr inline ::test_anonymous::Flags Flags::operator&(
    const ::test_anonymous::Flags& other) const {
  return ::test_anonymous::Flags(
      static_cast<uint16_t>(this->value_ & other.value_));
}

constexpr inline ::test_anonymous::Flags Flags::operator^(
    const ::test_anonymous::Flags& other) const {
  return ::test_anonymous::Flags(
      static_cast<uint16_t>(this->value_ ^ other.value_));
}

constexpr inline void Flags::operator|=(const ::test_anonymous::Flags& other) {
  this->value_ |= other.value_;
}

constexpr inline void Flags::operator&=(const ::test_anonymous::Flags& other) {
  this->value_ &= other.value_;
}

constexpr inline void Flags::operator^=(const ::test_anonymous::Flags& other) {
  this->value_ ^= other.value_;
}

// |BitsMember| is flexible, hence may contain unknown members not
// defined in the FIDL schema.
class BitsMember final {
 public:
  constexpr BitsMember() = default;

  // Constructs an instance of |BitsMember| from an underlying primitive value,
  // preserving any bit member not defined in the FIDL schema.
  explicit constexpr BitsMember(uint32_t value) : value_(value) {}
  const static BitsMember kBitOne;
  const static BitsMember kBitTwo;
  const static BitsMember kMask;

  explicit constexpr inline operator uint32_t() const { return value_; }
  explicit constexpr inline operator bool() const {
    return static_cast<bool>(value_);
  }
  constexpr inline bool operator==(const BitsMember& other) const {
    return value_ == other.value_;
  }
  constexpr inline bool operator!=(const BitsMember& other) const {
    return value_ != other.value_;
  }
  constexpr inline BitsMember operator~() const;
  constexpr inline BitsMember operator|(const BitsMember& other) const;
  constexpr inline BitsMember operator&(const BitsMember& other) const;
  constexpr inline BitsMember operator^(const BitsMember& other) const;
  constexpr inline void operator|=(const BitsMember& other);
  constexpr inline void operator&=(const BitsMember& other);
  constexpr inline void operator^=(const BitsMember& other);

  // Constructs an instance of |BitsMember| from an underlying primitive value
  // if the primitive does not contain any unknown members not defined in the
  // FIDL schema. Otherwise, returns |cpp17::nullopt|.
  constexpr inline static cpp17::optional<BitsMember> TryFrom(uint32_t value) {
    if (value & ~kMask.value_) {
      return cpp17::nullopt;
    }
    return BitsMember(value & BitsMember::kMask.value_);
  }

  // Constructs an instance of |BitsMember| from an underlying primitive value,
  // clearing any bit member not defined in the FIDL schema.
  constexpr inline static BitsMember TruncatingUnknown(uint32_t value) {
    return BitsMember(value & BitsMember::kMask.value_);
  }
  constexpr inline BitsMember unknown_bits() const {
    return *this & BitsMember(~kMask.value_);
  }
  constexpr inline bool has_unknown_bits() const {
    return static_cast<bool>(unknown_bits());
  }

 private:
  uint32_t value_ = 0;
};
constexpr const ::test_anonymous::BitsMember BitsMember::kBitOne =
    ::test_anonymous::BitsMember(1u);
constexpr const ::test_anonymous::BitsMember BitsMember::kBitTwo =
    ::test_anonymous::BitsMember(2u);
constexpr const ::test_anonymous::BitsMember BitsMember::kMask =
    ::test_anonymous::BitsMember(3u);

constexpr inline ::test_anonymous::BitsMember BitsMember::operator~() const {
  return ::test_anonymous::BitsMember(
      static_cast<uint32_t>(~this->value_ & kMask.value_));
}

constexpr inline ::test_anonymous::BitsMember BitsMember::operator|(
    const ::test_anonymous::BitsMember& other) const {
  return ::test_anonymous::BitsMember(
      static_cast<uint32_t>(this->value_ | other.value_));
}

constexpr inline ::test_anonymous::BitsMember BitsMember::operator&(
    const ::test_anonymous::BitsMember& other) const {
  return ::test_anonymous::BitsMember(
      static_cast<uint32_t>(this->value_ & other.value_));
}

constexpr inline ::test_anonymous::BitsMember BitsMember::operator^(
    const ::test_anonymous::BitsMember& other) const {
  return ::test_anonymous::BitsMember(
      static_cast<uint32_t>(this->value_ ^ other.value_));
}

constexpr inline void BitsMember::operator|=(
    const ::test_anonymous::BitsMember& other) {
  this->value_ |= other.value_;
}

constexpr inline void BitsMember::operator&=(
    const ::test_anonymous::BitsMember& other) {
  this->value_ &= other.value_;
}

constexpr inline void BitsMember::operator^=(
    const ::test_anonymous::BitsMember& other) {
  this->value_ ^= other.value_;
}

class SomeProtocol_SomeMethod_Error final {
 public:
  constexpr SomeProtocol_SomeMethod_Error() : value_(0) {}
  constexpr explicit SomeProtocol_SomeMethod_Error(uint32_t value)
      : value_(value) {}
  constexpr operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    switch (value_) {
      case 1u:

      case 2u:

        return false;
    }
    return true;
  }

  constexpr static SomeProtocol_SomeMethod_Error Unknown() {
    return SomeProtocol_SomeMethod_Error(0xffffffff);
  }

  static const SomeProtocol_SomeMethod_Error kErrorOne;

  static const SomeProtocol_SomeMethod_Error kErrorTwo;

 private:
  uint32_t value_;
};
constexpr const ::test_anonymous::SomeProtocol_SomeMethod_Error
    SomeProtocol_SomeMethod_Error::kErrorOne =
        ::test_anonymous::SomeProtocol_SomeMethod_Error(1u);
constexpr const ::test_anonymous::SomeProtocol_SomeMethod_Error
    SomeProtocol_SomeMethod_Error::kErrorTwo =
        ::test_anonymous::SomeProtocol_SomeMethod_Error(2u);

class Op final {
 public:
  constexpr Op() : value_(0) {}
  constexpr explicit Op(uint32_t value) : value_(value) {}
  constexpr operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    switch (value_) {
      case 1u:

      case 2u:

      case 3u:

        return false;
    }
    return true;
  }

  constexpr static Op Unknown() { return Op(0xffffffff); }

  static const Op kAdd;

  static const Op kMul;

  static const Op kDiv;

 private:
  uint32_t value_;
};
constexpr const ::test_anonymous::Op Op::kAdd = ::test_anonymous::Op(1u);
constexpr const ::test_anonymous::Op Op::kMul = ::test_anonymous::Op(2u);
constexpr const ::test_anonymous::Op Op::kDiv = ::test_anonymous::Op(3u);

}  // namespace test_anonymous
namespace fidl {

template <>
struct IsFidlType<::test_anonymous::Flags> : public std::true_type {};
template <>
struct ContainsHandle<::test_anonymous::Flags> : public std::false_type {};
static_assert(std::is_standard_layout_v<::test_anonymous::Flags>);
static_assert(sizeof(::test_anonymous::Flags) == sizeof(uint16_t));

template <>
struct IsFidlType<::test_anonymous::BitsMember> : public std::true_type {};
template <>
struct ContainsHandle<::test_anonymous::BitsMember> : public std::false_type {};
static_assert(std::is_standard_layout_v<::test_anonymous::BitsMember>);
static_assert(sizeof(::test_anonymous::BitsMember) == sizeof(uint32_t));

template <>
struct IsFidlType<::test_anonymous::SomeProtocol_SomeMethod_Error>
    : public std::true_type {};
template <>
struct ContainsHandle<::test_anonymous::SomeProtocol_SomeMethod_Error>
    : public std::false_type {};

template <>
struct IsFidlType<::test_anonymous::Op> : public std::true_type {};
template <>
struct ContainsHandle<::test_anonymous::Op> : public std::false_type {};

}  // namespace fidl
