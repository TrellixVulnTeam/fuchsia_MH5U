// WARNING: This file is machine generated by fidlgen_llcpp.

#pragma once

#include <fidl/test.protocols/cpp/markers.h>
#include <fidl/test.protocols/cpp/natural_types.h>
#include <lib/fidl/cpp/channel.h>
#include <lib/fidl/cpp/client.h>
#include <lib/fidl/cpp/internal/message_extensions.h>
#include <lib/fidl/cpp/internal/natural_client_messenger.h>
#include <lib/fidl/cpp/internal/natural_server_messenger.h>
#include <lib/fidl/cpp/natural_types.h>
#include <lib/fidl/cpp/unified_messaging.h>

namespace fidl {}  // namespace fidl
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolAnEventRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent>> {
 public:
  Event() = default;
  ~Event() = default;
  Event(Event&&) noexcept = default;
  Event& operator=(Event&&) noexcept = default;
  Event(::test_protocols::HandleRightsProtocolAnEventRequest payload)
      : payload_(std::move(payload)) {}
  Event(const Event&) noexcept = delete;
  Event& operator=(const Event&) noexcept = delete;
  ::test_protocols::HandleRightsProtocolAnEventRequest* operator->() {
    return &payload_;
  }
  const ::test_protocols::HandleRightsProtocolAnEventRequest* operator->()
      const {
    return &payload_;
  }
  ::test_protocols::HandleRightsProtocolAnEventRequest& operator*() {
    return payload_;
  }
  const ::test_protocols::HandleRightsProtocolAnEventRequest& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocols::HandleRightsProtocolAnEventRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::HandleRightsProtocolAnEventRequest;
};
namespace test_protocols {}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::HandleRightsProtocol::ResponseMethod>
    final : public ::fidl::internal::MessageBase<::fidl::Response<
                ::test_protocols::HandleRightsProtocol::ResponseMethod>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(
      ::test_protocols::HandleRightsProtocolResponseMethodTopResponse payload)
      : payload_(std::move(payload)) {}
  Response(const Response&) noexcept = delete;
  Response& operator=(const Response&) noexcept = delete;
  ::test_protocols::HandleRightsProtocolResponseMethodTopResponse*
  operator->() {
    return &payload_;
  }
  const ::test_protocols::HandleRightsProtocolResponseMethodTopResponse*
  operator->() const {
    return &payload_;
  }
  ::test_protocols::HandleRightsProtocolResponseMethodTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::HandleRightsProtocolResponseMethodTopResponse&
  operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::HandleRightsProtocolResponseMethodTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::HandleRightsProtocol::ResponseMethod>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload =
      ::test_protocols::HandleRightsProtocolResponseMethodTopResponse;
};
namespace test_protocols {}  // namespace test_protocols
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<::fidl::Error,
                     ::fidl::Response<::test_protocols::HandleRightsProtocol::
                                          ResponseMethod>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>&)>;
};

template <>
class ::fidl::internal::NaturalClientImpl<
    ::test_protocols::HandleRightsProtocol>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void ResponseMethod(
      ::test_protocols::HandleRightsProtocolResponseMethodRequest&& payload,
      ::fidl::ClientCallback<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>&& _callback)
      const;

  void ResponseMethod(
      ::test_protocols::HandleRightsProtocolResponseMethodRequest&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>&& _callback)
      const;

  ::fitx::result<::fidl::Error> NoResponseMethod(
      ::test_protocols::HandleRightsProtocolNoResponseMethodRequest&& payload)
      const;
};
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::HandleRightsProtocol> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void AnEvent(
      ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent>&) {}
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::HandleRightsProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::HandleRightsProtocol>
    final
    : public ::fidl::internal::IncomingEventDispatcher<
          ::fidl::AsyncEventHandler<::test_protocols::HandleRightsProtocol>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::HandleRightsProtocol>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<
    ::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  ::fitx::result<::fidl::Error> AnEvent(
      ::test_protocols::HandleRightsProtocolAnEventRequest payload);
};

template <>
class ::fidl::internal::NaturalEventSender<
    ::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocols::HandleRightsProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  ::fitx::result<::fidl::Error> AnEvent(
      ::test_protocols::HandleRightsProtocolAnEventRequest payload);
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::HandleRightsProtocol::NoResponseMethod>
    final : public ::fidl::internal::MessageBase<::fidl::Request<
                ::test_protocols::HandleRightsProtocol::NoResponseMethod>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocols::HandleRightsProtocolNoResponseMethodRequest payload)
      : payload_(std::move(payload)) {}
  Request(const Request&) noexcept = delete;
  Request& operator=(const Request&) noexcept = delete;
  ::test_protocols::HandleRightsProtocolNoResponseMethodRequest* operator->() {
    return &payload_;
  }
  const ::test_protocols::HandleRightsProtocolNoResponseMethodRequest*
  operator->() const {
    return &payload_;
  }
  ::test_protocols::HandleRightsProtocolNoResponseMethodRequest& operator*() {
    return payload_;
  }
  const ::test_protocols::HandleRightsProtocolNoResponseMethodRequest&
  operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::HandleRightsProtocolNoResponseMethodRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::HandleRightsProtocol::NoResponseMethod>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::HandleRightsProtocolNoResponseMethodRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::HandleRightsProtocol::ResponseMethod>
    final : public ::fidl::internal::MessageBase<::fidl::Request<
                ::test_protocols::HandleRightsProtocol::ResponseMethod>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocols::HandleRightsProtocolResponseMethodRequest payload)
      : payload_(std::move(payload)) {}
  Request(const Request&) noexcept = delete;
  Request& operator=(const Request&) noexcept = delete;
  ::test_protocols::HandleRightsProtocolResponseMethodRequest* operator->() {
    return &payload_;
  }
  const ::test_protocols::HandleRightsProtocolResponseMethodRequest*
  operator->() const {
    return &payload_;
  }
  ::test_protocols::HandleRightsProtocolResponseMethodRequest& operator*() {
    return payload_;
  }
  const ::test_protocols::HandleRightsProtocolResponseMethodRequest& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocols::HandleRightsProtocolResponseMethodRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::HandleRightsProtocol::ResponseMethod>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::HandleRightsProtocolResponseMethodRequest;
};
#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>
    : public ::fidl::CompleterBase {
 public:
  void Reply(::test_protocols::HandleRightsProtocolResponseMethodTopResponse&&
                 payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocols::HandleRightsProtocol::ResponseMethod> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>>;
};

template <>
class ::fidl::Server<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::HandleRightsProtocol;

  using NoResponseMethodRequest =
      ::fidl::Request<::test_protocols::HandleRightsProtocol::NoResponseMethod>;
  using NoResponseMethodCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::HandleRightsProtocol::NoResponseMethod>;

  virtual void NoResponseMethod(NoResponseMethodRequest& request,
                                NoResponseMethodCompleter::Sync& completer) = 0;

  using ResponseMethodRequest =
      ::fidl::Request<::test_protocols::HandleRightsProtocol::ResponseMethod>;
  using ResponseMethodCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>;

  virtual void ResponseMethod(ResponseMethodRequest& request,
                              ResponseMethodCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<
    ::test_protocols::HandleRightsProtocol>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(
      ::fidl::Server<::test_protocols::HandleRightsProtocol>* impl,
      ::fidl::IncomingMessage&& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

namespace test_protocols {
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Event<
    ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
    final
    : public ::fidl::internal::MessageBase<::fidl::Event<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>> {
 public:
  Event() = default;
  ~Event() = default;
  Event(Event&&) noexcept = default;
  Event& operator=(Event&&) noexcept = default;

 private:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Event<
    ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
namespace test_protocols {}  // namespace test_protocols

template <>
class ::fidl::Event<
    ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>
    final
    : public ::fidl::internal::MessageBase<::fidl::Event<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>> {
 public:
  Event() = default;
  ~Event() = default;
  Event(Event&&) noexcept = default;
  Event& operator=(Event&&) noexcept = default;
  Event(::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest
            payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest*
  operator->() {
    return &payload_;
  }
  const ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest*
  operator->() const {
    return &payload_;
  }
  ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest&
  operator*() {
    return payload_;
  }
  const ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest&
  operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Event<
    ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload =
      ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest;
};
namespace test_protocols {}  // namespace test_protocols

template <>
class ::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestEmptyResponse>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;

 private:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
namespace test_protocols {}  // namespace test_protocols
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestEmptyResponse>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                           NoRequestEmptyResponse>&)>;
};

template <>
class ::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestWithResponse>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(
      ::test_protocols::
          WithAndWithoutRequestResponseNoRequestWithResponseTopResponse payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse*
      operator->() {
    return &payload_;
  }
  const ::test_protocols::
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse*
      operator->() const {
    return &payload_;
  }
  ::test_protocols::
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse&
      operator*() {
    return payload_;
  }
  const ::test_protocols::
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse&
      operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestWithResponse>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                           NoRequestWithResponse>&)>;
};

template <>
class ::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestEmptyResponse>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;

 private:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestEmptyResponse>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                           WithRequestEmptyResponse>&)>;
};

template <>
class ::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestWithResponse>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::
               WithAndWithoutRequestResponseWithRequestWithResponseTopResponse
                   payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse*
      operator->() {
    return &payload_;
  }
  const ::test_protocols::
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse*
      operator->() const {
    return &payload_;
  }
  ::test_protocols::
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse&
      operator*() {
    return payload_;
  }
  const ::test_protocols::
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse&
      operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestWithResponse>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                           WithRequestWithResponse>&)>;
};

template <>
class ::fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void NoRequestEmptyResponse(
      ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                 NoRequestEmptyResponse>&& _callback) const;

  void NoRequestEmptyResponse(::fidl::ClientResponseCallback<
                              ::test_protocols::WithAndWithoutRequestResponse::
                                  NoRequestEmptyResponse>&& _callback) const;

  void NoRequestWithResponse(
      ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                 NoRequestWithResponse>&& _callback) const;

  void NoRequestWithResponse(::fidl::ClientResponseCallback<
                             ::test_protocols::WithAndWithoutRequestResponse::
                                 NoRequestWithResponse>&& _callback) const;

  void WithRequestEmptyResponse(
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&&
              payload,
      ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                 WithRequestEmptyResponse>&& _callback) const;

  void WithRequestEmptyResponse(
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&&
              payload,
      ::fidl::ClientResponseCallback<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>&& _callback) const;

  void WithRequestWithResponse(
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseRequest&& payload,
      ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                 WithRequestWithResponse>&& _callback) const;

  void WithRequestWithResponse(
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseRequest&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>&& _callback) const;

  ::fitx::result<::fidl::Error> NoRequestNoResponse() const;

  ::fitx::result<::fidl::Error> WithRequestNoResponse(
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestNoResponseRequest&& payload)
      const;
};
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::WithAndWithoutRequestResponse> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void OnEmptyResponse(
      ::fidl::Event<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>&) {}
  virtual void OnWithResponse(
      ::fidl::Event<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>&) {}
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::WithAndWithoutRequestResponse>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<
                    ::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<
          ::test_protocols::WithAndWithoutRequestResponse>* event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  ::fitx::result<::fidl::Error> OnEmptyResponse();

  ::fitx::result<::fidl::Error> OnWithResponse(
      ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest
          payload);
};

template <>
class ::fidl::internal::NaturalEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  ::fitx::result<::fidl::Error> OnEmptyResponse();

  ::fitx::result<::fidl::Error> OnWithResponse(
      ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest
          payload);
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
    final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                              NoRequestNoResponse>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;

 private:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                              NoRequestEmptyResponse>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;

 private:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                              NoRequestWithResponse>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;

 private:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
    final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                              WithRequestNoResponse>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocols::
              WithAndWithoutRequestResponseWithRequestNoResponseRequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest*
  operator->() {
    return &payload_;
  }
  const ::test_protocols::
      WithAndWithoutRequestResponseWithRequestNoResponseRequest*
      operator->() const {
    return &payload_;
  }
  ::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest&
  operator*() {
    return payload_;
  }
  const ::test_protocols::
      WithAndWithoutRequestResponseWithRequestNoResponseRequest&
      operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest
      payload_;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::
      WithAndWithoutRequestResponseWithRequestNoResponseRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                              WithRequestEmptyResponse>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestEmptyResponseRequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::
      WithAndWithoutRequestResponseWithRequestEmptyResponseRequest*
      operator->() {
    return &payload_;
  }
  const ::test_protocols::
      WithAndWithoutRequestResponseWithRequestEmptyResponseRequest*
      operator->() const {
    return &payload_;
  }
  ::test_protocols::
      WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&
      operator*() {
    return payload_;
  }
  const ::test_protocols::
      WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&
      operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
      payload_;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::
      WithAndWithoutRequestResponseWithRequestEmptyResponseRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                              WithRequestWithResponse>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseRequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest*
  operator->() {
    return &payload_;
  }
  const ::test_protocols::
      WithAndWithoutRequestResponseWithRequestWithResponseRequest*
      operator->() const {
    return &payload_;
  }
  ::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest&
  operator*() {
    return payload_;
  }
  const ::test_protocols::
      WithAndWithoutRequestResponseWithRequestWithResponseRequest&
      operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest
      payload_;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::
      WithAndWithoutRequestResponseWithRequestWithResponseRequest;
};
#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    : public ::fidl::CompleterBase {
 public:
  void Reply();

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    : public ::fidl::CompleterBase {
 public:
  void Reply(::test_protocols::
                 WithAndWithoutRequestResponseNoRequestWithResponseTopResponse&&
                     payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    : public ::fidl::CompleterBase {
 public:
  void Reply();

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>>;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseTopResponse&&
              payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>>;
};

template <>
class ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithAndWithoutRequestResponse;

  using NoRequestNoResponseRequest = ::fidl::Request<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>;
  using NoRequestNoResponseCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>;

  virtual void NoRequestNoResponse(
      NoRequestNoResponseRequest& request,
      NoRequestNoResponseCompleter::Sync& completer) = 0;

  using NoRequestEmptyResponseRequest = ::fidl::Request<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>;
  using NoRequestEmptyResponseCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>;

  virtual void NoRequestEmptyResponse(
      NoRequestEmptyResponseRequest& request,
      NoRequestEmptyResponseCompleter::Sync& completer) = 0;

  using NoRequestWithResponseRequest = ::fidl::Request<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>;
  using NoRequestWithResponseCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>;

  virtual void NoRequestWithResponse(
      NoRequestWithResponseRequest& request,
      NoRequestWithResponseCompleter::Sync& completer) = 0;

  using WithRequestNoResponseRequest = ::fidl::Request<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>;
  using WithRequestNoResponseCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>;

  virtual void WithRequestNoResponse(
      WithRequestNoResponseRequest& request,
      WithRequestNoResponseCompleter::Sync& completer) = 0;

  using WithRequestEmptyResponseRequest =
      ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                          WithRequestEmptyResponse>;
  using WithRequestEmptyResponseCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>;

  virtual void WithRequestEmptyResponse(
      WithRequestEmptyResponseRequest& request,
      WithRequestEmptyResponseCompleter::Sync& completer) = 0;

  using WithRequestWithResponseRequest = ::fidl::Request<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>;
  using WithRequestWithResponseCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>;

  virtual void WithRequestWithResponse(
      WithRequestWithResponseRequest& request,
      WithRequestWithResponseCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(
      ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>* impl,
      ::fidl::IncomingMessage&& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

namespace test_protocols {
__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalRequestRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalRequestTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalOneWayRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalEventRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Event<::test_protocols::Transitional::Event> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Event<::test_protocols::Transitional::Event>> {
 public:
  Event() = default;
  ~Event() = default;
  Event(Event&&) noexcept = default;
  Event& operator=(Event&&) noexcept = default;
  Event(::test_protocols::TransitionalEventRequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::TransitionalEventRequest* operator->() { return &payload_; }
  const ::test_protocols::TransitionalEventRequest* operator->() const {
    return &payload_;
  }
  ::test_protocols::TransitionalEventRequest& operator*() { return payload_; }
  const ::test_protocols::TransitionalEventRequest& operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::TransitionalEventRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocols::Transitional::Event>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::TransitionalEventRequest;
};
namespace test_protocols {}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::Transitional::Request> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::Transitional::Request>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::TransitionalRequestTopResponse payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::TransitionalRequestTopResponse* operator->() {
    return &payload_;
  }
  const ::test_protocols::TransitionalRequestTopResponse* operator->() const {
    return &payload_;
  }
  ::test_protocols::TransitionalRequestTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::TransitionalRequestTopResponse& operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::TransitionalRequestTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::Transitional::Request>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::TransitionalRequestTopResponse;
};
namespace test_protocols {}  // namespace test_protocols
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::Transitional::Request>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::Transitional::Request>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::Transitional::Request>&)>;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::Transitional> final
    : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void Request(::test_protocols::TransitionalRequestRequest&& payload,
               ::fidl::ClientCallback<::test_protocols::Transitional::Request>&&
                   _callback) const;

  void Request(
      ::test_protocols::TransitionalRequestRequest&& payload,
      ::fidl::ClientResponseCallback<::test_protocols::Transitional::Request>&&
          _callback) const;

  ::fitx::result<::fidl::Error> OneWay(
      ::test_protocols::TransitionalOneWayRequest&& payload) const;
};
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::Transitional> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void Event(::fidl::Event<::test_protocols::Transitional::Event>&) {}
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::Transitional>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::Transitional>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::Transitional>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<::test_protocols::Transitional>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::Transitional>* event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::Transitional>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  ::fitx::result<::fidl::Error> Event(
      ::test_protocols::TransitionalEventRequest payload);
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::Transitional>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocols::Transitional>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  ::fitx::result<::fidl::Error> Event(
      ::test_protocols::TransitionalEventRequest payload);
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::Transitional::Request> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocols::Transitional::Request>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocols::TransitionalRequestRequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::TransitionalRequestRequest* operator->() {
    return &payload_;
  }
  const ::test_protocols::TransitionalRequestRequest* operator->() const {
    return &payload_;
  }
  ::test_protocols::TransitionalRequestRequest& operator*() { return payload_; }
  const ::test_protocols::TransitionalRequestRequest& operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::TransitionalRequestRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::Transitional::Request>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::TransitionalRequestRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::Transitional::OneWay> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocols::Transitional::OneWay>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocols::TransitionalOneWayRequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::TransitionalOneWayRequest* operator->() {
    return &payload_;
  }
  const ::test_protocols::TransitionalOneWayRequest* operator->() const {
    return &payload_;
  }
  ::test_protocols::TransitionalOneWayRequest& operator*() { return payload_; }
  const ::test_protocols::TransitionalOneWayRequest& operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::TransitionalOneWayRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::Transitional::OneWay>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::TransitionalOneWayRequest;
};
#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::Transitional::Request> : public ::fidl::CompleterBase {
 public:
  void Reply(::test_protocols::TransitionalRequestTopResponse&& payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<::test_protocols::Transitional::Request> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::Transitional::Request>>;
};

template <>
class ::fidl::Server<::test_protocols::Transitional>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::Transitional;

  using RequestRequest =
      ::fidl::Request<::test_protocols::Transitional::Request>;
  using RequestCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::Transitional::Request>;

  virtual void Request(RequestRequest& request,
                       RequestCompleter::Sync& completer) {
    completer.Close(ZX_ERR_NOT_SUPPORTED);
  }

  using OneWayRequest = ::fidl::Request<::test_protocols::Transitional::OneWay>;
  using OneWayCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::Transitional::OneWay>;

  virtual void OneWay(OneWayRequest& request,
                      OneWayCompleter::Sync& completer) {
    completer.Close(ZX_ERR_NOT_SUPPORTED);
  }

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::Transitional>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::Transitional>* impl,
                       ::fidl::IncomingMessage&& msg,
                       internal::IncomingTransportContext transport_context,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

namespace test_protocols {
__LOCAL extern "C" const fidl_type_t
    test_protocols_MethodWithUnionUnionMethodRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocols
template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::MethodWithUnion>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fitx::result<::fidl::Error> UnionMethod(
      ::test_protocols::MethodWithUnionUnionMethodRequest&& payload) const;
};
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::MethodWithUnion> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::MethodWithUnion>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::MethodWithUnion>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<::test_protocols::MethodWithUnion>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::MethodWithUnion>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<
    ::test_protocols::MethodWithUnion>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocols::MethodWithUnion>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocols::MethodWithUnionUnionMethodRequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::MethodWithUnionUnionMethodRequest* operator->() {
    return &payload_;
  }
  const ::test_protocols::MethodWithUnionUnionMethodRequest* operator->()
      const {
    return &payload_;
  }
  ::test_protocols::MethodWithUnionUnionMethodRequest& operator*() {
    return payload_;
  }
  const ::test_protocols::MethodWithUnionUnionMethodRequest& operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::MethodWithUnionUnionMethodRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::MethodWithUnionUnionMethodRequest;
};
#endif  // __Fuchsia__

template <>
class ::fidl::Server<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::MethodWithUnion;

  using UnionMethodRequest =
      ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod>;
  using UnionMethodCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::MethodWithUnion::UnionMethod>;

  virtual void UnionMethod(UnionMethodRequest& request,
                           UnionMethodCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<
    ::test_protocols::MethodWithUnion>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::MethodWithUnion>* impl,
                       ::fidl::IncomingMessage&& msg,
                       internal::IncomingTransportContext transport_context,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

namespace test_protocols {
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::WithProtocolEndsClientEndsTopResponse payload)
      : payload_(std::move(payload)) {}
  Response(const Response&) noexcept = delete;
  Response& operator=(const Response&) noexcept = delete;
  ::test_protocols::WithProtocolEndsClientEndsTopResponse* operator->() {
    return &payload_;
  }
  const ::test_protocols::WithProtocolEndsClientEndsTopResponse* operator->()
      const {
    return &payload_;
  }
  ::test_protocols::WithProtocolEndsClientEndsTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::WithProtocolEndsClientEndsTopResponse& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocols::WithProtocolEndsClientEndsTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithProtocolEndsClientEndsTopResponse;
};
namespace test_protocols {}  // namespace test_protocols
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithProtocolEnds::ClientEnds>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>&)>;
};

template <>
class ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::WithProtocolEndsServerEndsTopResponse payload)
      : payload_(std::move(payload)) {}
  Response(const Response&) noexcept = delete;
  Response& operator=(const Response&) noexcept = delete;
  ::test_protocols::WithProtocolEndsServerEndsTopResponse* operator->() {
    return &payload_;
  }
  const ::test_protocols::WithProtocolEndsServerEndsTopResponse* operator->()
      const {
    return &payload_;
  }
  ::test_protocols::WithProtocolEndsServerEndsTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::WithProtocolEndsServerEndsTopResponse& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocols::WithProtocolEndsServerEndsTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithProtocolEndsServerEndsTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithProtocolEnds::ServerEnds>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>&)>;
};

template <>
class ::fidl::Response<::test_protocols::WithProtocolEnds::StructContainingEnds>
    final : public ::fidl::internal::MessageBase<::fidl::Response<
                ::test_protocols::WithProtocolEnds::StructContainingEnds>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(
      ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse payload)
      : payload_(std::move(payload)) {}
  Response(const Response&) noexcept = delete;
  Response& operator=(const Response&) noexcept = delete;
  ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse*
  operator->() {
    return &payload_;
  }
  const ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse*
  operator->() const {
    return &payload_;
  }
  ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse&
  operator*() {
    return payload_;
  }
  const ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse&
  operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithProtocolEnds::StructContainingEnds>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload =
      ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<::fidl::Error,
                     ::fidl::Response<::test_protocols::WithProtocolEnds::
                                          StructContainingEnds>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>&)>;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void ClientEnds(
      ::test_protocols::WithProtocolEndsClientEndsRequest&& payload,
      ::fidl::ClientCallback<::test_protocols::WithProtocolEnds::ClientEnds>&&
          _callback) const;

  void ClientEnds(
      ::test_protocols::WithProtocolEndsClientEndsRequest&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocols::WithProtocolEnds::ClientEnds>&& _callback) const;

  void ServerEnds(
      ::test_protocols::WithProtocolEndsServerEndsRequest&& payload,
      ::fidl::ClientCallback<::test_protocols::WithProtocolEnds::ServerEnds>&&
          _callback) const;

  void ServerEnds(
      ::test_protocols::WithProtocolEndsServerEndsRequest&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocols::WithProtocolEnds::ServerEnds>&& _callback) const;

  void StructContainingEnds(
      ::test_protocols::WithProtocolEndsStructContainingEndsRequest&& payload,
      ::fidl::ClientCallback<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>&& _callback)
      const;

  void StructContainingEnds(
      ::test_protocols::WithProtocolEndsStructContainingEndsRequest&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>&& _callback)
      const;
};
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::WithProtocolEnds> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::WithProtocolEnds>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::WithProtocolEnds>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<::test_protocols::WithProtocolEnds>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::WithProtocolEnds>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<
    ::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocols::WithProtocolEnds>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocols::WithProtocolEndsClientEndsRequest payload)
      : payload_(std::move(payload)) {}
  Request(const Request&) noexcept = delete;
  Request& operator=(const Request&) noexcept = delete;
  ::test_protocols::WithProtocolEndsClientEndsRequest* operator->() {
    return &payload_;
  }
  const ::test_protocols::WithProtocolEndsClientEndsRequest* operator->()
      const {
    return &payload_;
  }
  ::test_protocols::WithProtocolEndsClientEndsRequest& operator*() {
    return payload_;
  }
  const ::test_protocols::WithProtocolEndsClientEndsRequest& operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::WithProtocolEndsClientEndsRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithProtocolEndsClientEndsRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocols::WithProtocolEndsServerEndsRequest payload)
      : payload_(std::move(payload)) {}
  Request(const Request&) noexcept = delete;
  Request& operator=(const Request&) noexcept = delete;
  ::test_protocols::WithProtocolEndsServerEndsRequest* operator->() {
    return &payload_;
  }
  const ::test_protocols::WithProtocolEndsServerEndsRequest* operator->()
      const {
    return &payload_;
  }
  ::test_protocols::WithProtocolEndsServerEndsRequest& operator*() {
    return payload_;
  }
  const ::test_protocols::WithProtocolEndsServerEndsRequest& operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::WithProtocolEndsServerEndsRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithProtocolEndsServerEndsRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithProtocolEnds::StructContainingEnds>
    final : public ::fidl::internal::MessageBase<::fidl::Request<
                ::test_protocols::WithProtocolEnds::StructContainingEnds>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocols::WithProtocolEndsStructContainingEndsRequest payload)
      : payload_(std::move(payload)) {}
  Request(const Request&) noexcept = delete;
  Request& operator=(const Request&) noexcept = delete;
  ::test_protocols::WithProtocolEndsStructContainingEndsRequest* operator->() {
    return &payload_;
  }
  const ::test_protocols::WithProtocolEndsStructContainingEndsRequest*
  operator->() const {
    return &payload_;
  }
  ::test_protocols::WithProtocolEndsStructContainingEndsRequest& operator*() {
    return payload_;
  }
  const ::test_protocols::WithProtocolEndsStructContainingEndsRequest&
  operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::WithProtocolEndsStructContainingEndsRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::WithProtocolEnds::StructContainingEnds>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithProtocolEndsStructContainingEndsRequest;
};
#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithProtocolEnds::ClientEnds>
    : public ::fidl::CompleterBase {
 public:
  void Reply(::test_protocols::WithProtocolEndsClientEndsTopResponse&& payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocols::WithProtocolEnds::ClientEnds> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithProtocolEnds::ClientEnds>>;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithProtocolEnds::ServerEnds>
    : public ::fidl::CompleterBase {
 public:
  void Reply(::test_protocols::WithProtocolEndsServerEndsTopResponse&& payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocols::WithProtocolEnds::ServerEnds> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithProtocolEnds::ServerEnds>>;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>
    : public ::fidl::CompleterBase {
 public:
  void Reply(::test_protocols::WithProtocolEndsStructContainingEndsTopResponse&&
                 payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocols::WithProtocolEnds::StructContainingEnds> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>>;
};

template <>
class ::fidl::Server<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithProtocolEnds;

  using ClientEndsRequest =
      ::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds>;
  using ClientEndsCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithProtocolEnds::ClientEnds>;

  virtual void ClientEnds(ClientEndsRequest& request,
                          ClientEndsCompleter::Sync& completer) = 0;

  using ServerEndsRequest =
      ::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds>;
  using ServerEndsCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithProtocolEnds::ServerEnds>;

  virtual void ServerEnds(ServerEndsRequest& request,
                          ServerEndsCompleter::Sync& completer) = 0;

  using StructContainingEndsRequest =
      ::fidl::Request<::test_protocols::WithProtocolEnds::StructContainingEnds>;
  using StructContainingEndsCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>;

  virtual void StructContainingEnds(
      StructContainingEndsRequest& request,
      StructContainingEndsCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithProtocolEnds>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::WithProtocolEnds>* impl,
                       ::fidl::IncomingMessage&& msg,
                       internal::IncomingTransportContext transport_context,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

namespace test_protocols {
__LOCAL extern "C" const fidl_type_t
    test_protocols_ManyParametersFifteenRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocols
template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::ManyParameters>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fitx::result<::fidl::Error> Fifteen(
      ::test_protocols::ManyParametersFifteenRequest&& payload) const;
};
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::ManyParameters> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::ManyParameters>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::ManyParameters>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::ManyParameters>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<::test_protocols::ManyParameters>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::ManyParameters>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::ManyParameters>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::ManyParameters>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocols::ManyParameters>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::ManyParameters::Fifteen> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocols::ManyParameters::Fifteen>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocols::ManyParametersFifteenRequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::ManyParametersFifteenRequest* operator->() {
    return &payload_;
  }
  const ::test_protocols::ManyParametersFifteenRequest* operator->() const {
    return &payload_;
  }
  ::test_protocols::ManyParametersFifteenRequest& operator*() {
    return payload_;
  }
  const ::test_protocols::ManyParametersFifteenRequest& operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::ManyParametersFifteenRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::ManyParameters::Fifteen>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ManyParametersFifteenRequest;
};
#endif  // __Fuchsia__

template <>
class ::fidl::Server<::test_protocols::ManyParameters>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::ManyParameters;

  using FifteenRequest =
      ::fidl::Request<::test_protocols::ManyParameters::Fifteen>;
  using FifteenCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::ManyParameters::Fifteen>;

  virtual void Fifteen(FifteenRequest& request,
                       FifteenCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<
    ::test_protocols::ManyParameters>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::ManyParameters>* impl,
                       ::fidl::IncomingMessage&& msg,
                       internal::IncomingTransportContext transport_context,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

namespace test_protocols {
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>
    final : public ::fidl::internal::MessageBase<::fidl::Response<
                ::test_protocols::WithErrorSyntax::ResponseAsStruct>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::WithErrorSyntaxResponseAsStructTopResponse payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse* operator->() {
    return &payload_;
  }
  const ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse*
  operator->() const {
    return &payload_;
  }
  ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse&
  operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse;
};
namespace test_protocols {}  // namespace test_protocols
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<::fidl::Error,
                     ::fidl::Response<::test_protocols::WithErrorSyntax::
                                          ResponseAsStruct>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>&)>;
};

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final : public ::fidl::internal::MessageBase<::fidl::Response<
                ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse* operator->() {
    return &payload_;
  }
  const ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse*
  operator->() const {
    return &payload_;
  }
  ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse&
  operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<::fidl::Error,
                     ::fidl::Response<::test_protocols::WithErrorSyntax::
                                          ErrorAsPrimitive>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&)>;
};

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse* operator->() {
    return &payload_;
  }
  const ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse* operator->()
      const {
    return &payload_;
  }
  ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>&)>;
};

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::WithErrorSyntaxHandleInResultTopResponse payload)
      : payload_(std::move(payload)) {}
  Response(const Response&) noexcept = delete;
  Response& operator=(const Response&) noexcept = delete;
  ::test_protocols::WithErrorSyntaxHandleInResultTopResponse* operator->() {
    return &payload_;
  }
  const ::test_protocols::WithErrorSyntaxHandleInResultTopResponse* operator->()
      const {
    return &payload_;
  }
  ::test_protocols::WithErrorSyntaxHandleInResultTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::WithErrorSyntaxHandleInResultTopResponse& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocols::WithErrorSyntaxHandleInResultTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithErrorSyntaxHandleInResultTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithErrorSyntax::HandleInResult>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<::fidl::Error,
                     ::fidl::Response<
                         ::test_protocols::WithErrorSyntax::HandleInResult>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>&)>;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void ResponseAsStruct(::fidl::ClientCallback<
                        ::test_protocols::WithErrorSyntax::ResponseAsStruct>&&
                            _callback) const;

  void ResponseAsStruct(::fidl::ClientResponseCallback<
                        ::test_protocols::WithErrorSyntax::ResponseAsStruct>&&
                            _callback) const;

  void ErrorAsPrimitive(::fidl::ClientCallback<
                        ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&&
                            _callback) const;

  void ErrorAsPrimitive(::fidl::ClientResponseCallback<
                        ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&&
                            _callback) const;

  void ErrorAsEnum(
      ::fidl::ClientCallback<::test_protocols::WithErrorSyntax::ErrorAsEnum>&&
          _callback) const;

  void ErrorAsEnum(
      ::fidl::ClientResponseCallback<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>&& _callback) const;

  void HandleInResult(
      ::fidl::ClientCallback<
          ::test_protocols::WithErrorSyntax::HandleInResult>&& _callback) const;

  void HandleInResult(
      ::fidl::ClientResponseCallback<
          ::test_protocols::WithErrorSyntax::HandleInResult>&& _callback) const;
};
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::WithErrorSyntax> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::WithErrorSyntax>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::WithErrorSyntax>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<::test_protocols::WithErrorSyntax>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::WithErrorSyntax>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<
    ::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocols::WithErrorSyntax>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithErrorSyntax::ResponseAsStruct> final
    : public ::fidl::internal::MessageBase<::fidl::Request<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;

 private:
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::WithErrorSyntax::ResponseAsStruct>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final
    : public ::fidl::internal::MessageBase<::fidl::Request<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;

 private:
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsEnum> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsEnum>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;

 private:
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsEnum>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithErrorSyntax::HandleInResult> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocols::WithErrorSyntax::HandleInResult>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;

 private:
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::WithErrorSyntax::HandleInResult>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>
    : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse&& payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>>;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse&& payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>
    : public ::fidl::CompleterBase {
 public:
  void Reply(::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse&& payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>>;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithErrorSyntax::HandleInResult>
    : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::test_protocols::WithErrorSyntaxHandleInResultTopResponse&& payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocols::WithErrorSyntax::HandleInResult> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithErrorSyntax::HandleInResult>>;
};

template <>
class ::fidl::Server<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithErrorSyntax;

  using ResponseAsStructRequest =
      ::fidl::Request<::test_protocols::WithErrorSyntax::ResponseAsStruct>;
  using ResponseAsStructCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>;

  virtual void ResponseAsStruct(ResponseAsStructRequest& request,
                                ResponseAsStructCompleter::Sync& completer) = 0;

  using ErrorAsPrimitiveRequest =
      ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>;
  using ErrorAsPrimitiveCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>;

  virtual void ErrorAsPrimitive(ErrorAsPrimitiveRequest& request,
                                ErrorAsPrimitiveCompleter::Sync& completer) = 0;

  using ErrorAsEnumRequest =
      ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsEnum>;
  using ErrorAsEnumCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>;

  virtual void ErrorAsEnum(ErrorAsEnumRequest& request,
                           ErrorAsEnumCompleter::Sync& completer) = 0;

  using HandleInResultRequest =
      ::fidl::Request<::test_protocols::WithErrorSyntax::HandleInResult>;
  using HandleInResultCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithErrorSyntax::HandleInResult>;

  virtual void HandleInResult(HandleInResultRequest& request,
                              HandleInResultCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithErrorSyntax>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::WithErrorSyntax>* impl,
                       ::fidl::IncomingMessage&& msg,
                       internal::IncomingTransportContext transport_context,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalClientImpl<
    ::test_protocols::DiscoverableProtocol>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fitx::result<::fidl::Error> Method() const;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::DiscoverableProtocol> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::DiscoverableProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::DiscoverableProtocol>
    final
    : public ::fidl::internal::IncomingEventDispatcher<
          ::fidl::AsyncEventHandler<::test_protocols::DiscoverableProtocol>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::DiscoverableProtocol>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<
    ::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<
    ::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocols::DiscoverableProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::DiscoverableProtocol::Method> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocols::DiscoverableProtocol::Method>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;

 private:
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::DiscoverableProtocol::Method>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
#endif  // __Fuchsia__

template <>
class ::fidl::Server<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::DiscoverableProtocol;

  using MethodRequest =
      ::fidl::Request<::test_protocols::DiscoverableProtocol::Method>;
  using MethodCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::DiscoverableProtocol::Method>;

  virtual void Method(MethodRequest& request,
                      MethodCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<
    ::test_protocols::DiscoverableProtocol>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(
      ::fidl::Server<::test_protocols::DiscoverableProtocol>* impl,
      ::fidl::IncomingMessage&& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

namespace test_protocols {
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodARequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolEventARequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodBRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodBTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolTakeHandleRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketTopResponseTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Event<::test_protocols::ChannelProtocol::EventA> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Event<::test_protocols::ChannelProtocol::EventA>> {
 public:
  Event() = default;
  ~Event() = default;
  Event(Event&&) noexcept = default;
  Event& operator=(Event&&) noexcept = default;
  Event(::test_protocols::ChannelProtocolEventARequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::ChannelProtocolEventARequest* operator->() {
    return &payload_;
  }
  const ::test_protocols::ChannelProtocolEventARequest* operator->() const {
    return &payload_;
  }
  ::test_protocols::ChannelProtocolEventARequest& operator*() {
    return payload_;
  }
  const ::test_protocols::ChannelProtocolEventARequest& operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::ChannelProtocolEventARequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocols::ChannelProtocol::EventA>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolEventARequest;
};
namespace test_protocols {}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::ChannelProtocol::MethodB> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::ChannelProtocolMethodBTopResponse payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::ChannelProtocolMethodBTopResponse* operator->() {
    return &payload_;
  }
  const ::test_protocols::ChannelProtocolMethodBTopResponse* operator->()
      const {
    return &payload_;
  }
  ::test_protocols::ChannelProtocolMethodBTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::ChannelProtocolMethodBTopResponse& operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::ChannelProtocolMethodBTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolMethodBTopResponse;
};
namespace test_protocols {}  // namespace test_protocols
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::ChannelProtocol::MethodB>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>&)>;
};

template <>
class ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;

 private:
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::ChannelProtocol::TakeHandle>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle>&)>;
};

template <>
class ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::ChannelProtocolMutateSocketTopResponse payload)
      : payload_(std::move(payload)) {}
  Response(const Response&) noexcept = delete;
  Response& operator=(const Response&) noexcept = delete;
  ::test_protocols::ChannelProtocolMutateSocketTopResponse* operator->() {
    return &payload_;
  }
  const ::test_protocols::ChannelProtocolMutateSocketTopResponse* operator->()
      const {
    return &payload_;
  }
  ::test_protocols::ChannelProtocolMutateSocketTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::ChannelProtocolMutateSocketTopResponse& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocols::ChannelProtocolMutateSocketTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolMutateSocketTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::ChannelProtocol::MutateSocket>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>&)>;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void MethodB(
      ::test_protocols::ChannelProtocolMethodBRequest&& payload,
      ::fidl::ClientCallback<::test_protocols::ChannelProtocol::MethodB>&&
          _callback) const;

  void MethodB(
      ::test_protocols::ChannelProtocolMethodBRequest&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocols::ChannelProtocol::MethodB>&& _callback) const;

  void TakeHandle(
      ::test_protocols::ChannelProtocolTakeHandleRequest&& payload,
      ::fidl::ClientCallback<::test_protocols::ChannelProtocol::TakeHandle>&&
          _callback) const;

  void TakeHandle(
      ::test_protocols::ChannelProtocolTakeHandleRequest&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocols::ChannelProtocol::TakeHandle>&& _callback) const;

  void MutateSocket(
      ::test_protocols::ChannelProtocolMutateSocketRequest&& payload,
      ::fidl::ClientCallback<::test_protocols::ChannelProtocol::MutateSocket>&&
          _callback) const;

  void MutateSocket(
      ::test_protocols::ChannelProtocolMutateSocketRequest&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocols::ChannelProtocol::MutateSocket>&& _callback) const;

  ::fitx::result<::fidl::Error> MethodA(
      ::test_protocols::ChannelProtocolMethodARequest&& payload) const;
};
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::ChannelProtocol> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void EventA(
      ::fidl::Event<::test_protocols::ChannelProtocol::EventA>&) {}
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::ChannelProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::ChannelProtocol>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<::test_protocols::ChannelProtocol>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::ChannelProtocol>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<
    ::test_protocols::ChannelProtocol>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  ::fitx::result<::fidl::Error> EventA(
      ::test_protocols::ChannelProtocolEventARequest payload);
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocols::ChannelProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  ::fitx::result<::fidl::Error> EventA(
      ::test_protocols::ChannelProtocolEventARequest payload);
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::ChannelProtocol::MethodA> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocols::ChannelProtocol::MethodA>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocols::ChannelProtocolMethodARequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::ChannelProtocolMethodARequest* operator->() {
    return &payload_;
  }
  const ::test_protocols::ChannelProtocolMethodARequest* operator->() const {
    return &payload_;
  }
  ::test_protocols::ChannelProtocolMethodARequest& operator*() {
    return payload_;
  }
  const ::test_protocols::ChannelProtocolMethodARequest& operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::ChannelProtocolMethodARequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::ChannelProtocol::MethodA>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolMethodARequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::ChannelProtocol::MethodB> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocols::ChannelProtocol::MethodB>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocols::ChannelProtocolMethodBRequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::ChannelProtocolMethodBRequest* operator->() {
    return &payload_;
  }
  const ::test_protocols::ChannelProtocolMethodBRequest* operator->() const {
    return &payload_;
  }
  ::test_protocols::ChannelProtocolMethodBRequest& operator*() {
    return payload_;
  }
  const ::test_protocols::ChannelProtocolMethodBRequest& operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::ChannelProtocolMethodBRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::ChannelProtocol::MethodB>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolMethodBRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocols::ChannelProtocolTakeHandleRequest payload)
      : payload_(std::move(payload)) {}
  Request(const Request&) noexcept = delete;
  Request& operator=(const Request&) noexcept = delete;
  ::test_protocols::ChannelProtocolTakeHandleRequest* operator->() {
    return &payload_;
  }
  const ::test_protocols::ChannelProtocolTakeHandleRequest* operator->() const {
    return &payload_;
  }
  ::test_protocols::ChannelProtocolTakeHandleRequest& operator*() {
    return payload_;
  }
  const ::test_protocols::ChannelProtocolTakeHandleRequest& operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::ChannelProtocolTakeHandleRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolTakeHandleRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket>> {
 public:
  Request() = default;
  ~Request() = default;
  Request(Request&&) noexcept = default;
  Request& operator=(Request&&) noexcept = default;
  Request(::test_protocols::ChannelProtocolMutateSocketRequest payload)
      : payload_(std::move(payload)) {}
  Request(const Request&) noexcept = delete;
  Request& operator=(const Request&) noexcept = delete;
  ::test_protocols::ChannelProtocolMutateSocketRequest* operator->() {
    return &payload_;
  }
  const ::test_protocols::ChannelProtocolMutateSocketRequest* operator->()
      const {
    return &payload_;
  }
  ::test_protocols::ChannelProtocolMutateSocketRequest& operator*() {
    return payload_;
  }
  const ::test_protocols::ChannelProtocolMutateSocketRequest& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocols::ChannelProtocolMutateSocketRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolMutateSocketRequest;
};
#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::ChannelProtocol::MethodB> : public ::fidl::CompleterBase {
 public:
  void Reply(::test_protocols::ChannelProtocolMethodBTopResponse&& payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocols::ChannelProtocol::MethodB> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::ChannelProtocol::MethodB>>;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::ChannelProtocol::TakeHandle>
    : public ::fidl::CompleterBase {
 public:
  void Reply();

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocols::ChannelProtocol::TakeHandle> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::ChannelProtocol::TakeHandle>>;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::ChannelProtocol::MutateSocket>
    : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::test_protocols::ChannelProtocolMutateSocketTopResponse&& payload);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::MethodTypes<
    ::test_protocols::ChannelProtocol::MutateSocket> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::ChannelProtocol::MutateSocket>>;
};

template <>
class ::fidl::Server<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::ChannelProtocol;

  using MethodARequest =
      ::fidl::Request<::test_protocols::ChannelProtocol::MethodA>;
  using MethodACompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::ChannelProtocol::MethodA>;

  virtual void MethodA(MethodARequest& request,
                       MethodACompleter::Sync& completer) = 0;

  using MethodBRequest =
      ::fidl::Request<::test_protocols::ChannelProtocol::MethodB>;
  using MethodBCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::ChannelProtocol::MethodB>;

  virtual void MethodB(MethodBRequest& request,
                       MethodBCompleter::Sync& completer) = 0;

  using TakeHandleRequest =
      ::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle>;
  using TakeHandleCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::ChannelProtocol::TakeHandle>;

  virtual void TakeHandle(TakeHandleRequest& request,
                          TakeHandleCompleter::Sync& completer) = 0;

  using MutateSocketRequest =
      ::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket>;
  using MutateSocketCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::ChannelProtocol::MutateSocket>;

  virtual void MutateSocket(MutateSocketRequest& request,
                            MutateSocketCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<
    ::test_protocols::ChannelProtocol>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::ChannelProtocol>* impl,
                       ::fidl::IncomingMessage&& msg,
                       internal::IncomingTransportContext transport_context,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__
