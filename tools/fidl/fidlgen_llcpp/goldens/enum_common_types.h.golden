// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/llcpp/traits.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>

namespace test_enum {

enum class MyStrictEnum : uint32_t {

  kFoo = 1u,

  kBar = 2u,
};

class MyFlexibleEnumWithCustomUnknown final {
 public:
  constexpr MyFlexibleEnumWithCustomUnknown() : value_(0) {}
  constexpr explicit MyFlexibleEnumWithCustomUnknown(uint32_t value)
      : value_(value) {}
  constexpr operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    switch (value_) {
      case 1u:

      case 2u:

        return false;
    }
    return true;
  }

  constexpr static MyFlexibleEnumWithCustomUnknown Unknown() {
    return MyFlexibleEnumWithCustomUnknown(0x3);
  }

  static const MyFlexibleEnumWithCustomUnknown kFoo;

  static const MyFlexibleEnumWithCustomUnknown kBar;

  static const MyFlexibleEnumWithCustomUnknown kCustomUnknown;

 private:
  uint32_t value_;
};
constexpr const ::test_enum::MyFlexibleEnumWithCustomUnknown
    MyFlexibleEnumWithCustomUnknown::kFoo =
        ::test_enum::MyFlexibleEnumWithCustomUnknown(1u);
constexpr const ::test_enum::MyFlexibleEnumWithCustomUnknown
    MyFlexibleEnumWithCustomUnknown::kBar =
        ::test_enum::MyFlexibleEnumWithCustomUnknown(2u);
constexpr const ::test_enum::MyFlexibleEnumWithCustomUnknown
    MyFlexibleEnumWithCustomUnknown::kCustomUnknown =
        ::test_enum::MyFlexibleEnumWithCustomUnknown(3u);

class MyFlexibleEnum final {
 public:
  constexpr MyFlexibleEnum() : value_(0) {}
  constexpr explicit MyFlexibleEnum(uint32_t value) : value_(value) {}
  constexpr operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    switch (value_) {
      case 1u:

      case 2u:

        return false;
    }
    return true;
  }

  constexpr static MyFlexibleEnum Unknown() {
    return MyFlexibleEnum(0xffffffff);
  }

  static const MyFlexibleEnum kFoo;

  static const MyFlexibleEnum kBar;

 private:
  uint32_t value_;
};
constexpr const ::test_enum::MyFlexibleEnum MyFlexibleEnum::kFoo =
    ::test_enum::MyFlexibleEnum(1u);
constexpr const ::test_enum::MyFlexibleEnum MyFlexibleEnum::kBar =
    ::test_enum::MyFlexibleEnum(2u);

class MyEmptyFlexibleEnum final {
 public:
  constexpr MyEmptyFlexibleEnum() : value_(0) {}
  constexpr explicit MyEmptyFlexibleEnum(uint32_t value) : value_(value) {}
  constexpr operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const { return true; }

  constexpr static MyEmptyFlexibleEnum Unknown() {
    return MyEmptyFlexibleEnum(0xffffffff);
  }

 private:
  uint32_t value_;
};

}  // namespace test_enum
namespace fidl {

template <>
struct IsFidlType<::test_enum::MyStrictEnum> : public std::true_type {};
template <>
struct ContainsHandle<::test_enum::MyStrictEnum> : public std::false_type {};

template <>
struct IsFidlType<::test_enum::MyFlexibleEnumWithCustomUnknown>
    : public std::true_type {};
template <>
struct ContainsHandle<::test_enum::MyFlexibleEnumWithCustomUnknown>
    : public std::false_type {};

template <>
struct IsFidlType<::test_enum::MyFlexibleEnum> : public std::true_type {};
template <>
struct ContainsHandle<::test_enum::MyFlexibleEnum> : public std::false_type {};

template <>
struct IsFidlType<::test_enum::MyEmptyFlexibleEnum> : public std::true_type {};
template <>
struct ContainsHandle<::test_enum::MyEmptyFlexibleEnum>
    : public std::false_type {};

}  // namespace fidl
