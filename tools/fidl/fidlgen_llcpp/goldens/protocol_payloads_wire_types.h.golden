// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/envelope.h>
#include <lib/fidl/llcpp/message.h>
#include <lib/fidl/llcpp/message_storage.h>
#include <lib/fidl/llcpp/object_view.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/wire_types.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>
#ifdef __Fuchsia__
#include <lib/zx/channel.h>

#endif  // __Fuchsia__

#include <fidl/test.protocolpayloads.imported/cpp/wire_types.h>
#include <fidl/test.protocolpayloads/cpp/common_types.h>
#include <fidl/test.protocolpayloads/cpp/markers.h>

namespace test_protocolpayloads {
namespace wire {
struct MainProtocolTwoWayAnonWithErrorResponse;

struct MainProtocolOnAnonWithErrorResponse;

struct LocalStructPayload;

class MainProtocolTwoWayImportWithErrorResult;

class MainProtocolTwoWayAnonWithErrorResult;

class MainProtocolOnImportWithErrorResult;

class MainProtocolOnAnonWithErrorResult;

class MainProtocolTwoWayLocalWithErrorResult;

class MainProtocolOnLocalWithErrorResult;

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocol_TwoWayImportWithError_ResultTable;

class MainProtocolTwoWayImportWithErrorResult {
 public:
  MainProtocolTwoWayImportWithErrorResult()
      : ordinal_(::test_protocolpayloads::wire::
                     MainProtocolTwoWayImportWithErrorResult::Ordinal::Invalid),
        envelope_ {}
  {}

  MainProtocolTwoWayImportWithErrorResult(
      const MainProtocolTwoWayImportWithErrorResult&) = default;
  MainProtocolTwoWayImportWithErrorResult& operator=(
      const MainProtocolTwoWayImportWithErrorResult&) = default;
  MainProtocolTwoWayImportWithErrorResult(
      MainProtocolTwoWayImportWithErrorResult&&) = default;
  MainProtocolTwoWayImportWithErrorResult& operator=(
      MainProtocolTwoWayImportWithErrorResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::
               MainProtocolTwoWayImportWithErrorResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::
               MainProtocolTwoWayImportWithErrorResult::Ordinal::kResponse;
  }
  static MainProtocolTwoWayImportWithErrorResult WithResponse(
      ::test_protocolpayloads_imported::wire::ImportStructPayload val) {
    MainProtocolTwoWayImportWithErrorResult result;
    result.set_response(std::move(val));
    return result;
  }

  void set_response(
      ::test_protocolpayloads_imported::wire::ImportStructPayload elem) {
    ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolTwoWayImportWithErrorResult::Ordinal::kResponse;
    envelope_.As<::test_protocolpayloads_imported::wire::ImportStructPayload>()
        .set_data(std::move(elem));
  }

  ::test_protocolpayloads_imported::wire::ImportStructPayload& response() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayImportWithErrorResult::Ordinal::kResponse);
    return envelope_
        .As<::test_protocolpayloads_imported::wire::ImportStructPayload>()
        .get_data();
  }
  const ::test_protocolpayloads_imported::wire::ImportStructPayload& response()
      const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayImportWithErrorResult::Ordinal::kResponse);
    return envelope_
        .As<::test_protocolpayloads_imported::wire::ImportStructPayload>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::
               MainProtocolTwoWayImportWithErrorResult::Ordinal::kErr;
  }
  static MainProtocolTwoWayImportWithErrorResult WithErr(uint32_t val) {
    MainProtocolTwoWayImportWithErrorResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolTwoWayImportWithErrorResult::Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayImportWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayImportWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Tag
  Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_protocolpayloads::wire::
                           MainProtocolTwoWayImportWithErrorResult::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::
      Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocol_TwoWayAnonWithError_ResultTable;

class MainProtocolTwoWayAnonWithErrorResult {
 public:
  using Response =
      test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse;

  MainProtocolTwoWayAnonWithErrorResult()
      : ordinal_(::test_protocolpayloads::wire::
                     MainProtocolTwoWayAnonWithErrorResult::Ordinal::Invalid),
        envelope_ {}
  {}

  MainProtocolTwoWayAnonWithErrorResult(
      const MainProtocolTwoWayAnonWithErrorResult&) = default;
  MainProtocolTwoWayAnonWithErrorResult& operator=(
      const MainProtocolTwoWayAnonWithErrorResult&) = default;
  MainProtocolTwoWayAnonWithErrorResult(
      MainProtocolTwoWayAnonWithErrorResult&&) = default;
  MainProtocolTwoWayAnonWithErrorResult& operator=(
      MainProtocolTwoWayAnonWithErrorResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::
               MainProtocolTwoWayAnonWithErrorResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::
               MainProtocolTwoWayAnonWithErrorResult::Ordinal::kResponse;
  }
  static MainProtocolTwoWayAnonWithErrorResult WithResponse(
      ::fidl::ObjectView<::test_protocolpayloads::wire::
                             MainProtocolTwoWayAnonWithErrorResponse>
          val) {
    MainProtocolTwoWayAnonWithErrorResult result;
    result.set_response(val);
    return result;
  }

  template <typename... Args>
  static MainProtocolTwoWayAnonWithErrorResult WithResponse(
      ::fidl::AnyArena& allocator, Args&&... args) {
    MainProtocolTwoWayAnonWithErrorResult result;
    result.set_response(
        ::fidl::ObjectView<::test_protocolpayloads::wire::
                               MainProtocolTwoWayAnonWithErrorResponse>(
            allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_response(
      ::fidl::ObjectView<::test_protocolpayloads::wire::
                             MainProtocolTwoWayAnonWithErrorResponse>
          elem) {
    ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolTwoWayAnonWithErrorResult::Ordinal::kResponse;
    envelope_
        .As<::test_protocolpayloads::wire::
                MainProtocolTwoWayAnonWithErrorResponse>()
        .set_data(std::move(elem));
  }

  template <typename... Args>
  void set_response(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolTwoWayAnonWithErrorResult::Ordinal::kResponse;
    set_response(
        ::fidl::ObjectView<::test_protocolpayloads::wire::
                               MainProtocolTwoWayAnonWithErrorResponse>(
            allocator, std::forward<Args>(args)...));
  }

  ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse&
  response() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayAnonWithErrorResult::Ordinal::kResponse);
    return envelope_
        .As<::test_protocolpayloads::wire::
                MainProtocolTwoWayAnonWithErrorResponse>()
        .get_data();
  }
  const ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayAnonWithErrorResult::Ordinal::kResponse);
    return envelope_
        .As<::test_protocolpayloads::wire::
                MainProtocolTwoWayAnonWithErrorResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ == ::test_protocolpayloads::wire::
                           MainProtocolTwoWayAnonWithErrorResult::Ordinal::kErr;
  }
  static MainProtocolTwoWayAnonWithErrorResult WithErr(uint32_t val) {
    MainProtocolTwoWayAnonWithErrorResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolTwoWayAnonWithErrorResult::Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayAnonWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayAnonWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Tag
  Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_protocolpayloads::wire::
                           MainProtocolTwoWayAnonWithErrorResult::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocol_OnImportWithError_ResultTable;

class MainProtocolOnImportWithErrorResult {
 public:
  MainProtocolOnImportWithErrorResult()
      : ordinal_(::test_protocolpayloads::wire::
                     MainProtocolOnImportWithErrorResult::Ordinal::Invalid),
        envelope_ {}
  {}

  MainProtocolOnImportWithErrorResult(
      const MainProtocolOnImportWithErrorResult&) = default;
  MainProtocolOnImportWithErrorResult& operator=(
      const MainProtocolOnImportWithErrorResult&) = default;
  MainProtocolOnImportWithErrorResult(MainProtocolOnImportWithErrorResult&&) =
      default;
  MainProtocolOnImportWithErrorResult& operator=(
      MainProtocolOnImportWithErrorResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult::
               Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult::
               Ordinal::kResponse;
  }
  static MainProtocolOnImportWithErrorResult WithResponse(
      ::test_protocolpayloads_imported::wire::ImportStructPayload val) {
    MainProtocolOnImportWithErrorResult result;
    result.set_response(std::move(val));
    return result;
  }

  void set_response(
      ::test_protocolpayloads_imported::wire::ImportStructPayload elem) {
    ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolOnImportWithErrorResult::Ordinal::kResponse;
    envelope_.As<::test_protocolpayloads_imported::wire::ImportStructPayload>()
        .set_data(std::move(elem));
  }

  ::test_protocolpayloads_imported::wire::ImportStructPayload& response() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolOnImportWithErrorResult::Ordinal::kResponse);
    return envelope_
        .As<::test_protocolpayloads_imported::wire::ImportStructPayload>()
        .get_data();
  }
  const ::test_protocolpayloads_imported::wire::ImportStructPayload& response()
      const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolOnImportWithErrorResult::Ordinal::kResponse);
    return envelope_
        .As<::test_protocolpayloads_imported::wire::ImportStructPayload>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ == ::test_protocolpayloads::wire::
                           MainProtocolOnImportWithErrorResult::Ordinal::kErr;
  }
  static MainProtocolOnImportWithErrorResult WithErr(uint32_t val) {
    MainProtocolOnImportWithErrorResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolOnImportWithErrorResult::Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolOnImportWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolOnImportWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult::Tag
  Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_protocolpayloads::wire::
                           MainProtocolOnImportWithErrorResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocol_OnAnonWithError_ResultTable;

class MainProtocolOnAnonWithErrorResult {
 public:
  using Response =
      test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse;

  MainProtocolOnAnonWithErrorResult()
      : ordinal_(::test_protocolpayloads::wire::
                     MainProtocolOnAnonWithErrorResult::Ordinal::Invalid),
        envelope_ {}
  {}

  MainProtocolOnAnonWithErrorResult(const MainProtocolOnAnonWithErrorResult&) =
      default;
  MainProtocolOnAnonWithErrorResult& operator=(
      const MainProtocolOnAnonWithErrorResult&) = default;
  MainProtocolOnAnonWithErrorResult(MainProtocolOnAnonWithErrorResult&&) =
      default;
  MainProtocolOnAnonWithErrorResult& operator=(
      MainProtocolOnAnonWithErrorResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::test_protocolpayloads::wire::
                           MainProtocolOnAnonWithErrorResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult::
               Ordinal::kResponse;
  }
  static MainProtocolOnAnonWithErrorResult WithResponse(
      ::fidl::ObjectView<
          ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse>
          val) {
    MainProtocolOnAnonWithErrorResult result;
    result.set_response(val);
    return result;
  }

  template <typename... Args>
  static MainProtocolOnAnonWithErrorResult WithResponse(
      ::fidl::AnyArena& allocator, Args&&... args) {
    MainProtocolOnAnonWithErrorResult result;
    result.set_response(
        ::fidl::ObjectView<
            ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse>(
            allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_response(
      ::fidl::ObjectView<
          ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse>
          elem) {
    ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolOnAnonWithErrorResult::Ordinal::kResponse;
    envelope_
        .As<::test_protocolpayloads::wire::
                MainProtocolOnAnonWithErrorResponse>()
        .set_data(std::move(elem));
  }

  template <typename... Args>
  void set_response(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolOnAnonWithErrorResult::Ordinal::kResponse;
    set_response(
        ::fidl::ObjectView<
            ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse>(
            allocator, std::forward<Args>(args)...));
  }

  ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse&
  response() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_protocolpayloads::wire::
                MainProtocolOnAnonWithErrorResponse>()
        .get_data();
  }
  const ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_protocolpayloads::wire::
                MainProtocolOnAnonWithErrorResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ == ::test_protocolpayloads::wire::
                           MainProtocolOnAnonWithErrorResult::Ordinal::kErr;
  }
  static MainProtocolOnAnonWithErrorResult WithErr(uint32_t val) {
    MainProtocolOnAnonWithErrorResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolOnAnonWithErrorResult::Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_protocolpayloads::wire::
                              MainProtocolOnAnonWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_protocolpayloads::wire::
                              MainProtocolOnAnonWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult::Tag Which()
      const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<
        ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocol_TwoWayLocalWithError_ResultTable;

class MainProtocolTwoWayLocalWithErrorResult {
 public:
  MainProtocolTwoWayLocalWithErrorResult()
      : ordinal_(::test_protocolpayloads::wire::
                     MainProtocolTwoWayLocalWithErrorResult::Ordinal::Invalid),
        envelope_ {}
  {}

  MainProtocolTwoWayLocalWithErrorResult(
      const MainProtocolTwoWayLocalWithErrorResult&) = default;
  MainProtocolTwoWayLocalWithErrorResult& operator=(
      const MainProtocolTwoWayLocalWithErrorResult&) = default;
  MainProtocolTwoWayLocalWithErrorResult(
      MainProtocolTwoWayLocalWithErrorResult&&) = default;
  MainProtocolTwoWayLocalWithErrorResult& operator=(
      MainProtocolTwoWayLocalWithErrorResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::
               MainProtocolTwoWayLocalWithErrorResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::
               MainProtocolTwoWayLocalWithErrorResult::Ordinal::kResponse;
  }
  static MainProtocolTwoWayLocalWithErrorResult WithResponse(
      ::fidl::ObjectView<::test_protocolpayloads::wire::LocalStructPayload>
          val) {
    MainProtocolTwoWayLocalWithErrorResult result;
    result.set_response(val);
    return result;
  }

  template <typename... Args>
  static MainProtocolTwoWayLocalWithErrorResult WithResponse(
      ::fidl::AnyArena& allocator, Args&&... args) {
    MainProtocolTwoWayLocalWithErrorResult result;
    result.set_response(
        ::fidl::ObjectView<::test_protocolpayloads::wire::LocalStructPayload>(
            allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_response(
      ::fidl::ObjectView<::test_protocolpayloads::wire::LocalStructPayload>
          elem) {
    ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolTwoWayLocalWithErrorResult::Ordinal::kResponse;
    envelope_.As<::test_protocolpayloads::wire::LocalStructPayload>().set_data(
        std::move(elem));
  }

  template <typename... Args>
  void set_response(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolTwoWayLocalWithErrorResult::Ordinal::kResponse;
    set_response(
        ::fidl::ObjectView<::test_protocolpayloads::wire::LocalStructPayload>(
            allocator, std::forward<Args>(args)...));
  }

  ::test_protocolpayloads::wire::LocalStructPayload& response() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayLocalWithErrorResult::Ordinal::kResponse);
    return envelope_.As<::test_protocolpayloads::wire::LocalStructPayload>()
        .get_data();
  }
  const ::test_protocolpayloads::wire::LocalStructPayload& response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayLocalWithErrorResult::Ordinal::kResponse);
    return envelope_.As<::test_protocolpayloads::wire::LocalStructPayload>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::
               MainProtocolTwoWayLocalWithErrorResult::Ordinal::kErr;
  }
  static MainProtocolTwoWayLocalWithErrorResult WithErr(uint32_t val) {
    MainProtocolTwoWayLocalWithErrorResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolTwoWayLocalWithErrorResult::Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayLocalWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayLocalWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Tag
  Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_protocolpayloads::wire::
                           MainProtocolTwoWayLocalWithErrorResult::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocol_OnLocalWithError_ResultTable;

class MainProtocolOnLocalWithErrorResult {
 public:
  MainProtocolOnLocalWithErrorResult()
      : ordinal_(::test_protocolpayloads::wire::
                     MainProtocolOnLocalWithErrorResult::Ordinal::Invalid),
        envelope_ {}
  {}

  MainProtocolOnLocalWithErrorResult(
      const MainProtocolOnLocalWithErrorResult&) = default;
  MainProtocolOnLocalWithErrorResult& operator=(
      const MainProtocolOnLocalWithErrorResult&) = default;
  MainProtocolOnLocalWithErrorResult(MainProtocolOnLocalWithErrorResult&&) =
      default;
  MainProtocolOnLocalWithErrorResult& operator=(
      MainProtocolOnLocalWithErrorResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::test_protocolpayloads::wire::
                           MainProtocolOnLocalWithErrorResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult::
               Ordinal::kResponse;
  }
  static MainProtocolOnLocalWithErrorResult WithResponse(
      ::fidl::ObjectView<::test_protocolpayloads::wire::LocalStructPayload>
          val) {
    MainProtocolOnLocalWithErrorResult result;
    result.set_response(val);
    return result;
  }

  template <typename... Args>
  static MainProtocolOnLocalWithErrorResult WithResponse(
      ::fidl::AnyArena& allocator, Args&&... args) {
    MainProtocolOnLocalWithErrorResult result;
    result.set_response(
        ::fidl::ObjectView<::test_protocolpayloads::wire::LocalStructPayload>(
            allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_response(
      ::fidl::ObjectView<::test_protocolpayloads::wire::LocalStructPayload>
          elem) {
    ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolOnLocalWithErrorResult::Ordinal::kResponse;
    envelope_.As<::test_protocolpayloads::wire::LocalStructPayload>().set_data(
        std::move(elem));
  }

  template <typename... Args>
  void set_response(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolOnLocalWithErrorResult::Ordinal::kResponse;
    set_response(
        ::fidl::ObjectView<::test_protocolpayloads::wire::LocalStructPayload>(
            allocator, std::forward<Args>(args)...));
  }

  ::test_protocolpayloads::wire::LocalStructPayload& response() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolOnLocalWithErrorResult::Ordinal::kResponse);
    return envelope_.As<::test_protocolpayloads::wire::LocalStructPayload>()
        .get_data();
  }
  const ::test_protocolpayloads::wire::LocalStructPayload& response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolOnLocalWithErrorResult::Ordinal::kResponse);
    return envelope_.As<::test_protocolpayloads::wire::LocalStructPayload>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ == ::test_protocolpayloads::wire::
                           MainProtocolOnLocalWithErrorResult::Ordinal::kErr;
  }
  static MainProtocolOnLocalWithErrorResult WithErr(uint32_t val) {
    MainProtocolOnLocalWithErrorResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolOnLocalWithErrorResult::Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolOnLocalWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolOnLocalWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult::Tag Which()
      const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<
        ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocol_TwoWayAnonWithError_ResponseTable;

struct MainProtocolTwoWayAnonWithErrorResponse {
  uint32_t a = {};

  uint32_t b = {};
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocol_OnAnonWithError_ResponseTable;

struct MainProtocolOnAnonWithErrorResponse {
  uint32_t a = {};

  uint32_t b = {};
};

extern "C" const fidl_type_t test_protocolpayloads_LocalStructPayloadTable;

struct LocalStructPayload {
  uint32_t a = {};

  uint32_t b = {};
};

}  // namespace wire
}  // namespace test_protocolpayloads
namespace fidl {

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocol_TwoWayAnonWithError_ResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::test_protocolpayloads::wire::
                                  MainProtocolTwoWayAnonWithErrorResponse>);
static_assert(
    offsetof(
        ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse,
        a) == 0);
static_assert(
    offsetof(
        ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse,
        b) == 4);
static_assert(
    sizeof(::test_protocolpayloads::wire::
               MainProtocolTwoWayAnonWithErrorResponse) ==
    TypeTraits<::test_protocolpayloads::wire::
                   MainProtocolTwoWayAnonWithErrorResponse>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocol_OnAnonWithError_ResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse>);
static_assert(
    offsetof(::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse,
             a) == 0);
static_assert(
    offsetof(::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse,
             b) == 4);
static_assert(
    sizeof(
        ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse) ==
    TypeTraits<::test_protocolpayloads::wire::
                   MainProtocolOnAnonWithErrorResponse>::kPrimarySize);

template <>
struct TypeTraits<::test_protocolpayloads::wire::LocalStructPayload> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_LocalStructPayloadTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocolpayloads::wire::LocalStructPayload>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocolpayloads::wire::LocalStructPayload>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocolpayloads::wire::LocalStructPayload>);
static_assert(offsetof(::test_protocolpayloads::wire::LocalStructPayload, a) ==
              0);
static_assert(offsetof(::test_protocolpayloads::wire::LocalStructPayload, b) ==
              4);
static_assert(sizeof(::test_protocolpayloads::wire::LocalStructPayload) ==
              TypeTraits<::test_protocolpayloads::wire::LocalStructPayload>::
                  kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocol_TwoWayImportWithError_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult>
    : public std::true_type {};
template <>
struct IsUnion<
    ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::test_protocolpayloads::wire::
                                  MainProtocolTwoWayImportWithErrorResult>);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocol_TwoWayAnonWithError_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult>
    : public std::true_type {};
template <>
struct IsUnion<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult>);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocol_OnImportWithError_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult>
    : public std::true_type {};
template <>
struct IsUnion<
    ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult>);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocol_OnAnonWithError_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult>
    : public std::true_type {};
template <>
struct IsUnion<::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult>);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocol_TwoWayLocalWithError_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult>
    : public std::true_type {};
template <>
struct IsUnion<
    ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult>);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocol_OnLocalWithError_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult>
    : public std::true_type {};
template <>
struct IsUnion<
    ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult>);

}  // namespace fidl
