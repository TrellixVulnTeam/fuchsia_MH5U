// WARNING: This file is machine generated by fidlgen_llcpp.

#include <fidl/test.protocolpayloads/cpp/natural_messaging.h>

namespace test_protocolpayloads {
[[maybe_unused]] constexpr inline uint64_t
    kMainProtocol_OneWayComposed_Ordinal = 2602591870026304272lu;
[[maybe_unused]] constexpr inline uint64_t
    kMainProtocol_TwoWayComposed_Ordinal = 2542459230546612144lu;
[[maybe_unused]] constexpr inline uint64_t
    kMainProtocol_TwoWayComposedWithError_Ordinal = 7681984876526769495lu;
[[maybe_unused]] constexpr inline uint64_t kMainProtocol_OnComposed_Ordinal =
    1872339328378152762lu;
[[maybe_unused]] constexpr inline uint64_t
    kMainProtocol_OnComposedWithError_Ordinal = 7167282778061495960lu;
[[maybe_unused]] constexpr inline uint64_t kMainProtocol_OneWayLocal_Ordinal =
    7755175439334311701lu;
[[maybe_unused]] constexpr inline uint64_t kMainProtocol_TwoWayLocal_Ordinal =
    8374292137648566031lu;
[[maybe_unused]] constexpr inline uint64_t
    kMainProtocol_TwoWayLocalWithError_Ordinal = 2898559119954589948lu;
[[maybe_unused]] constexpr inline uint64_t kMainProtocol_OnLocal_Ordinal =
    5135782819583756313lu;
[[maybe_unused]] constexpr inline uint64_t
    kMainProtocol_OnLocalWithError_Ordinal = 5678277415565140399lu;
[[maybe_unused]] constexpr inline uint64_t kMainProtocol_OneWayImport_Ordinal =
    3344777159365288972lu;
[[maybe_unused]] constexpr inline uint64_t kMainProtocol_TwoWayImport_Ordinal =
    2374708679656510579lu;
[[maybe_unused]] constexpr inline uint64_t
    kMainProtocol_TwoWayImportWithError_Ordinal = 4286143084949642173lu;
[[maybe_unused]] constexpr inline uint64_t kMainProtocol_OnImport_Ordinal =
    1996489653379631369lu;
[[maybe_unused]] constexpr inline uint64_t
    kMainProtocol_OnImportWithError_Ordinal = 7102941407914553861lu;
[[maybe_unused]] constexpr inline uint64_t kMainProtocol_OneWayAnon_Ordinal =
    811587311021806764lu;
[[maybe_unused]] constexpr inline uint64_t kMainProtocol_TwoWayAnon_Ordinal =
    629880979996923737lu;
[[maybe_unused]] constexpr inline uint64_t
    kMainProtocol_TwoWayAnonWithError_Ordinal = 6368863385719175734lu;
[[maybe_unused]] constexpr inline uint64_t kMainProtocol_OnAnon_Ordinal =
    4815229650203439104lu;
[[maybe_unused]] constexpr inline uint64_t
    kMainProtocol_OnAnonWithError_Ordinal = 5024931894357412354lu;

#ifdef __Fuchsia__
}  // namespace test_protocolpayloads
void fidl::internal::NaturalClientImpl<::test_protocolpayloads::MainProtocol>::
    TwoWayComposed(
        ::test_protocolpayloads_imported::ImportStructPayload&& payload,
        ::fidl::ClientCallback<
            ::test_protocolpayloads::MainProtocol::TwoWayComposed>&& _callback)
        const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_TwoWayComposed_Ordinal};
  return messenger().TwoWay(
      &::test_protocolpayloads::
          test_protocolpayloads_imported_ImportStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocolpayloads::MainProtocol::TwoWayComposed>,
          ::fidl::ClientCallback<
              ::test_protocolpayloads::MainProtocol::TwoWayComposed>>(
          ::test_protocolpayloads::kMainProtocol_TwoWayComposed_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocolpayloads::MainProtocol>::
    TwoWayComposed(
        ::test_protocolpayloads_imported::ImportStructPayload&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocolpayloads::MainProtocol::TwoWayComposed>&& _callback)
        const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_TwoWayComposed_Ordinal};
  return messenger().TwoWay(
      &::test_protocolpayloads::
          test_protocolpayloads_imported_ImportStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocolpayloads::MainProtocol::TwoWayComposed>,
          ::fidl::ClientResponseCallback<
              ::test_protocolpayloads::MainProtocol::TwoWayComposed>>(
          ::test_protocolpayloads::kMainProtocol_TwoWayComposed_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocolpayloads::MainProtocol>::
    TwoWayComposedWithError(
        ::test_protocolpayloads_imported::ImportStructPayload&& payload,
        ::fidl::ClientCallback<
            ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>&&
            _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::
                   kMainProtocol_TwoWayComposedWithError_Ordinal};
  return messenger().TwoWay(
      &::test_protocolpayloads::
          test_protocolpayloads_imported_ImportStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>,
          ::fidl::ClientCallback<
              ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>>(
          ::test_protocolpayloads::
              kMainProtocol_TwoWayComposedWithError_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocolpayloads::MainProtocol>::
    TwoWayComposedWithError(
        ::test_protocolpayloads_imported::ImportStructPayload&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>&&
            _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::
                   kMainProtocol_TwoWayComposedWithError_Ordinal};
  return messenger().TwoWay(
      &::test_protocolpayloads::
          test_protocolpayloads_imported_ImportStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>,
          ::fidl::ClientResponseCallback<
              ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>>(
          ::test_protocolpayloads::
              kMainProtocol_TwoWayComposedWithError_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocolpayloads::MainProtocol>::
    TwoWayLocal(::test_protocolpayloads::LocalStructPayload&& payload,
                ::fidl::ClientCallback<
                    ::test_protocolpayloads::MainProtocol::TwoWayLocal>&&
                    _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_TwoWayLocal_Ordinal};
  return messenger().TwoWay(
      &::test_protocolpayloads::test_protocolpayloads_LocalStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayLocal>,
          ::fidl::ClientCallback<
              ::test_protocolpayloads::MainProtocol::TwoWayLocal>>(
          ::test_protocolpayloads::kMainProtocol_TwoWayLocal_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocolpayloads::MainProtocol>::
    TwoWayLocal(::test_protocolpayloads::LocalStructPayload&& payload,
                ::fidl::ClientResponseCallback<
                    ::test_protocolpayloads::MainProtocol::TwoWayLocal>&&
                    _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_TwoWayLocal_Ordinal};
  return messenger().TwoWay(
      &::test_protocolpayloads::test_protocolpayloads_LocalStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayLocal>,
          ::fidl::ClientResponseCallback<
              ::test_protocolpayloads::MainProtocol::TwoWayLocal>>(
          ::test_protocolpayloads::kMainProtocol_TwoWayLocal_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocolpayloads::MainProtocol>::
    TwoWayLocalWithError(
        ::test_protocolpayloads::LocalStructPayload&& payload,
        ::fidl::ClientCallback<
            ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>&&
            _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocolpayloads::kMainProtocol_TwoWayLocalWithError_Ordinal};
  return messenger().TwoWay(
      &::test_protocolpayloads::test_protocolpayloads_LocalStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>,
          ::fidl::ClientCallback<
              ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>>(
          ::test_protocolpayloads::kMainProtocol_TwoWayLocalWithError_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocolpayloads::MainProtocol>::
    TwoWayLocalWithError(
        ::test_protocolpayloads::LocalStructPayload&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>&&
            _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocolpayloads::kMainProtocol_TwoWayLocalWithError_Ordinal};
  return messenger().TwoWay(
      &::test_protocolpayloads::test_protocolpayloads_LocalStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>,
          ::fidl::ClientResponseCallback<
              ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>>(
          ::test_protocolpayloads::kMainProtocol_TwoWayLocalWithError_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocolpayloads::MainProtocol>::
    TwoWayImport(
        ::test_protocolpayloads_imported::ImportStructPayload&& payload,
        ::fidl::ClientCallback<
            ::test_protocolpayloads::MainProtocol::TwoWayImport>&& _callback)
        const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_TwoWayImport_Ordinal};
  return messenger().TwoWay(
      &::test_protocolpayloads::
          test_protocolpayloads_imported_ImportStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayImport>,
          ::fidl::ClientCallback<
              ::test_protocolpayloads::MainProtocol::TwoWayImport>>(
          ::test_protocolpayloads::kMainProtocol_TwoWayImport_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocolpayloads::MainProtocol>::
    TwoWayImport(
        ::test_protocolpayloads_imported::ImportStructPayload&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocolpayloads::MainProtocol::TwoWayImport>&& _callback)
        const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_TwoWayImport_Ordinal};
  return messenger().TwoWay(
      &::test_protocolpayloads::
          test_protocolpayloads_imported_ImportStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayImport>,
          ::fidl::ClientResponseCallback<
              ::test_protocolpayloads::MainProtocol::TwoWayImport>>(
          ::test_protocolpayloads::kMainProtocol_TwoWayImport_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocolpayloads::MainProtocol>::
    TwoWayImportWithError(
        ::test_protocolpayloads_imported::ImportStructPayload&& payload,
        ::fidl::ClientCallback<
            ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>&&
            _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocolpayloads::kMainProtocol_TwoWayImportWithError_Ordinal};
  return messenger().TwoWay(
      &::test_protocolpayloads::
          test_protocolpayloads_imported_ImportStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>,
          ::fidl::ClientCallback<
              ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>>(
          ::test_protocolpayloads::kMainProtocol_TwoWayImportWithError_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocolpayloads::MainProtocol>::
    TwoWayImportWithError(
        ::test_protocolpayloads_imported::ImportStructPayload&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>&&
            _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocolpayloads::kMainProtocol_TwoWayImportWithError_Ordinal};
  return messenger().TwoWay(
      &::test_protocolpayloads::
          test_protocolpayloads_imported_ImportStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>,
          ::fidl::ClientResponseCallback<
              ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>>(
          ::test_protocolpayloads::kMainProtocol_TwoWayImportWithError_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocolpayloads::MainProtocol>::
    TwoWayAnon(::test_protocolpayloads::MainProtocolTwoWayAnonRequest&& payload,
               ::fidl::ClientCallback<
                   ::test_protocolpayloads::MainProtocol::TwoWayAnon>&&
                   _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_TwoWayAnon_Ordinal};
  return messenger().TwoWay(
      &::test_protocolpayloads::
          test_protocolpayloads_MainProtocolTwoWayAnonRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayAnon>,
          ::fidl::ClientCallback<
              ::test_protocolpayloads::MainProtocol::TwoWayAnon>>(
          ::test_protocolpayloads::kMainProtocol_TwoWayAnon_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocolpayloads::MainProtocol>::
    TwoWayAnon(::test_protocolpayloads::MainProtocolTwoWayAnonRequest&& payload,
               ::fidl::ClientResponseCallback<
                   ::test_protocolpayloads::MainProtocol::TwoWayAnon>&&
                   _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_TwoWayAnon_Ordinal};
  return messenger().TwoWay(
      &::test_protocolpayloads::
          test_protocolpayloads_MainProtocolTwoWayAnonRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayAnon>,
          ::fidl::ClientResponseCallback<
              ::test_protocolpayloads::MainProtocol::TwoWayAnon>>(
          ::test_protocolpayloads::kMainProtocol_TwoWayAnon_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocolpayloads::MainProtocol>::
    TwoWayAnonWithError(
        ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest&&
            payload,
        ::fidl::ClientCallback<
            ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>&&
            _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocolpayloads::kMainProtocol_TwoWayAnonWithError_Ordinal};
  return messenger().TwoWay(
      &::test_protocolpayloads::
          test_protocolpayloads_MainProtocolTwoWayAnonWithErrorRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>,
          ::fidl::ClientCallback<
              ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>>(
          ::test_protocolpayloads::kMainProtocol_TwoWayAnonWithError_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocolpayloads::MainProtocol>::
    TwoWayAnonWithError(
        ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest&&
            payload,
        ::fidl::ClientResponseCallback<
            ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>&&
            _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocolpayloads::kMainProtocol_TwoWayAnonWithError_Ordinal};
  return messenger().TwoWay(
      &::test_protocolpayloads::
          test_protocolpayloads_MainProtocolTwoWayAnonWithErrorRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>,
          ::fidl::ClientResponseCallback<
              ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>>(
          ::test_protocolpayloads::kMainProtocol_TwoWayAnonWithError_Ordinal,
          std::move(_callback)));
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalClientImpl<::test_protocolpayloads::MainProtocol>::OneWayComposed(
        ::test_protocolpayloads_imported::ImportStructPayload&& payload) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_OneWayComposed_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test_protocolpayloads::
          test_protocolpayloads_imported_ImportStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalClientImpl<::test_protocolpayloads::MainProtocol>::OneWayLocal(
        ::test_protocolpayloads::LocalStructPayload&& payload) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_OneWayLocal_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test_protocolpayloads::test_protocolpayloads_LocalStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalClientImpl<::test_protocolpayloads::MainProtocol>::OneWayImport(
        ::test_protocolpayloads_imported::ImportStructPayload&& payload) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_OneWayImport_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test_protocolpayloads::
          test_protocolpayloads_imported_ImportStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalClientImpl<::test_protocolpayloads::MainProtocol>::OneWayAnon(
        ::test_protocolpayloads::MainProtocolOneWayAnonRequest&& payload)
        const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_OneWayAnon_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test_protocolpayloads::
          test_protocolpayloads_MainProtocolOneWayAnonRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocolpayloads {
#endif  // __Fuchsia__

}  // namespace test_protocolpayloads
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo>
fidl::internal::NaturalEventDispatcher<::test_protocolpayloads::MainProtocol>::
    DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocolpayloads::kMainProtocol_OnComposed_Ordinal: {
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Event<::test_protocolpayloads::MainProtocol::OnComposed>>
          decoded =
              ::fidl::Event<::test_protocolpayloads::MainProtocol::OnComposed>::
                  DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->OnComposed(decoded.value());
      }
      return std::nullopt;
    }
    case ::test_protocolpayloads::kMainProtocol_OnComposedWithError_Ordinal: {
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Event<
              ::test_protocolpayloads::MainProtocol::OnComposedWithError>>
          decoded = ::fidl::Event<
              ::test_protocolpayloads::MainProtocol::OnComposedWithError>::
              DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->OnComposedWithError(decoded.value());
      }
      return std::nullopt;
    }
    case ::test_protocolpayloads::kMainProtocol_OnLocal_Ordinal: {
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Event<::test_protocolpayloads::MainProtocol::OnLocal>>
          decoded =
              ::fidl::Event<::test_protocolpayloads::MainProtocol::OnLocal>::
                  DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->OnLocal(decoded.value());
      }
      return std::nullopt;
    }
    case ::test_protocolpayloads::kMainProtocol_OnLocalWithError_Ordinal: {
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Event<
              ::test_protocolpayloads::MainProtocol::OnLocalWithError>>
          decoded = ::fidl::Event<
              ::test_protocolpayloads::MainProtocol::OnLocalWithError>::
              DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->OnLocalWithError(decoded.value());
      }
      return std::nullopt;
    }
    case ::test_protocolpayloads::kMainProtocol_OnImport_Ordinal: {
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Event<::test_protocolpayloads::MainProtocol::OnImport>>
          decoded =
              ::fidl::Event<::test_protocolpayloads::MainProtocol::OnImport>::
                  DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->OnImport(decoded.value());
      }
      return std::nullopt;
    }
    case ::test_protocolpayloads::kMainProtocol_OnImportWithError_Ordinal: {
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Event<
              ::test_protocolpayloads::MainProtocol::OnImportWithError>>
          decoded = ::fidl::Event<
              ::test_protocolpayloads::MainProtocol::OnImportWithError>::
              DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->OnImportWithError(decoded.value());
      }
      return std::nullopt;
    }
    case ::test_protocolpayloads::kMainProtocol_OnAnon_Ordinal: {
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Event<::test_protocolpayloads::MainProtocol::OnAnon>>
          decoded =
              ::fidl::Event<::test_protocolpayloads::MainProtocol::OnAnon>::
                  DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->OnAnon(decoded.value());
      }
      return std::nullopt;
    }
    case ::test_protocolpayloads::kMainProtocol_OnAnonWithError_Ordinal: {
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Event<::test_protocolpayloads::MainProtocol::OnAnonWithError>>
          decoded = ::fidl::Event<
              ::test_protocolpayloads::MainProtocol::OnAnonWithError>::
              DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->OnAnonWithError(decoded.value());
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fitx::result<::fidl::Error> fidl::internal::
    NaturalWeakEventSender<::test_protocolpayloads::MainProtocol>::OnComposed(
        ::test_protocolpayloads_imported::ImportStructPayload payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_OnComposed_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocolpayloads::
          test_protocolpayloads_imported_ImportStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        return _inner().SendEvent(outgoing);
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalEventSender<::test_protocolpayloads::MainProtocol>::OnComposed(
        ::test_protocolpayloads_imported::ImportStructPayload payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_OnComposed_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocolpayloads::
          test_protocolpayloads_imported_ImportStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        outgoing.Write(_transport());
        return ::fidl::Result{outgoing};
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalWeakEventSender<::test_protocolpayloads::MainProtocol>::
    OnComposedWithError(
        ::test_protocolpayloads_imported::
            ComposedProtocolOnComposedWithErrorRequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocolpayloads::kMainProtocol_OnComposedWithError_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocolpayloads::
          test_protocolpayloads_imported_ComposedProtocolOnComposedWithErrorRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        return _inner().SendEvent(outgoing);
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalEventSender<::test_protocolpayloads::MainProtocol>::
    OnComposedWithError(
        ::test_protocolpayloads_imported::
            ComposedProtocolOnComposedWithErrorRequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocolpayloads::kMainProtocol_OnComposedWithError_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocolpayloads::
          test_protocolpayloads_imported_ComposedProtocolOnComposedWithErrorRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        outgoing.Write(_transport());
        return ::fidl::Result{outgoing};
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalWeakEventSender<::test_protocolpayloads::MainProtocol>::OnLocal(
        ::test_protocolpayloads::LocalStructPayload payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_OnLocal_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocolpayloads::test_protocolpayloads_LocalStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        return _inner().SendEvent(outgoing);
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalEventSender<::test_protocolpayloads::MainProtocol>::OnLocal(
        ::test_protocolpayloads::LocalStructPayload payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_OnLocal_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocolpayloads::test_protocolpayloads_LocalStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        outgoing.Write(_transport());
        return ::fidl::Result{outgoing};
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalWeakEventSender<::test_protocolpayloads::MainProtocol>::
    OnLocalWithError(
        ::test_protocolpayloads::MainProtocolOnLocalWithErrorRequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_OnLocalWithError_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocolpayloads::
          test_protocolpayloads_MainProtocolOnLocalWithErrorRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        return _inner().SendEvent(outgoing);
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalEventSender<::test_protocolpayloads::MainProtocol>::OnLocalWithError(
        ::test_protocolpayloads::MainProtocolOnLocalWithErrorRequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_OnLocalWithError_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocolpayloads::
          test_protocolpayloads_MainProtocolOnLocalWithErrorRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        outgoing.Write(_transport());
        return ::fidl::Result{outgoing};
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalWeakEventSender<::test_protocolpayloads::MainProtocol>::OnImport(
        ::test_protocolpayloads_imported::ImportStructPayload payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_OnImport_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocolpayloads::
          test_protocolpayloads_imported_ImportStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        return _inner().SendEvent(outgoing);
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalEventSender<::test_protocolpayloads::MainProtocol>::OnImport(
        ::test_protocolpayloads_imported::ImportStructPayload payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_OnImport_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocolpayloads::
          test_protocolpayloads_imported_ImportStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        outgoing.Write(_transport());
        return ::fidl::Result{outgoing};
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalWeakEventSender<::test_protocolpayloads::MainProtocol>::
    OnImportWithError(
        ::test_protocolpayloads::MainProtocolOnImportWithErrorRequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocolpayloads::kMainProtocol_OnImportWithError_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocolpayloads::
          test_protocolpayloads_MainProtocolOnImportWithErrorRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        return _inner().SendEvent(outgoing);
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalEventSender<::test_protocolpayloads::MainProtocol>::
    OnImportWithError(
        ::test_protocolpayloads::MainProtocolOnImportWithErrorRequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocolpayloads::kMainProtocol_OnImportWithError_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocolpayloads::
          test_protocolpayloads_MainProtocolOnImportWithErrorRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        outgoing.Write(_transport());
        return ::fidl::Result{outgoing};
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalWeakEventSender<::test_protocolpayloads::MainProtocol>::OnAnon(
        ::test_protocolpayloads::MainProtocolOnAnonRequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_OnAnon_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocolpayloads::
          test_protocolpayloads_MainProtocolOnAnonRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        return _inner().SendEvent(outgoing);
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalEventSender<::test_protocolpayloads::MainProtocol>::OnAnon(
        ::test_protocolpayloads::MainProtocolOnAnonRequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_OnAnon_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocolpayloads::
          test_protocolpayloads_MainProtocolOnAnonRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        outgoing.Write(_transport());
        return ::fidl::Result{outgoing};
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalWeakEventSender<::test_protocolpayloads::MainProtocol>::
    OnAnonWithError(
        ::test_protocolpayloads::MainProtocolOnAnonWithErrorRequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_OnAnonWithError_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocolpayloads::
          test_protocolpayloads_MainProtocolOnAnonWithErrorRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        return _inner().SendEvent(outgoing);
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalEventSender<::test_protocolpayloads::MainProtocol>::OnAnonWithError(
        ::test_protocolpayloads::MainProtocolOnAnonWithErrorRequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_OnAnonWithError_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocolpayloads::
          test_protocolpayloads_MainProtocolOnAnonWithErrorRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        outgoing.Write(_transport());
        return ::fidl::Result{outgoing};
      });
  return ::fidl::internal::ToFitxResult(result);
}

#endif  // __Fuchsia__

void fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayComposed>::
    Reply(::test_protocolpayloads_imported::ImportStructPayload&& payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_TwoWayComposed_Ordinal};
  _messenger.SendReply(
      &::test_protocolpayloads::
          test_protocolpayloads_imported_ImportStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>::
    Reply(::test_protocolpayloads_imported::
              ComposedProtocolTwoWayComposedWithErrorTopResponse&& payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::
                   kMainProtocol_TwoWayComposedWithError_Ordinal};
  _messenger.SendReply(
      &::test_protocolpayloads::
          test_protocolpayloads_imported_ComposedProtocolTwoWayComposedWithErrorTopResponseTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayLocal>::
    Reply(::test_protocolpayloads::LocalStructPayload&& payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_TwoWayLocal_Ordinal};
  _messenger.SendReply(
      &::test_protocolpayloads::test_protocolpayloads_LocalStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>::
    Reply(::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorTopResponse&&
              payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocolpayloads::kMainProtocol_TwoWayLocalWithError_Ordinal};
  _messenger.SendReply(
      &::test_protocolpayloads::
          test_protocolpayloads_MainProtocolTwoWayLocalWithErrorTopResponseTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayImport>::
    Reply(::test_protocolpayloads_imported::ImportStructPayload&& payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_TwoWayImport_Ordinal};
  _messenger.SendReply(
      &::test_protocolpayloads::
          test_protocolpayloads_imported_ImportStructPayloadTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>::
    Reply(
        ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorTopResponse&&
            payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocolpayloads::kMainProtocol_TwoWayImportWithError_Ordinal};
  _messenger.SendReply(
      &::test_protocolpayloads::
          test_protocolpayloads_MainProtocolTwoWayImportWithErrorTopResponseTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayAnon>::
    Reply(
        ::test_protocolpayloads::MainProtocolTwoWayAnonTopResponse&& payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocolpayloads::kMainProtocol_TwoWayAnon_Ordinal};
  _messenger.SendReply(
      &::test_protocolpayloads::
          test_protocolpayloads_MainProtocolTwoWayAnonTopResponseTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>::
    Reply(::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorTopResponse&&
              payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocolpayloads::kMainProtocol_TwoWayAnonWithError_Ordinal};
  _messenger.SendReply(
      &::test_protocolpayloads::
          test_protocolpayloads_MainProtocolTwoWayAnonWithErrorTopResponseTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocolpayloads::MainProtocol>::entries_[] = {
    {
        ::test_protocolpayloads::kMainProtocol_OneWayComposed_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<
                  ::test_protocolpayloads::MainProtocol::OneWayComposed>>
              decoded = ::fidl::Request<
                  ::test_protocolpayloads::MainProtocol::OneWayComposed>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocolpayloads::MainProtocol::OneWayComposed>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocolpayloads::MainProtocol>*>(
              interface)
              ->OneWayComposed(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocolpayloads::kMainProtocol_TwoWayComposed_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<
                  ::test_protocolpayloads::MainProtocol::TwoWayComposed>>
              decoded = ::fidl::Request<
                  ::test_protocolpayloads::MainProtocol::TwoWayComposed>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocolpayloads::MainProtocol::TwoWayComposed>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocolpayloads::MainProtocol>*>(
              interface)
              ->TwoWayComposed(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocolpayloads::kMainProtocol_TwoWayComposedWithError_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<::fidl::Error,
                         ::fidl::Request<::test_protocolpayloads::MainProtocol::
                                             TwoWayComposedWithError>>
              decoded = ::fidl::Request<::test_protocolpayloads::MainProtocol::
                                            TwoWayComposedWithError>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>::
              Sync completer(txn);
          static_cast<::fidl::Server<::test_protocolpayloads::MainProtocol>*>(
              interface)
              ->TwoWayComposedWithError(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocolpayloads::kMainProtocol_OneWayLocal_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<
                  ::test_protocolpayloads::MainProtocol::OneWayLocal>>
              decoded = ::fidl::Request<
                  ::test_protocolpayloads::MainProtocol::OneWayLocal>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocolpayloads::MainProtocol::OneWayLocal>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocolpayloads::MainProtocol>*>(
              interface)
              ->OneWayLocal(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocolpayloads::kMainProtocol_TwoWayLocal_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<
                  ::test_protocolpayloads::MainProtocol::TwoWayLocal>>
              decoded = ::fidl::Request<
                  ::test_protocolpayloads::MainProtocol::TwoWayLocal>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocolpayloads::MainProtocol::TwoWayLocal>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocolpayloads::MainProtocol>*>(
              interface)
              ->TwoWayLocal(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocolpayloads::kMainProtocol_TwoWayLocalWithError_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<
                  ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>>
              decoded = ::fidl::Request<
                  ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocolpayloads::MainProtocol>*>(
              interface)
              ->TwoWayLocalWithError(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocolpayloads::kMainProtocol_OneWayImport_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<
                  ::test_protocolpayloads::MainProtocol::OneWayImport>>
              decoded = ::fidl::Request<
                  ::test_protocolpayloads::MainProtocol::OneWayImport>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocolpayloads::MainProtocol::OneWayImport>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocolpayloads::MainProtocol>*>(
              interface)
              ->OneWayImport(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocolpayloads::kMainProtocol_TwoWayImport_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<
                  ::test_protocolpayloads::MainProtocol::TwoWayImport>>
              decoded = ::fidl::Request<
                  ::test_protocolpayloads::MainProtocol::TwoWayImport>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocolpayloads::MainProtocol::TwoWayImport>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocolpayloads::MainProtocol>*>(
              interface)
              ->TwoWayImport(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocolpayloads::kMainProtocol_TwoWayImportWithError_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<
                  ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>>
              decoded = ::fidl::Request<::test_protocolpayloads::MainProtocol::
                                            TwoWayImportWithError>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>::
              Sync completer(txn);
          static_cast<::fidl::Server<::test_protocolpayloads::MainProtocol>*>(
              interface)
              ->TwoWayImportWithError(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocolpayloads::kMainProtocol_OneWayAnon_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<::fidl::Error,
                         ::fidl::Request<
                             ::test_protocolpayloads::MainProtocol::OneWayAnon>>
              decoded = ::fidl::Request<
                  ::test_protocolpayloads::MainProtocol::OneWayAnon>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocolpayloads::MainProtocol::OneWayAnon>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocolpayloads::MainProtocol>*>(
              interface)
              ->OneWayAnon(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocolpayloads::kMainProtocol_TwoWayAnon_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<::fidl::Error,
                         ::fidl::Request<
                             ::test_protocolpayloads::MainProtocol::TwoWayAnon>>
              decoded = ::fidl::Request<
                  ::test_protocolpayloads::MainProtocol::TwoWayAnon>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocolpayloads::MainProtocol::TwoWayAnon>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocolpayloads::MainProtocol>*>(
              interface)
              ->TwoWayAnon(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocolpayloads::kMainProtocol_TwoWayAnonWithError_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<
                  ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>>
              decoded = ::fidl::Request<
                  ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocolpayloads::MainProtocol>*>(
              interface)
              ->TwoWayAnonWithError(decoded.value(), completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocolpayloads::MainProtocol>::entries_end_ = &entries_[12];

void fidl::internal::
    NaturalServerDispatcher<::test_protocolpayloads::MainProtocol>::Dispatch(
        ::fidl::Server<::test_protocolpayloads::MainProtocol>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocolpayloads::MainProtocol>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocolpayloads::MainProtocol>::Dispatch(this, std::move(msg),
                                                       std::move(
                                                           transport_context),
                                                       txn);
}
#endif  // __Fuchsia__
