// WARNING: This file is machine generated by fidlgen_llcpp.

#include <fidl/test.protocols/cpp/natural_messaging.h>

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kHandleRightsProtocol_NoResponseMethod_Ordinal = 1155044649514904573lu;
[[maybe_unused]] constexpr inline uint64_t
    kHandleRightsProtocol_ResponseMethod_Ordinal = 5956276128041940295lu;
[[maybe_unused]] constexpr inline uint64_t
    kHandleRightsProtocol_AnEvent_Ordinal = 476727631355490611lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::HandleRightsProtocol>::
    ResponseMethod(
        ::test_protocols::HandleRightsProtocolResponseMethodRequest&& payload,
        ::fidl::ClientCallback<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>&& _callback)
        const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_HandleRightsProtocolResponseMethodRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>,
          ::fidl::ClientCallback<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>>(
          ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::HandleRightsProtocol>::
    ResponseMethod(
        ::test_protocols::HandleRightsProtocolResponseMethodRequest&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>&& _callback)
        const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_HandleRightsProtocolResponseMethodRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>>(
          ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal,
          std::move(_callback)));
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalClientImpl<::test_protocols::HandleRightsProtocol>::NoResponseMethod(
        ::test_protocols::HandleRightsProtocolNoResponseMethodRequest&& payload)
        const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::kHandleRightsProtocol_NoResponseMethod_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test_protocols::
          test_protocols_HandleRightsProtocolNoResponseMethodRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo>
fidl::internal::NaturalEventDispatcher<::test_protocols::HandleRightsProtocol>::
    DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal: {
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent>>
          decoded =
              ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent>::
                  DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->AnEvent(decoded.value());
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fitx::result<::fidl::Error> fidl::internal::
    NaturalWeakEventSender<::test_protocols::HandleRightsProtocol>::AnEvent(
        ::test_protocols::HandleRightsProtocolAnEventRequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocols::test_protocols_HandleRightsProtocolAnEventRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        return _inner().SendEvent(outgoing);
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalEventSender<::test_protocols::HandleRightsProtocol>::AnEvent(
        ::test_protocols::HandleRightsProtocolAnEventRequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocols::test_protocols_HandleRightsProtocolAnEventRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        outgoing.Write(_transport());
        return ::fidl::Result{outgoing};
      });
  return ::fidl::internal::ToFitxResult(result);
}

#endif  // __Fuchsia__

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>::
    Reply(::test_protocols::HandleRightsProtocolResponseMethodTopResponse&&
              payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal};
  _messenger.SendReply(
      &::test_protocols::
          test_protocols_HandleRightsProtocolResponseMethodTopResponseTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::HandleRightsProtocol>::entries_[] = {
    {
        ::test_protocols::kHandleRightsProtocol_NoResponseMethod_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<
                  ::test_protocols::HandleRightsProtocol::NoResponseMethod>>
              decoded = ::fidl::Request<
                  ::test_protocols::HandleRightsProtocol::NoResponseMethod>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::HandleRightsProtocol::NoResponseMethod>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::HandleRightsProtocol>*>(
              interface)
              ->NoResponseMethod(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<
                  ::test_protocols::HandleRightsProtocol::ResponseMethod>>
              decoded = ::fidl::Request<
                  ::test_protocols::HandleRightsProtocol::ResponseMethod>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::HandleRightsProtocol>*>(
              interface)
              ->ResponseMethod(decoded.value(), completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::HandleRightsProtocol>::entries_end_ = &entries_[2];

void fidl::internal::
    NaturalServerDispatcher<::test_protocols::HandleRightsProtocol>::Dispatch(
        ::fidl::Server<::test_protocols::HandleRightsProtocol>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::HandleRightsProtocol>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::HandleRightsProtocol>::Dispatch(this, std::move(msg),
                                                        std::move(
                                                            transport_context),
                                                        txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal =
        5413654872775949227lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal =
        1631193469798418024lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal =
        9037369643591427517lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal =
        7326057319832554103lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal =
        2877322062572412767lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal =
        6417226585456833969lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal =
        5397663296507358806lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_OnWithResponse_Ordinal =
        5811598563493228968lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestEmptyResponse(
        ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                   NoRequestEmptyResponse>&& _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal};
  return messenger().TwoWay(
      nullptr,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestEmptyResponse>,
          ::fidl::ClientCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestEmptyResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestEmptyResponse(::fidl::ClientResponseCallback<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestEmptyResponse>&& _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal};
  return messenger().TwoWay(
      nullptr,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestEmptyResponse>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestEmptyResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestWithResponse(
        ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                   NoRequestWithResponse>&& _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal};
  return messenger().TwoWay(
      nullptr,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestWithResponse>,
          ::fidl::ClientCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestWithResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestWithResponse(::fidl::ClientResponseCallback<
                          ::test_protocols::WithAndWithoutRequestResponse::
                              NoRequestWithResponse>&& _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal};
  return messenger().TwoWay(
      nullptr,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestWithResponse>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestWithResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestEmptyResponse(
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&&
                payload,
        ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                   WithRequestEmptyResponse>&& _callback)
        const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestEmptyResponse>,
          ::fidl::ClientCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestEmptyResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestEmptyResponse(
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&&
                payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestEmptyResponse>&& _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestEmptyResponse>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestEmptyResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestWithResponse(
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestWithResponseRequest&&
                payload,
        ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                   WithRequestWithResponse>&& _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestWithResponse>,
          ::fidl::ClientCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestWithResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestWithResponse(
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestWithResponseRequest&&
                payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestWithResponse>&& _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestWithResponse>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestWithResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal,
          std::move(_callback)));
}

::fitx::result<::fidl::Error> fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::NoRequestNoResponse()
    const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::
                   kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      nullptr,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder));
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestNoResponse(
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestNoResponseRequest&& payload)
        const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::NaturalEventDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::
    DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::
        kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal: {
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Event<
              ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>
          decoded = ::fidl::Event<
              ::test_protocols::WithAndWithoutRequestResponse::
                  OnEmptyResponse>::DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->OnEmptyResponse(decoded.value());
      }
      return std::nullopt;
    }
    case ::test_protocols::
        kWithAndWithoutRequestResponse_OnWithResponse_Ordinal: {
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Event<
              ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>
          decoded = ::fidl::Event<
              ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>::
              DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->OnWithResponse(decoded.value());
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fitx::result<::fidl::Error> fidl::internal::NaturalWeakEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::
                   kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      nullptr,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      [this](fidl::OutgoingMessage outgoing) {
        return _inner().SendEvent(outgoing);
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::NaturalEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::
                   kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      nullptr,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      [this](fidl::OutgoingMessage outgoing) {
        outgoing.Write(_transport());
        return ::fidl::Result{outgoing};
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::NaturalWeakEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::
    OnWithResponse(
        ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest
            payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::
                   kWithAndWithoutRequestResponse_OnWithResponse_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        return _inner().SendEvent(outgoing);
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::NaturalEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::
    OnWithResponse(
        ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest
            payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::
                   kWithAndWithoutRequestResponse_OnWithResponse_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        outgoing.Write(_transport());
        return ::fidl::Result{outgoing};
      });
  return ::fidl::internal::ToFitxResult(result);
}

#endif  // __Fuchsia__

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::
    Reply() {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal};
  _messenger.SendReply(
      nullptr,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder));
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::
    Reply(::test_protocols::
              WithAndWithoutRequestResponseNoRequestWithResponseTopResponse&&
                  payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal};
  _messenger.SendReply(
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::
    Reply() {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal};
  _messenger.SendReply(
      nullptr,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder));
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::
    Reply(::test_protocols::
              WithAndWithoutRequestResponseWithRequestWithResponseTopResponse&&
                  payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal};
  _messenger.SendReply(
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::entries_[] = {
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                                  NoRequestNoResponse>>
              decoded = ::fidl::Request<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      NoRequestNoResponse>::DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestNoResponse>::Sync completer(txn);
          static_cast<
              ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>*>(
              interface)
              ->NoRequestNoResponse(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                                  NoRequestEmptyResponse>>
              decoded = ::fidl::Request<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      NoRequestEmptyResponse>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestEmptyResponse>::Sync completer(txn);
          static_cast<
              ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>*>(
              interface)
              ->NoRequestEmptyResponse(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                                  NoRequestWithResponse>>
              decoded = ::fidl::Request<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      NoRequestWithResponse>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestWithResponse>::Sync completer(txn);
          static_cast<
              ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>*>(
              interface)
              ->NoRequestWithResponse(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                                  WithRequestNoResponse>>
              decoded = ::fidl::Request<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      WithRequestNoResponse>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestNoResponse>::Sync completer(txn);
          static_cast<
              ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>*>(
              interface)
              ->WithRequestNoResponse(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                                  WithRequestEmptyResponse>>
              decoded = ::fidl::Request<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      WithRequestEmptyResponse>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestEmptyResponse>::Sync completer(txn);
          static_cast<
              ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>*>(
              interface)
              ->WithRequestEmptyResponse(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                                  WithRequestWithResponse>>
              decoded = ::fidl::Request<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      WithRequestWithResponse>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestWithResponse>::Sync completer(txn);
          static_cast<
              ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>*>(
              interface)
              ->WithRequestWithResponse(decoded.value(), completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::entries_end_ =
    &entries_[6];

void fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::
    Dispatch(
        ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::WithAndWithoutRequestResponse>::
    dispatch_message(
        ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
        ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::WithAndWithoutRequestResponse>::
      Dispatch(this, std::move(msg), std::move(transport_context), txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t kTransitional_Request_Ordinal =
    5849263021838298888lu;
[[maybe_unused]] constexpr inline uint64_t kTransitional_OneWay_Ordinal =
    4336658926562441191lu;
[[maybe_unused]] constexpr inline uint64_t kTransitional_Event_Ordinal =
    8507647465196374081lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::Transitional>::Request(
    ::test_protocols::TransitionalRequestRequest&& payload,
    ::fidl::ClientCallback<::test_protocols::Transitional::Request>&& _callback)
    const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kTransitional_Request_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::test_protocols_TransitionalRequestRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::Transitional::Request>,
          ::fidl::ClientCallback<::test_protocols::Transitional::Request>>(
          ::test_protocols::kTransitional_Request_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::Transitional>::Request(
    ::test_protocols::TransitionalRequestRequest&& payload,
    ::fidl::ClientResponseCallback<::test_protocols::Transitional::Request>&&
        _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kTransitional_Request_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::test_protocols_TransitionalRequestRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::Transitional::Request>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::Transitional::Request>>(
          ::test_protocols::kTransitional_Request_Ordinal,
          std::move(_callback)));
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalClientImpl<::test_protocols::Transitional>::OneWay(
    ::test_protocols::TransitionalOneWayRequest&& payload) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kTransitional_OneWay_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test_protocols::test_protocols_TransitionalOneWayRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::Transitional>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kTransitional_Event_Ordinal: {
      ::fitx::result<::fidl::Error,
                     ::fidl::Event<::test_protocols::Transitional::Event>>
          decoded = ::fidl::Event<::test_protocols::Transitional::Event>::
              DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->Event(decoded.value());
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fitx::result<::fidl::Error>
fidl::internal::NaturalWeakEventSender<::test_protocols::Transitional>::Event(
    ::test_protocols::TransitionalEventRequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kTransitional_Event_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocols::test_protocols_TransitionalEventRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        return _inner().SendEvent(outgoing);
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalEventSender<::test_protocols::Transitional>::Event(
    ::test_protocols::TransitionalEventRequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kTransitional_Event_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocols::test_protocols_TransitionalEventRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        outgoing.Write(_transport());
        return ::fidl::Result{outgoing};
      });
  return ::fidl::internal::ToFitxResult(result);
}

#endif  // __Fuchsia__

void fidl::internal::
    NaturalCompleterBase<::test_protocols::Transitional::Request>::Reply(
        ::test_protocols::TransitionalRequestTopResponse&& payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kTransitional_Request_Ordinal};
  _messenger.SendReply(
      &::test_protocols::test_protocols_TransitionalRequestTopResponseTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::Transitional>::entries_[] = {
    {
        ::test_protocols::kTransitional_Request_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<::test_protocols::Transitional::Request>>
              decoded =
                  ::fidl::Request<::test_protocols::Transitional::Request>::
                      DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::Transitional::Request>::Sync completer(txn);
          static_cast<::fidl::Server<::test_protocols::Transitional>*>(
              interface)
              ->Request(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kTransitional_OneWay_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<::test_protocols::Transitional::OneWay>>
              decoded =
                  ::fidl::Request<::test_protocols::Transitional::OneWay>::
                      DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::Transitional::OneWay>::Sync completer(txn);
          static_cast<::fidl::Server<::test_protocols::Transitional>*>(
              interface)
              ->OneWay(decoded.value(), completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::Transitional>::entries_end_ = &entries_[2];

void fidl::internal::NaturalServerDispatcher<::test_protocols::Transitional>::
    Dispatch(::fidl::Server<::test_protocols::Transitional>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::Transitional>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::Transitional>::Dispatch(this, std::move(msg),
                                                std::move(transport_context),
                                                txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kMethodWithUnion_UnionMethod_Ordinal = 4124874338266649112lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fitx::result<::fidl::Error> fidl::internal::
    NaturalClientImpl<::test_protocols::MethodWithUnion>::UnionMethod(
        ::test_protocols::MethodWithUnionUnionMethodRequest&& payload) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kMethodWithUnion_UnionMethod_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test_protocols::test_protocols_MethodWithUnionUnionMethodRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::MethodWithUnion>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::MethodWithUnion>::entries_[] = {
    {
        ::test_protocols::kMethodWithUnion_UnionMethod_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod>>
              decoded = ::fidl::Request<
                  ::test_protocols::MethodWithUnion::UnionMethod>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::MethodWithUnion::UnionMethod>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::MethodWithUnion>*>(
              interface)
              ->UnionMethod(decoded.value(), completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::MethodWithUnion>::entries_end_ = &entries_[1];

void fidl::internal::
    NaturalServerDispatcher<::test_protocols::MethodWithUnion>::Dispatch(
        ::fidl::Server<::test_protocols::MethodWithUnion>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::MethodWithUnion>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::MethodWithUnion>::Dispatch(this, std::move(msg),
                                                   std::move(transport_context),
                                                   txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kWithProtocolEnds_ClientEnds_Ordinal = 5870448041025163330lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithProtocolEnds_ServerEnds_Ordinal = 8115535094437022259lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithProtocolEnds_StructContainingEnds_Ordinal = 4076866772260025813lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    ClientEnds(
        ::test_protocols::WithProtocolEndsClientEndsRequest&& payload,
        ::fidl::ClientCallback<::test_protocols::WithProtocolEnds::ClientEnds>&&
            _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::test_protocols_WithProtocolEndsClientEndsRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>,
          ::fidl::ClientCallback<
              ::test_protocols::WithProtocolEnds::ClientEnds>>(
          ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    ClientEnds(
        ::test_protocols::WithProtocolEndsClientEndsRequest&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::WithProtocolEnds::ClientEnds>&& _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::test_protocols_WithProtocolEndsClientEndsRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithProtocolEnds::ClientEnds>>(
          ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    ServerEnds(
        ::test_protocols::WithProtocolEndsServerEndsRequest&& payload,
        ::fidl::ClientCallback<::test_protocols::WithProtocolEnds::ServerEnds>&&
            _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::test_protocols_WithProtocolEndsServerEndsRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>,
          ::fidl::ClientCallback<
              ::test_protocols::WithProtocolEnds::ServerEnds>>(
          ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    ServerEnds(
        ::test_protocols::WithProtocolEndsServerEndsRequest&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::WithProtocolEnds::ServerEnds>&& _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::test_protocols_WithProtocolEndsServerEndsRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithProtocolEnds::ServerEnds>>(
          ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    StructContainingEnds(
        ::test_protocols::WithProtocolEndsStructContainingEndsRequest&& payload,
        ::fidl::ClientCallback<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>&&
            _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithProtocolEndsStructContainingEndsRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>,
          ::fidl::ClientCallback<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>>(
          ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    StructContainingEnds(
        ::test_protocols::WithProtocolEndsStructContainingEndsRequest&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>&&
            _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithProtocolEndsStructContainingEndsRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>>(
          ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal,
          std::move(_callback)));
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::WithProtocolEnds>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

#endif  // __Fuchsia__

void fidl::internal::
    NaturalCompleterBase<::test_protocols::WithProtocolEnds::ClientEnds>::Reply(
        ::test_protocols::WithProtocolEndsClientEndsTopResponse&& payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal};
  _messenger.SendReply(
      &::test_protocols::
          test_protocols_WithProtocolEndsClientEndsTopResponseTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

void fidl::internal::
    NaturalCompleterBase<::test_protocols::WithProtocolEnds::ServerEnds>::Reply(
        ::test_protocols::WithProtocolEndsServerEndsTopResponse&& payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal};
  _messenger.SendReply(
      &::test_protocols::
          test_protocols_WithProtocolEndsServerEndsTopResponseTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>::
    Reply(::test_protocols::WithProtocolEndsStructContainingEndsTopResponse&&
              payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal};
  _messenger.SendReply(
      &::test_protocols::
          test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithProtocolEnds>::entries_[] = {
    {
        ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds>>
              decoded = ::fidl::Request<
                  ::test_protocols::WithProtocolEnds::ClientEnds>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithProtocolEnds::ClientEnds>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithProtocolEnds>*>(
              interface)
              ->ClientEnds(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds>>
              decoded = ::fidl::Request<
                  ::test_protocols::WithProtocolEnds::ServerEnds>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithProtocolEnds::ServerEnds>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithProtocolEnds>*>(
              interface)
              ->ServerEnds(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<
                  ::test_protocols::WithProtocolEnds::StructContainingEnds>>
              decoded = ::fidl::Request<
                  ::test_protocols::WithProtocolEnds::StructContainingEnds>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithProtocolEnds>*>(
              interface)
              ->StructContainingEnds(decoded.value(), completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithProtocolEnds>::entries_end_ = &entries_[3];

void fidl::internal::
    NaturalServerDispatcher<::test_protocols::WithProtocolEnds>::Dispatch(
        ::fidl::Server<::test_protocols::WithProtocolEnds>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::WithProtocolEnds>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::WithProtocolEnds>::Dispatch(this, std::move(msg),
                                                    std::move(
                                                        transport_context),
                                                    txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t kManyParameters_Fifteen_Ordinal =
    6423043252952467815lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fitx::result<::fidl::Error>
fidl::internal::NaturalClientImpl<::test_protocols::ManyParameters>::Fifteen(
    ::test_protocols::ManyParametersFifteenRequest&& payload) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kManyParameters_Fifteen_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test_protocols::test_protocols_ManyParametersFifteenRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::ManyParameters>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::ManyParameters>::entries_[] = {
    {
        ::test_protocols::kManyParameters_Fifteen_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<::test_protocols::ManyParameters::Fifteen>>
              decoded =
                  ::fidl::Request<::test_protocols::ManyParameters::Fifteen>::
                      DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::ManyParameters::Fifteen>::Sync completer(txn);
          static_cast<::fidl::Server<::test_protocols::ManyParameters>*>(
              interface)
              ->Fifteen(decoded.value(), completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::ManyParameters>::entries_end_ = &entries_[1];

void fidl::internal::NaturalServerDispatcher<::test_protocols::ManyParameters>::
    Dispatch(::fidl::Server<::test_protocols::ManyParameters>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::ManyParameters>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::ManyParameters>::Dispatch(this, std::move(msg),
                                                  std::move(transport_context),
                                                  txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_ResponseAsStruct_Ordinal = 268248568430741139lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_ErrorAsPrimitive_Ordinal = 6930994461233198567lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_ErrorAsEnum_Ordinal = 5491891352371277635lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_HandleInResult_Ordinal = 1371676333068455103lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ResponseAsStruct(::fidl::ClientCallback<
                     ::test_protocols::WithErrorSyntax::ResponseAsStruct>&&
                         _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal};
  return messenger().TwoWay(
      nullptr,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>,
          ::fidl::ClientCallback<
              ::test_protocols::WithErrorSyntax::ResponseAsStruct>>(
          ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ResponseAsStruct(::fidl::ClientResponseCallback<
                     ::test_protocols::WithErrorSyntax::ResponseAsStruct>&&
                         _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal};
  return messenger().TwoWay(
      nullptr,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithErrorSyntax::ResponseAsStruct>>(
          ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ErrorAsPrimitive(::fidl::ClientCallback<
                     ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&&
                         _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal};
  return messenger().TwoWay(
      nullptr,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
          ::fidl::ClientCallback<
              ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>(
          ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ErrorAsPrimitive(::fidl::ClientResponseCallback<
                     ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&&
                         _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal};
  return messenger().TwoWay(
      nullptr,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>(
          ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ErrorAsEnum(
        ::fidl::ClientCallback<::test_protocols::WithErrorSyntax::ErrorAsEnum>&&
            _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal};
  return messenger().TwoWay(
      nullptr,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>,
          ::fidl::ClientCallback<
              ::test_protocols::WithErrorSyntax::ErrorAsEnum>>(
          ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ErrorAsEnum(
        ::fidl::ClientResponseCallback<
            ::test_protocols::WithErrorSyntax::ErrorAsEnum>&& _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal};
  return messenger().TwoWay(
      nullptr,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithErrorSyntax::ErrorAsEnum>>(
          ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    HandleInResult(::fidl::ClientCallback<
                   ::test_protocols::WithErrorSyntax::HandleInResult>&&
                       _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal};
  return messenger().TwoWay(
      nullptr,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>,
          ::fidl::ClientCallback<
              ::test_protocols::WithErrorSyntax::HandleInResult>>(
          ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    HandleInResult(::fidl::ClientResponseCallback<
                   ::test_protocols::WithErrorSyntax::HandleInResult>&&
                       _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal};
  return messenger().TwoWay(
      nullptr,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithErrorSyntax::HandleInResult>>(
          ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal,
          std::move(_callback)));
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::WithErrorSyntax>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

#endif  // __Fuchsia__

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    Reply(::test_protocols::WithErrorSyntaxResponseAsStructTopResponse&&
              payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal};
  _messenger.SendReply(
      &::test_protocols::
          test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::
    Reply(::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse&&
              payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal};
  _messenger.SendReply(
      &::test_protocols::
          test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

void fidl::internal::
    NaturalCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsEnum>::Reply(
        ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse&& payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal};
  _messenger.SendReply(
      &::test_protocols::
          test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithErrorSyntax::HandleInResult>::
    Reply(
        ::test_protocols::WithErrorSyntaxHandleInResultTopResponse&& payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal};
  _messenger.SendReply(
      &::test_protocols::
          test_protocols_WithErrorSyntaxHandleInResultTopResponseTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithErrorSyntax>::entries_[] = {
    {
        ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<
                  ::test_protocols::WithErrorSyntax::ResponseAsStruct>>
              decoded = ::fidl::Request<
                  ::test_protocols::WithErrorSyntax::ResponseAsStruct>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithErrorSyntax::ResponseAsStruct>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithErrorSyntax>*>(
              interface)
              ->ResponseAsStruct(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<
                  ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
              decoded = ::fidl::Request<
                  ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithErrorSyntax>*>(
              interface)
              ->ErrorAsPrimitive(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsEnum>>
              decoded = ::fidl::Request<
                  ::test_protocols::WithErrorSyntax::ErrorAsEnum>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithErrorSyntax::ErrorAsEnum>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithErrorSyntax>*>(
              interface)
              ->ErrorAsEnum(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<::fidl::Error,
                         ::fidl::Request<
                             ::test_protocols::WithErrorSyntax::HandleInResult>>
              decoded = ::fidl::Request<
                  ::test_protocols::WithErrorSyntax::HandleInResult>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithErrorSyntax::HandleInResult>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithErrorSyntax>*>(
              interface)
              ->HandleInResult(decoded.value(), completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithErrorSyntax>::entries_end_ = &entries_[4];

void fidl::internal::
    NaturalServerDispatcher<::test_protocols::WithErrorSyntax>::Dispatch(
        ::fidl::Server<::test_protocols::WithErrorSyntax>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::WithErrorSyntax>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::WithErrorSyntax>::Dispatch(this, std::move(msg),
                                                   std::move(transport_context),
                                                   txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kDiscoverableProtocol_Method_Ordinal = 3455873048082739435lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fitx::result<::fidl::Error> fidl::internal::NaturalClientImpl<
    ::test_protocols::DiscoverableProtocol>::Method() const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kDiscoverableProtocol_Method_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      nullptr,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo>
fidl::internal::NaturalEventDispatcher<::test_protocols::DiscoverableProtocol>::
    DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::DiscoverableProtocol>::entries_[] = {
    {
        ::test_protocols::kDiscoverableProtocol_Method_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<::test_protocols::DiscoverableProtocol::Method>>
              decoded = ::fidl::Request<
                  ::test_protocols::DiscoverableProtocol::Method>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::DiscoverableProtocol::Method>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::DiscoverableProtocol>*>(
              interface)
              ->Method(decoded.value(), completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::DiscoverableProtocol>::entries_end_ = &entries_[1];

void fidl::internal::
    NaturalServerDispatcher<::test_protocols::DiscoverableProtocol>::Dispatch(
        ::fidl::Server<::test_protocols::DiscoverableProtocol>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::DiscoverableProtocol>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::DiscoverableProtocol>::Dispatch(this, std::move(msg),
                                                        std::move(
                                                            transport_context),
                                                        txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_MethodA_Ordinal =
    3155008840945527714lu;
[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_EventA_Ordinal =
    2220452875311597006lu;
[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_MethodB_Ordinal =
    8903004957800778182lu;
[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_TakeHandle_Ordinal =
    591935489944717925lu;
[[maybe_unused]] constexpr inline uint64_t
    kChannelProtocol_MutateSocket_Ordinal = 7411742788430590287lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    MethodB(::test_protocols::ChannelProtocolMethodBRequest&& payload,
            ::fidl::ClientCallback<::test_protocols::ChannelProtocol::MethodB>&&
                _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_MethodB_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::test_protocols_ChannelProtocolMethodBRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>,
          ::fidl::ClientCallback<::test_protocols::ChannelProtocol::MethodB>>(
          ::test_protocols::kChannelProtocol_MethodB_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    MethodB(::test_protocols::ChannelProtocolMethodBRequest&& payload,
            ::fidl::ClientResponseCallback<
                ::test_protocols::ChannelProtocol::MethodB>&& _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_MethodB_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::test_protocols_ChannelProtocolMethodBRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::ChannelProtocol::MethodB>>(
          ::test_protocols::kChannelProtocol_MethodB_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    TakeHandle(
        ::test_protocols::ChannelProtocolTakeHandleRequest&& payload,
        ::fidl::ClientCallback<::test_protocols::ChannelProtocol::TakeHandle>&&
            _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_TakeHandle_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::test_protocols_ChannelProtocolTakeHandleRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle>,
          ::fidl::ClientCallback<
              ::test_protocols::ChannelProtocol::TakeHandle>>(
          ::test_protocols::kChannelProtocol_TakeHandle_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    TakeHandle(
        ::test_protocols::ChannelProtocolTakeHandleRequest&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::ChannelProtocol::TakeHandle>&& _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_TakeHandle_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::test_protocols_ChannelProtocolTakeHandleRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::ChannelProtocol::TakeHandle>>(
          ::test_protocols::kChannelProtocol_TakeHandle_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    MutateSocket(::test_protocols::ChannelProtocolMutateSocketRequest&& payload,
                 ::fidl::ClientCallback<
                     ::test_protocols::ChannelProtocol::MutateSocket>&&
                     _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_MutateSocket_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::test_protocols_ChannelProtocolMutateSocketRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>,
          ::fidl::ClientCallback<
              ::test_protocols::ChannelProtocol::MutateSocket>>(
          ::test_protocols::kChannelProtocol_MutateSocket_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    MutateSocket(::test_protocols::ChannelProtocolMutateSocketRequest&& payload,
                 ::fidl::ClientResponseCallback<
                     ::test_protocols::ChannelProtocol::MutateSocket>&&
                     _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_MutateSocket_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::test_protocols_ChannelProtocolMutateSocketRequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::ChannelProtocol::MutateSocket>>(
          ::test_protocols::kChannelProtocol_MutateSocket_Ordinal,
          std::move(_callback)));
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::MethodA(
    ::test_protocols::ChannelProtocolMethodARequest&& payload) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_MethodA_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test_protocols::test_protocols_ChannelProtocolMethodARequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::ChannelProtocol>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kChannelProtocol_EventA_Ordinal: {
      ::fitx::result<::fidl::Error,
                     ::fidl::Event<::test_protocols::ChannelProtocol::EventA>>
          decoded = ::fidl::Event<::test_protocols::ChannelProtocol::EventA>::
              DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->EventA(decoded.value());
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fitx::result<::fidl::Error> fidl::internal::
    NaturalWeakEventSender<::test_protocols::ChannelProtocol>::EventA(
        ::test_protocols::ChannelProtocolEventARequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_EventA_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocols::test_protocols_ChannelProtocolEventARequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        return _inner().SendEvent(outgoing);
      });
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalEventSender<::test_protocols::ChannelProtocol>::EventA(
    ::test_protocols::ChannelProtocolEventARequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_EventA_Ordinal};
  ::fidl::Result result = ::fidl::internal::ConvertFromHLCPPOutgoingMessageThen(
      &::test_protocols::test_protocols_ChannelProtocolEventARequestTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      [this](fidl::OutgoingMessage outgoing) {
        outgoing.Write(_transport());
        return ::fidl::Result{outgoing};
      });
  return ::fidl::internal::ToFitxResult(result);
}

#endif  // __Fuchsia__

void fidl::internal::
    NaturalCompleterBase<::test_protocols::ChannelProtocol::MethodB>::Reply(
        ::test_protocols::ChannelProtocolMethodBTopResponse&& payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_MethodB_Ordinal};
  _messenger.SendReply(
      &::test_protocols::test_protocols_ChannelProtocolMethodBTopResponseTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::ChannelProtocol::TakeHandle>::Reply() {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_TakeHandle_Ordinal};
  _messenger.SendReply(
      nullptr,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder));
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::ChannelProtocol::MutateSocket>::
    Reply(::test_protocols::ChannelProtocolMutateSocketTopResponse&& payload) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_MutateSocket_Ordinal};
  _messenger.SendReply(
      &::test_protocols::
          test_protocols_ChannelProtocolMutateSocketTopResponseTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
}

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::ChannelProtocol>::entries_[] = {
    {
        ::test_protocols::kChannelProtocol_MethodA_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<::test_protocols::ChannelProtocol::MethodA>>
              decoded =
                  ::fidl::Request<::test_protocols::ChannelProtocol::MethodA>::
                      DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::ChannelProtocol::MethodA>::Sync completer(txn);
          static_cast<::fidl::Server<::test_protocols::ChannelProtocol>*>(
              interface)
              ->MethodA(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kChannelProtocol_MethodB_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<::test_protocols::ChannelProtocol::MethodB>>
              decoded =
                  ::fidl::Request<::test_protocols::ChannelProtocol::MethodB>::
                      DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::ChannelProtocol::MethodB>::Sync completer(txn);
          static_cast<::fidl::Server<::test_protocols::ChannelProtocol>*>(
              interface)
              ->MethodB(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kChannelProtocol_TakeHandle_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle>>
              decoded = ::fidl::Request<
                  ::test_protocols::ChannelProtocol::TakeHandle>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::ChannelProtocol::TakeHandle>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::ChannelProtocol>*>(
              interface)
              ->TakeHandle(decoded.value(), completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kChannelProtocol_MutateSocket_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result<
              ::fidl::Error,
              ::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket>>
              decoded = ::fidl::Request<
                  ::test_protocols::ChannelProtocol::MutateSocket>::
                  DecodeTransactional(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::ChannelProtocol::MutateSocket>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::ChannelProtocol>*>(
              interface)
              ->MutateSocket(decoded.value(), completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::ChannelProtocol>::entries_end_ = &entries_[4];

void fidl::internal::
    NaturalServerDispatcher<::test_protocols::ChannelProtocol>::Dispatch(
        ::fidl::Server<::test_protocols::ChannelProtocol>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::ChannelProtocol>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::ChannelProtocol>::Dispatch(this, std::move(msg),
                                                   std::move(transport_context),
                                                   txn);
}
#endif  // __Fuchsia__
