// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <fidl/test.handles/cpp/common_types.h>
#include <fidl/test.handles/cpp/markers.h>
#include <lib/fidl/cpp/coding_traits.h>
#include <lib/fidl/cpp/unified_messaging.h>

#include <cinttypes>
#include <string>

#ifdef __Fuchsia__

#include <lib/zx/bti.h>
#include <lib/zx/channel.h>
#include <lib/zx/clock.h>
#include <lib/zx/debuglog.h>
#include <lib/zx/event.h>
#include <lib/zx/eventpair.h>
#include <lib/zx/exception.h>
#include <lib/zx/fifo.h>
#include <lib/zx/guest.h>
#include <lib/zx/handle.h>
#include <lib/zx/interrupt.h>
#include <lib/zx/iommu.h>
#include <lib/zx/job.h>
#include <lib/zx/pager.h>
#include <lib/zx/pmt.h>
#include <lib/zx/port.h>
#include <lib/zx/process.h>
#include <lib/zx/profile.h>
#include <lib/zx/resource.h>
#include <lib/zx/socket.h>
#include <lib/zx/suspend_token.h>
#include <lib/zx/thread.h>
#include <lib/zx/timer.h>
#include <lib/zx/vcpu.h>
#include <lib/zx/vmar.h>
#include <lib/zx/vmo.h>

#endif  // __Fuchsia__

namespace test_handles {
class Handles;

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_handles_HandlesTable;

class Handles final {
 private:
  struct Storage_;

 public:
  Handles(Storage_ storage) noexcept : storage_(std::move(storage)) {}
  Handles(::zx::handle plain_handle, ::zx::bti bti_handle,
          ::zx::channel channel_handle, ::zx::clock clock_handle,
          ::zx::debuglog debuglog_handle, ::zx::event event_handle,
          ::zx::eventpair eventpair_handle, ::zx::exception exception_handle,
          ::zx::fifo fifo_handle, ::zx::guest guest_handle,
          ::zx::interrupt interrupt_handle, ::zx::iommu iommu_handle,
          ::zx::job job_handle, ::zx::pager pager_handle, ::zx::pmt pmt_handle,
          ::zx::port port_handle, ::zx::process process_handle,
          ::zx::profile profile_handle, ::zx::resource resource_handle,
          ::zx::socket socket_handle, ::zx::suspend_token suspendtoken_handle,
          ::zx::thread thread_handle, ::zx::timer timer_handle,
          ::zx::vcpu vcpu_handle, ::zx::vmar vmar_handle, ::zx::vmo vmo_handle,
          ::zx::vmo rights_handle, ::zx::handle aliased_plain_handle_field,
          ::zx::vmo aliased_subtype_handle_field,
          ::zx::vmo aliased_rights_handle_field,
          ::fidl::ClientEnd<::test_handles::SomeProtocol> some_protocol,
          ::fidl::ServerEnd<::test_handles::SomeProtocol>
              request_some_protocol) noexcept
      : storage_({.plain_handle = std::move(plain_handle),
                  .bti_handle = std::move(bti_handle),
                  .channel_handle = std::move(channel_handle),
                  .clock_handle = std::move(clock_handle),
                  .debuglog_handle = std::move(debuglog_handle),
                  .event_handle = std::move(event_handle),
                  .eventpair_handle = std::move(eventpair_handle),
                  .exception_handle = std::move(exception_handle),
                  .fifo_handle = std::move(fifo_handle),
                  .guest_handle = std::move(guest_handle),
                  .interrupt_handle = std::move(interrupt_handle),
                  .iommu_handle = std::move(iommu_handle),
                  .job_handle = std::move(job_handle),
                  .pager_handle = std::move(pager_handle),
                  .pmt_handle = std::move(pmt_handle),
                  .port_handle = std::move(port_handle),
                  .process_handle = std::move(process_handle),
                  .profile_handle = std::move(profile_handle),
                  .resource_handle = std::move(resource_handle),
                  .socket_handle = std::move(socket_handle),
                  .suspendtoken_handle = std::move(suspendtoken_handle),
                  .thread_handle = std::move(thread_handle),
                  .timer_handle = std::move(timer_handle),
                  .vcpu_handle = std::move(vcpu_handle),
                  .vmar_handle = std::move(vmar_handle),
                  .vmo_handle = std::move(vmo_handle),
                  .rights_handle = std::move(rights_handle),
                  .aliased_plain_handle_field =
                      std::move(aliased_plain_handle_field),
                  .aliased_subtype_handle_field =
                      std::move(aliased_subtype_handle_field),
                  .aliased_rights_handle_field =
                      std::move(aliased_rights_handle_field),
                  .some_protocol = std::move(some_protocol),
                  .request_some_protocol = std::move(request_some_protocol)}) {}
  Handles() : Handles(Storage_{}) {}

  Handles(Handles&&) noexcept = default;
  Handles& operator=(Handles&&) noexcept = default;

  const ::zx::handle& plain_handle() const { return storage_.plain_handle; }

  ::zx::handle& plain_handle() { return storage_.plain_handle; }

  const ::zx::bti& bti_handle() const { return storage_.bti_handle; }

  ::zx::bti& bti_handle() { return storage_.bti_handle; }

  const ::zx::channel& channel_handle() const {
    return storage_.channel_handle;
  }

  ::zx::channel& channel_handle() { return storage_.channel_handle; }

  const ::zx::clock& clock_handle() const { return storage_.clock_handle; }

  ::zx::clock& clock_handle() { return storage_.clock_handle; }

  const ::zx::debuglog& debuglog_handle() const {
    return storage_.debuglog_handle;
  }

  ::zx::debuglog& debuglog_handle() { return storage_.debuglog_handle; }

  const ::zx::event& event_handle() const { return storage_.event_handle; }

  ::zx::event& event_handle() { return storage_.event_handle; }

  const ::zx::eventpair& eventpair_handle() const {
    return storage_.eventpair_handle;
  }

  ::zx::eventpair& eventpair_handle() { return storage_.eventpair_handle; }

  const ::zx::exception& exception_handle() const {
    return storage_.exception_handle;
  }

  ::zx::exception& exception_handle() { return storage_.exception_handle; }

  const ::zx::fifo& fifo_handle() const { return storage_.fifo_handle; }

  ::zx::fifo& fifo_handle() { return storage_.fifo_handle; }

  const ::zx::guest& guest_handle() const { return storage_.guest_handle; }

  ::zx::guest& guest_handle() { return storage_.guest_handle; }

  const ::zx::interrupt& interrupt_handle() const {
    return storage_.interrupt_handle;
  }

  ::zx::interrupt& interrupt_handle() { return storage_.interrupt_handle; }

  const ::zx::iommu& iommu_handle() const { return storage_.iommu_handle; }

  ::zx::iommu& iommu_handle() { return storage_.iommu_handle; }

  const ::zx::job& job_handle() const { return storage_.job_handle; }

  ::zx::job& job_handle() { return storage_.job_handle; }

  const ::zx::pager& pager_handle() const { return storage_.pager_handle; }

  ::zx::pager& pager_handle() { return storage_.pager_handle; }

  const ::zx::pmt& pmt_handle() const { return storage_.pmt_handle; }

  ::zx::pmt& pmt_handle() { return storage_.pmt_handle; }

  const ::zx::port& port_handle() const { return storage_.port_handle; }

  ::zx::port& port_handle() { return storage_.port_handle; }

  const ::zx::process& process_handle() const {
    return storage_.process_handle;
  }

  ::zx::process& process_handle() { return storage_.process_handle; }

  const ::zx::profile& profile_handle() const {
    return storage_.profile_handle;
  }

  ::zx::profile& profile_handle() { return storage_.profile_handle; }

  const ::zx::resource& resource_handle() const {
    return storage_.resource_handle;
  }

  ::zx::resource& resource_handle() { return storage_.resource_handle; }

  const ::zx::socket& socket_handle() const { return storage_.socket_handle; }

  ::zx::socket& socket_handle() { return storage_.socket_handle; }

  const ::zx::suspend_token& suspendtoken_handle() const {
    return storage_.suspendtoken_handle;
  }

  ::zx::suspend_token& suspendtoken_handle() {
    return storage_.suspendtoken_handle;
  }

  const ::zx::thread& thread_handle() const { return storage_.thread_handle; }

  ::zx::thread& thread_handle() { return storage_.thread_handle; }

  const ::zx::timer& timer_handle() const { return storage_.timer_handle; }

  ::zx::timer& timer_handle() { return storage_.timer_handle; }

  const ::zx::vcpu& vcpu_handle() const { return storage_.vcpu_handle; }

  ::zx::vcpu& vcpu_handle() { return storage_.vcpu_handle; }

  const ::zx::vmar& vmar_handle() const { return storage_.vmar_handle; }

  ::zx::vmar& vmar_handle() { return storage_.vmar_handle; }

  const ::zx::vmo& vmo_handle() const { return storage_.vmo_handle; }

  ::zx::vmo& vmo_handle() { return storage_.vmo_handle; }

  const ::zx::vmo& rights_handle() const { return storage_.rights_handle; }

  ::zx::vmo& rights_handle() { return storage_.rights_handle; }

  const ::zx::handle& aliased_plain_handle_field() const {
    return storage_.aliased_plain_handle_field;
  }

  ::zx::handle& aliased_plain_handle_field() {
    return storage_.aliased_plain_handle_field;
  }

  const ::zx::vmo& aliased_subtype_handle_field() const {
    return storage_.aliased_subtype_handle_field;
  }

  ::zx::vmo& aliased_subtype_handle_field() {
    return storage_.aliased_subtype_handle_field;
  }

  const ::zx::vmo& aliased_rights_handle_field() const {
    return storage_.aliased_rights_handle_field;
  }

  ::zx::vmo& aliased_rights_handle_field() {
    return storage_.aliased_rights_handle_field;
  }

  const ::fidl::ClientEnd<::test_handles::SomeProtocol>& some_protocol() const {
    return storage_.some_protocol;
  }

  ::fidl::ClientEnd<::test_handles::SomeProtocol>& some_protocol() {
    return storage_.some_protocol;
  }

  const ::fidl::ServerEnd<::test_handles::SomeProtocol>& request_some_protocol()
      const {
    return storage_.request_some_protocol;
  }

  ::fidl::ServerEnd<::test_handles::SomeProtocol>& request_some_protocol() {
    return storage_.request_some_protocol;
  }

 private:
  struct Storage_ final {
    ::zx::handle plain_handle{};
    ::zx::bti bti_handle{};
    ::zx::channel channel_handle{};
    ::zx::clock clock_handle{};
    ::zx::debuglog debuglog_handle{};
    ::zx::event event_handle{};
    ::zx::eventpair eventpair_handle{};
    ::zx::exception exception_handle{};
    ::zx::fifo fifo_handle{};
    ::zx::guest guest_handle{};
    ::zx::interrupt interrupt_handle{};
    ::zx::iommu iommu_handle{};
    ::zx::job job_handle{};
    ::zx::pager pager_handle{};
    ::zx::pmt pmt_handle{};
    ::zx::port port_handle{};
    ::zx::process process_handle{};
    ::zx::profile profile_handle{};
    ::zx::resource resource_handle{};
    ::zx::socket socket_handle{};
    ::zx::suspend_token suspendtoken_handle{};
    ::zx::thread thread_handle{};
    ::zx::timer timer_handle{};
    ::zx::vcpu vcpu_handle{};
    ::zx::vmar vmar_handle{};
    ::zx::vmo vmo_handle{};
    ::zx::vmo rights_handle{};
    ::zx::handle aliased_plain_handle_field{};
    ::zx::vmo aliased_subtype_handle_field{};
    ::zx::vmo aliased_rights_handle_field{};
    ::fidl::ClientEnd<::test_handles::SomeProtocol> some_protocol{};
    ::fidl::ServerEnd<::test_handles::SomeProtocol> request_some_protocol{};
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_handles::Handles, 128, 128>;
  friend struct ::fidl::internal::MemberVisitor<::test_handles::Handles>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::handle>{
          &Storage_::plain_handle, 0, 0,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_NONE, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::bti>{
          &Storage_::bti_handle, 4, 4,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_BTI, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::channel>{
          &Storage_::channel_handle, 8, 8,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_CHANNEL, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::clock>{
          &Storage_::clock_handle, 12, 12,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_CLOCK, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::debuglog>{
          &Storage_::debuglog_handle, 16, 16,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_LOG, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::event>{
          &Storage_::event_handle, 20, 20,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_EVENT, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::eventpair>{
          &Storage_::eventpair_handle, 24, 24,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_EVENTPAIR, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::exception>{
          &Storage_::exception_handle, 28, 28,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_EXCEPTION, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::fifo>{
          &Storage_::fifo_handle, 32, 32,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_FIFO, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::guest>{
          &Storage_::guest_handle, 36, 36,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_GUEST, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::interrupt>{
          &Storage_::interrupt_handle, 40, 40,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_INTERRUPT, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::iommu>{
          &Storage_::iommu_handle, 44, 44,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_IOMMU, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::job>{
          &Storage_::job_handle, 48, 48,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_JOB, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::pager>{
          &Storage_::pager_handle, 52, 52,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_PAGER, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::pmt>{
          &Storage_::pmt_handle, 56, 56,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_PMT, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::port>{
          &Storage_::port_handle, 60, 60,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_PORT, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::process>{
          &Storage_::process_handle, 64, 64,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_PROCESS, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::profile>{
          &Storage_::profile_handle, 68, 68,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_PROFILE, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::resource>{
          &Storage_::resource_handle, 72, 72,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_RESOURCE, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::socket>{
          &Storage_::socket_handle, 76, 76,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_SOCKET, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::suspend_token>{
          &Storage_::suspendtoken_handle, 80, 80,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_SUSPEND_TOKEN,
               .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::thread>{
          &Storage_::thread_handle, 84, 84,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_THREAD, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::timer>{
          &Storage_::timer_handle, 88, 88,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_TIMER, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::vcpu>{
          &Storage_::vcpu_handle, 92, 92,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_VCPU, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::vmar>{
          &Storage_::vmar_handle, 96, 96,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_VMAR, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::vmo>{
          &Storage_::vmo_handle, 100, 100,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_VMO, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::vmo>{
          &Storage_::rights_handle, 104, 104,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_VMO, .rights = 0x5})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::handle>{
          &Storage_::aliased_plain_handle_field, 108, 108,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_NONE, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::vmo>{
          &Storage_::aliased_subtype_handle_field, 112, 112,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_VMO, .rights = 0x80000000})},
      ::fidl::internal::NaturalStructMember<Storage_, ::zx::vmo>{
          &Storage_::aliased_rights_handle_field, 116, 116,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_VMO, .rights = 0x1})},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::fidl::ClientEnd<::test_handles::SomeProtocol>>{
          &Storage_::some_protocol, 120, 120,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_CHANNEL,
               .rights = ZX_DEFAULT_CHANNEL_RIGHTS})},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::fidl::ServerEnd<::test_handles::SomeProtocol>>{
          &Storage_::request_some_protocol, 124, 124,
          std::make_optional<::fidl::internal::NaturalHandleInformation>(
              {.object_type = ZX_OBJ_TYPE_CHANNEL,
               .rights = ZX_DEFAULT_CHANNEL_RIGHTS})});
};

#endif  // __Fuchsia__

}  // namespace test_handles
namespace fidl {

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_handles_HandlesTable;

template <>
struct IsResource<::test_handles::Handles> : public std::true_type {};
template <>
struct IsFidlType<::test_handles::Handles> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_handles::Handles> final {
 public:
  static constexpr const fidl_type_t* kCodingTable = &test_handles_HandlesTable;
};

template <>
struct internal::NaturalCodingTraits<::test_handles::Handles> final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_handles::Handles, 128, 128> {};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_handles::Handles>
    : public internal::BoolConstant<
          !HasPadding<::test_handles::Handles>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::handle>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::bti>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::channel>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::clock>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::debuglog>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::event>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::eventpair>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::exception>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::fifo>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::guest>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::interrupt>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::iommu>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::job>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::pager>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::pmt>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::port>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::process>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::profile>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::resource>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::socket>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::suspend_token>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::thread>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::timer>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::vcpu>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::vmar>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::vmo>::value &&
          internal::NaturalIsMemcpyCompatible<
              ::fidl::ClientEnd<::test_handles::SomeProtocol>>::value &&
          internal::NaturalIsMemcpyCompatible<
              ::fidl::ServerEnd<::test_handles::SomeProtocol>>::value> {};

#endif  // __Fuchsia__

template <>
struct internal::NaturalCodingTraits<::test_handles::obj_type> {
  static constexpr size_t inline_size_v1_no_ee = sizeof(uint32_t);
  static constexpr size_t inline_size_v2 = sizeof(uint32_t);

  static void Encode(internal::NaturalEncoder* encoder,
                     ::test_handles::obj_type* value, size_t offset,
                     cpp17::optional<NaturalHandleInformation>
                         maybe_handle_info = cpp17::nullopt) {
    ZX_DEBUG_ASSERT(maybe_handle_info == cpp17::nullopt);
    *encoder->template GetPtr<::test_handles::obj_type>(offset) = *value;
  }
  static void Decode(internal::NaturalDecoder* decoder,
                     ::test_handles::obj_type* value, size_t offset) {
    *value = *decoder->template GetPtr<::test_handles::obj_type>(offset);
  }
};

}  // namespace fidl
