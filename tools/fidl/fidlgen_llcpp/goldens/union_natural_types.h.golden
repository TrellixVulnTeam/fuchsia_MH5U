// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <fidl/test.union/cpp/common_types.h>
#include <fidl/test.union/cpp/markers.h>
#include <lib/fidl/cpp/coding_traits.h>
#include <lib/fidl/cpp/unified_messaging.h>

#include <cinttypes>
#include <string>

#ifdef __Fuchsia__

#include <lib/zx/channel.h>

#endif  // __Fuchsia__

namespace test_union {
class StructWithNullableXUnion;

class TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse;

class Pizza;

class Pasta;

class TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse;

class NullableUnionStruct;

class UnionSandwich;

class Empty;

class UnionWithAttributes;

class Union;

class StrictUnion;

class StrictSimpleXUnion;

class StrictFoo;

class StrictBoundedXUnion;

class ReverseOrdinalUnion;

class StrictPizzaOrPasta;

class PizzaOrPasta;

class FlexiblePizzaOrPasta;

class ExplicitPizzaOrPasta;

class OlderSimpleUnion;

class NewerSimpleUnion;

class FlexibleUnion;

class FlexibleFoo;

class FieldCollision;

class ExplicitXUnion;

class ExplicitUnion;

class ExplicitStrictFoo;

class ExplicitFoo;

class XUnionContainingEmptyStruct;

extern "C" const fidl_type_t test_union_UnionWithAttributesTable;

class UnionWithAttributes final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, int64_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kX = 1,  // 0x1
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  // Create an unknown value of this union.
  UnionWithAttributes() : storage_(std::make_shared<Storage_>()) {}

  UnionWithAttributes(UnionWithAttributes&&) noexcept = default;
  UnionWithAttributes& operator=(UnionWithAttributes&&) noexcept = default;
  UnionWithAttributes(const UnionWithAttributes& other) noexcept
      : UnionWithAttributes(other.CloneStorage_()) {}
  UnionWithAttributes& operator=(const UnionWithAttributes& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const UnionWithAttributes& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const UnionWithAttributes& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::UnionWithAttributes::Tag Which() const {
    return UnionWithAttributes::IndexToTag(storage_->index());
  }
  static UnionWithAttributes WithX(int64_t val) {
    return UnionWithAttributes(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> x() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> x() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::UnionWithAttributes>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 2>
      kMembers = {std::nullopt, std::nullopt};

  explicit UnionWithAttributes(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::test_union::UnionWithAttributes::Tag tag) {
    switch (tag) {
      case ::test_union::UnionWithAttributes::Tag::kX:
        return 1;
      case ::test_union::UnionWithAttributes::Tag::kUnknown:
        return 0;
    }
  }

  static constexpr ::test_union::UnionWithAttributes::Tag IndexToTag(
      size_t index) {
    switch (index) {
      case 1:
        return ::test_union::UnionWithAttributes::Tag::kX;
      default:
        return ::test_union::UnionWithAttributes::Tag::kUnknown;
    }
  }
};

extern "C" const fidl_type_t test_union_UnionTable;

class Union final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, int32_t, ::std::string,
                                  ::std::vector<::std::string>>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  // Create an unknown value of this union.
  Union() : storage_(std::make_shared<Storage_>()) {}

  Union(Union&&) noexcept = default;
  Union& operator=(Union&&) noexcept = default;
  Union(const Union& other) noexcept : Union(other.CloneStorage_()) {}
  Union& operator=(const Union& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Union& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const Union& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::Union::Tag Which() const {
    return Union::IndexToTag(storage_->index());
  }
  static Union WithPrimitive(int32_t val) {
    return Union(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> primitive() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> primitive() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static Union WithStringNeedsConstructor(::std::string val) {
    return Union(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_>
  string_needs_constructor() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> string_needs_constructor() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  static Union WithVectorStringAlsoNeedsConstructor(
      ::std::vector<::std::string> val) {
    return Union(
        std::make_shared<Storage_>(std::in_place_index_t<3>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<3, Storage_>
  vector_string_also_needs_constructor() const {
    return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<3, Storage_>
  vector_string_also_needs_constructor() {
    return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::Union>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 4>
      kMembers = {std::nullopt, std::nullopt, std::nullopt, std::nullopt};

  explicit Union(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::test_union::Union::Tag tag) {
    switch (tag) {
      case ::test_union::Union::Tag::kPrimitive:
        return 1;
      case ::test_union::Union::Tag::kStringNeedsConstructor:
        return 2;
      case ::test_union::Union::Tag::kVectorStringAlsoNeedsConstructor:
        return 3;
    }
  }

  static constexpr ::test_union::Union::Tag IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_union::Union::Tag::kPrimitive;
      case 2:
        return ::test_union::Union::Tag::kStringNeedsConstructor;
      case 3:
        return ::test_union::Union::Tag::kVectorStringAlsoNeedsConstructor;
      // TODO: what's the right thing to do here?
      default:
        return ::test_union::Union::Tag::kPrimitive;
    }
  }
};

extern "C" const fidl_type_t test_union_StructWithNullableXUnionTable;

class StructWithNullableXUnion final {
 private:
  struct Storage_;

 public:
  StructWithNullableXUnion(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  StructWithNullableXUnion(
      ::std::unique_ptr<::test_union::OlderSimpleUnion> x1) noexcept
      : storage_({.x1 = std::move(x1)}) {}
  StructWithNullableXUnion() : StructWithNullableXUnion(Storage_{}) {}

  StructWithNullableXUnion(StructWithNullableXUnion&&) noexcept = default;
  StructWithNullableXUnion& operator=(StructWithNullableXUnion&&) noexcept =
      default;
  StructWithNullableXUnion(const StructWithNullableXUnion& other) noexcept
      : StructWithNullableXUnion(other.CloneStorage_()) {}
  StructWithNullableXUnion& operator=(
      const StructWithNullableXUnion& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const StructWithNullableXUnion& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_union::StructWithNullableXUnion, 24, 16>::Equal(this, &other);
  }
  bool operator!=(const StructWithNullableXUnion& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_union::StructWithNullableXUnion, 24, 16>::Equal(this, &other);
  }

  const ::std::unique_ptr<::test_union::OlderSimpleUnion>& x1() const {
    return storage_.x1;
  }

  ::std::unique_ptr<::test_union::OlderSimpleUnion>& x1() {
    return storage_.x1;
  }

 private:
  struct Storage_ final {
    ::std::unique_ptr<::test_union::OlderSimpleUnion> x1{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_union::StructWithNullableXUnion, 24, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_union::StructWithNullableXUnion>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, ::std::unique_ptr<::test_union::OlderSimpleUnion>>{
          &Storage_::x1, 0, 0});
};

extern "C" const fidl_type_t test_union_StrictUnionTable;

class StrictUnion final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, int32_t, ::std::string,
                                  ::std::vector<::std::string>>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  // Create an unknown value of this union.
  StrictUnion() : storage_(std::make_shared<Storage_>()) {}

  StrictUnion(StrictUnion&&) noexcept = default;
  StrictUnion& operator=(StrictUnion&&) noexcept = default;
  StrictUnion(const StrictUnion& other) noexcept
      : StrictUnion(other.CloneStorage_()) {}
  StrictUnion& operator=(const StrictUnion& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const StrictUnion& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const StrictUnion& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::StrictUnion::Tag Which() const {
    return StrictUnion::IndexToTag(storage_->index());
  }
  static StrictUnion WithPrimitive(int32_t val) {
    return StrictUnion(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> primitive() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> primitive() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static StrictUnion WithStringNeedsConstructor(::std::string val) {
    return StrictUnion(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_>
  string_needs_constructor() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> string_needs_constructor() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  static StrictUnion WithVectorStringAlsoNeedsConstructor(
      ::std::vector<::std::string> val) {
    return StrictUnion(
        std::make_shared<Storage_>(std::in_place_index_t<3>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<3, Storage_>
  vector_string_also_needs_constructor() const {
    return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<3, Storage_>
  vector_string_also_needs_constructor() {
    return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::StrictUnion>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 4>
      kMembers = {std::nullopt, std::nullopt, std::nullopt, std::nullopt};

  explicit StrictUnion(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::test_union::StrictUnion::Tag tag) {
    switch (tag) {
      case ::test_union::StrictUnion::Tag::kPrimitive:
        return 1;
      case ::test_union::StrictUnion::Tag::kStringNeedsConstructor:
        return 2;
      case ::test_union::StrictUnion::Tag::kVectorStringAlsoNeedsConstructor:
        return 3;
    }
  }

  static constexpr ::test_union::StrictUnion::Tag IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_union::StrictUnion::Tag::kPrimitive;
      case 2:
        return ::test_union::StrictUnion::Tag::kStringNeedsConstructor;
      case 3:
        return ::test_union::StrictUnion::Tag::
            kVectorStringAlsoNeedsConstructor;
      // TODO: what's the right thing to do here?
      default:
        return ::test_union::StrictUnion::Tag::kPrimitive;
    }
  }
};

extern "C" const fidl_type_t test_union_StrictSimpleXUnionTable;

class StrictSimpleXUnion final {
 private:
  using Storage_ =
      cpp17::variant<cpp17::monostate, int32_t, float, ::std::string>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kI = 1,  // 0x1
    kF = 2,  // 0x2
    kS = 3,  // 0x3
  };

  // Create an unknown value of this union.
  StrictSimpleXUnion() : storage_(std::make_shared<Storage_>()) {}

  StrictSimpleXUnion(StrictSimpleXUnion&&) noexcept = default;
  StrictSimpleXUnion& operator=(StrictSimpleXUnion&&) noexcept = default;
  StrictSimpleXUnion(const StrictSimpleXUnion& other) noexcept
      : StrictSimpleXUnion(other.CloneStorage_()) {}
  StrictSimpleXUnion& operator=(const StrictSimpleXUnion& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const StrictSimpleXUnion& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const StrictSimpleXUnion& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::StrictSimpleXUnion::Tag Which() const {
    return StrictSimpleXUnion::IndexToTag(storage_->index());
  }
  static StrictSimpleXUnion WithI(int32_t val) {
    return StrictSimpleXUnion(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> i() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> i() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static StrictSimpleXUnion WithF(float val) {
    return StrictSimpleXUnion(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> f() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> f() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  static StrictSimpleXUnion WithS(::std::string val) {
    return StrictSimpleXUnion(
        std::make_shared<Storage_>(std::in_place_index_t<3>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<3, Storage_> s() const {
    return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<3, Storage_> s() {
    return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::StrictSimpleXUnion>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 4>
      kMembers = {std::nullopt, std::nullopt, std::nullopt, std::nullopt};

  explicit StrictSimpleXUnion(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::test_union::StrictSimpleXUnion::Tag tag) {
    switch (tag) {
      case ::test_union::StrictSimpleXUnion::Tag::kI:
        return 1;
      case ::test_union::StrictSimpleXUnion::Tag::kF:
        return 2;
      case ::test_union::StrictSimpleXUnion::Tag::kS:
        return 3;
    }
  }

  static constexpr ::test_union::StrictSimpleXUnion::Tag IndexToTag(
      size_t index) {
    switch (index) {
      case 1:
        return ::test_union::StrictSimpleXUnion::Tag::kI;
      case 2:
        return ::test_union::StrictSimpleXUnion::Tag::kF;
      case 3:
        return ::test_union::StrictSimpleXUnion::Tag::kS;
      // TODO: what's the right thing to do here?
      default:
        return ::test_union::StrictSimpleXUnion::Tag::kI;
    }
  }
};

extern "C" const fidl_type_t test_union_StrictFooTable;

class StrictFoo final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, ::std::string, int32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kS = 1,  // 0x1
    kI = 2,  // 0x2
  };

  // Create an unknown value of this union.
  StrictFoo() : storage_(std::make_shared<Storage_>()) {}

  StrictFoo(StrictFoo&&) noexcept = default;
  StrictFoo& operator=(StrictFoo&&) noexcept = default;
  StrictFoo(const StrictFoo& other) noexcept
      : StrictFoo(other.CloneStorage_()) {}
  StrictFoo& operator=(const StrictFoo& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const StrictFoo& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const StrictFoo& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::StrictFoo::Tag Which() const {
    return StrictFoo::IndexToTag(storage_->index());
  }
  static StrictFoo WithS(::std::string val) {
    return StrictFoo(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> s() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> s() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static StrictFoo WithI(int32_t val) {
    return StrictFoo(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> i() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> i() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::StrictFoo>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 3>
      kMembers = {std::nullopt, std::nullopt, std::nullopt};

  explicit StrictFoo(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::test_union::StrictFoo::Tag tag) {
    switch (tag) {
      case ::test_union::StrictFoo::Tag::kS:
        return 1;
      case ::test_union::StrictFoo::Tag::kI:
        return 2;
    }
  }

  static constexpr ::test_union::StrictFoo::Tag IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_union::StrictFoo::Tag::kS;
      case 2:
        return ::test_union::StrictFoo::Tag::kI;
      // TODO: what's the right thing to do here?
      default:
        return ::test_union::StrictFoo::Tag::kS;
    }
  }
};

extern "C" const fidl_type_t test_union_StrictBoundedXUnionTable;

class StrictBoundedXUnion final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, ::std::vector<uint8_t>>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kV = 1,  // 0x1
  };

  // Create an unknown value of this union.
  StrictBoundedXUnion() : storage_(std::make_shared<Storage_>()) {}

  StrictBoundedXUnion(StrictBoundedXUnion&&) noexcept = default;
  StrictBoundedXUnion& operator=(StrictBoundedXUnion&&) noexcept = default;
  StrictBoundedXUnion(const StrictBoundedXUnion& other) noexcept
      : StrictBoundedXUnion(other.CloneStorage_()) {}
  StrictBoundedXUnion& operator=(const StrictBoundedXUnion& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const StrictBoundedXUnion& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const StrictBoundedXUnion& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::StrictBoundedXUnion::Tag Which() const {
    return StrictBoundedXUnion::IndexToTag(storage_->index());
  }
  static StrictBoundedXUnion WithV(::std::vector<uint8_t> val) {
    return StrictBoundedXUnion(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> v() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> v() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::StrictBoundedXUnion>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 2>
      kMembers = {std::nullopt, std::nullopt};

  explicit StrictBoundedXUnion(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::test_union::StrictBoundedXUnion::Tag tag) {
    switch (tag) {
      case ::test_union::StrictBoundedXUnion::Tag::kV:
        return 1;
    }
  }

  static constexpr ::test_union::StrictBoundedXUnion::Tag IndexToTag(
      size_t index) {
    switch (index) {
      case 1:
        return ::test_union::StrictBoundedXUnion::Tag::kV;
      // TODO: what's the right thing to do here?
      default:
        return ::test_union::StrictBoundedXUnion::Tag::kV;
    }
  }
};

extern "C" const fidl_type_t
    test_union_TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponseTable;

class TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse
    final {
 private:
  struct Storage_;

 public:
  TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse(
      Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse(
      ::test_union::StrictBoundedXUnion xu) noexcept
      : storage_({.xu = std::move(xu)}) {}
  TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse()
      : TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse(
            Storage_{}) {}

  TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse(
      TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse&&) noexcept =
      default;
  TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse&
  operator=(
      TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse&&) noexcept =
      default;
  TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse(
      const TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse&
          other) noexcept
      : TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse(
            other.CloneStorage_()) {}
  TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse&
  operator=(
      const TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse&
          other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse&
          other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_union::
            TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse,
        24, 16>::Equal(this, &other);
  }
  bool operator!=(
      const TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse&
          other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_union::
            TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse,
        24, 16>::Equal(this, &other);
  }

  const ::test_union::StrictBoundedXUnion& xu() const { return storage_.xu; }

  ::test_union::StrictBoundedXUnion& xu() { return storage_.xu; }

 private:
  struct Storage_ final {
    ::test_union::StrictBoundedXUnion xu{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_union::
          TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse,
      24, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_union::
          TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_,
                                            ::test_union::StrictBoundedXUnion>{
          &Storage_::xu, 0, 0});
};

extern "C" const fidl_type_t test_union_ReverseOrdinalUnionTable;

class ReverseOrdinalUnion final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, uint32_t, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kSecond = 2,  // 0x2
    kFirst = 1,   // 0x1
  };

  // Create an unknown value of this union.
  ReverseOrdinalUnion() : storage_(std::make_shared<Storage_>()) {}

  ReverseOrdinalUnion(ReverseOrdinalUnion&&) noexcept = default;
  ReverseOrdinalUnion& operator=(ReverseOrdinalUnion&&) noexcept = default;
  ReverseOrdinalUnion(const ReverseOrdinalUnion& other) noexcept
      : ReverseOrdinalUnion(other.CloneStorage_()) {}
  ReverseOrdinalUnion& operator=(const ReverseOrdinalUnion& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const ReverseOrdinalUnion& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const ReverseOrdinalUnion& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::ReverseOrdinalUnion::Tag Which() const {
    return ReverseOrdinalUnion::IndexToTag(storage_->index());
  }
  static ReverseOrdinalUnion WithSecond(uint32_t val) {
    return ReverseOrdinalUnion(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> second() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> second() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static ReverseOrdinalUnion WithFirst(uint32_t val) {
    return ReverseOrdinalUnion(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> first() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> first() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::ReverseOrdinalUnion>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 3>
      kMembers = {std::nullopt, std::nullopt, std::nullopt};

  explicit ReverseOrdinalUnion(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::test_union::ReverseOrdinalUnion::Tag tag) {
    switch (tag) {
      case ::test_union::ReverseOrdinalUnion::Tag::kSecond:
        return 1;
      case ::test_union::ReverseOrdinalUnion::Tag::kFirst:
        return 2;
    }
  }

  static constexpr ::test_union::ReverseOrdinalUnion::Tag IndexToTag(
      size_t index) {
    switch (index) {
      case 1:
        return ::test_union::ReverseOrdinalUnion::Tag::kSecond;
      case 2:
        return ::test_union::ReverseOrdinalUnion::Tag::kFirst;
      // TODO: what's the right thing to do here?
      default:
        return ::test_union::ReverseOrdinalUnion::Tag::kSecond;
    }
  }
};

extern "C" const fidl_type_t test_union_PizzaTable;

class Pizza final {
 private:
  struct Storage_;

 public:
  Pizza(Storage_ storage) noexcept : storage_(std::move(storage)) {}
  Pizza(::std::vector<::std::string> toppings) noexcept
      : storage_({.toppings = std::move(toppings)}) {}
  Pizza() : Pizza(Storage_{}) {}

  Pizza(Pizza&&) noexcept = default;
  Pizza& operator=(Pizza&&) noexcept = default;
  Pizza(const Pizza& other) noexcept : Pizza(other.CloneStorage_()) {}
  Pizza& operator=(const Pizza& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Pizza& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<::test_union::Pizza, 16,
                                                       16>::Equal(this, &other);
  }
  bool operator!=(const Pizza& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<::test_union::Pizza, 16,
                                                        16>::Equal(this,
                                                                   &other);
  }

  const ::std::vector<::std::string>& toppings() const {
    return storage_.toppings;
  }

  ::std::vector<::std::string>& toppings() { return storage_.toppings; }

 private:
  struct Storage_ final {
    ::std::vector<::std::string> toppings{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_union::Pizza,
                                                            16, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_union::Pizza>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_,
                                            ::std::vector<::std::string>>{
          &Storage_::toppings, 0, 0});
};

extern "C" const fidl_type_t test_union_PastaTable;

class Pasta final {
 private:
  struct Storage_;

 public:
  Pasta(Storage_ storage) noexcept : storage_(std::move(storage)) {}
  Pasta(::std::string sauce) noexcept : storage_({.sauce = std::move(sauce)}) {}
  Pasta() : Pasta(Storage_{}) {}

  Pasta(Pasta&&) noexcept = default;
  Pasta& operator=(Pasta&&) noexcept = default;
  Pasta(const Pasta& other) noexcept : Pasta(other.CloneStorage_()) {}
  Pasta& operator=(const Pasta& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Pasta& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<::test_union::Pasta, 16,
                                                       16>::Equal(this, &other);
  }
  bool operator!=(const Pasta& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<::test_union::Pasta, 16,
                                                        16>::Equal(this,
                                                                   &other);
  }

  const ::std::string& sauce() const { return storage_.sauce; }

  ::std::string& sauce() { return storage_.sauce; }

 private:
  struct Storage_ final {
    ::std::string sauce{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_union::Pasta,
                                                            16, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_union::Pasta>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_, ::std::string>{
          &Storage_::sauce, 0, 0});
};

extern "C" const fidl_type_t test_union_StrictPizzaOrPastaTable;

class StrictPizzaOrPasta final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, ::test_union::Pizza,
                                  ::test_union::Pasta>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  // Create an unknown value of this union.
  StrictPizzaOrPasta() : storage_(std::make_shared<Storage_>()) {}

  StrictPizzaOrPasta(StrictPizzaOrPasta&&) noexcept = default;
  StrictPizzaOrPasta& operator=(StrictPizzaOrPasta&&) noexcept = default;
  StrictPizzaOrPasta(const StrictPizzaOrPasta& other) noexcept
      : StrictPizzaOrPasta(other.CloneStorage_()) {}
  StrictPizzaOrPasta& operator=(const StrictPizzaOrPasta& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const StrictPizzaOrPasta& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const StrictPizzaOrPasta& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::StrictPizzaOrPasta::Tag Which() const {
    return StrictPizzaOrPasta::IndexToTag(storage_->index());
  }
  static StrictPizzaOrPasta WithPizza(::test_union::Pizza val) {
    return StrictPizzaOrPasta(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> pizza() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> pizza() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static StrictPizzaOrPasta WithPasta(::test_union::Pasta val) {
    return StrictPizzaOrPasta(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> pasta() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> pasta() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::StrictPizzaOrPasta>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 3>
      kMembers = {std::nullopt, std::nullopt, std::nullopt};

  explicit StrictPizzaOrPasta(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::test_union::StrictPizzaOrPasta::Tag tag) {
    switch (tag) {
      case ::test_union::StrictPizzaOrPasta::Tag::kPizza:
        return 1;
      case ::test_union::StrictPizzaOrPasta::Tag::kPasta:
        return 2;
    }
  }

  static constexpr ::test_union::StrictPizzaOrPasta::Tag IndexToTag(
      size_t index) {
    switch (index) {
      case 1:
        return ::test_union::StrictPizzaOrPasta::Tag::kPizza;
      case 2:
        return ::test_union::StrictPizzaOrPasta::Tag::kPasta;
      // TODO: what's the right thing to do here?
      default:
        return ::test_union::StrictPizzaOrPasta::Tag::kPizza;
    }
  }
};

extern "C" const fidl_type_t test_union_PizzaOrPastaTable;

class PizzaOrPasta final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, ::test_union::Pizza,
                                  ::test_union::Pasta>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  // Create an unknown value of this union.
  PizzaOrPasta() : storage_(std::make_shared<Storage_>()) {}

  PizzaOrPasta(PizzaOrPasta&&) noexcept = default;
  PizzaOrPasta& operator=(PizzaOrPasta&&) noexcept = default;
  PizzaOrPasta(const PizzaOrPasta& other) noexcept
      : PizzaOrPasta(other.CloneStorage_()) {}
  PizzaOrPasta& operator=(const PizzaOrPasta& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const PizzaOrPasta& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const PizzaOrPasta& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::PizzaOrPasta::Tag Which() const {
    return PizzaOrPasta::IndexToTag(storage_->index());
  }
  static PizzaOrPasta WithPizza(::test_union::Pizza val) {
    return PizzaOrPasta(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> pizza() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> pizza() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static PizzaOrPasta WithPasta(::test_union::Pasta val) {
    return PizzaOrPasta(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> pasta() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> pasta() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::PizzaOrPasta>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 3>
      kMembers = {std::nullopt, std::nullopt, std::nullopt};

  explicit PizzaOrPasta(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::test_union::PizzaOrPasta::Tag tag) {
    switch (tag) {
      case ::test_union::PizzaOrPasta::Tag::kPizza:
        return 1;
      case ::test_union::PizzaOrPasta::Tag::kPasta:
        return 2;
    }
  }

  static constexpr ::test_union::PizzaOrPasta::Tag IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_union::PizzaOrPasta::Tag::kPizza;
      case 2:
        return ::test_union::PizzaOrPasta::Tag::kPasta;
      // TODO: what's the right thing to do here?
      default:
        return ::test_union::PizzaOrPasta::Tag::kPizza;
    }
  }
};

extern "C" const fidl_type_t test_union_FlexiblePizzaOrPastaTable;

class FlexiblePizzaOrPasta final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, ::test_union::Pizza,
                                  ::test_union::Pasta>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  // Create an unknown value of this union.
  FlexiblePizzaOrPasta() : storage_(std::make_shared<Storage_>()) {}

  FlexiblePizzaOrPasta(FlexiblePizzaOrPasta&&) noexcept = default;
  FlexiblePizzaOrPasta& operator=(FlexiblePizzaOrPasta&&) noexcept = default;
  FlexiblePizzaOrPasta(const FlexiblePizzaOrPasta& other) noexcept
      : FlexiblePizzaOrPasta(other.CloneStorage_()) {}
  FlexiblePizzaOrPasta& operator=(const FlexiblePizzaOrPasta& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const FlexiblePizzaOrPasta& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const FlexiblePizzaOrPasta& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::FlexiblePizzaOrPasta::Tag Which() const {
    return FlexiblePizzaOrPasta::IndexToTag(storage_->index());
  }
  static FlexiblePizzaOrPasta WithPizza(::test_union::Pizza val) {
    return FlexiblePizzaOrPasta(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> pizza() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> pizza() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static FlexiblePizzaOrPasta WithPasta(::test_union::Pasta val) {
    return FlexiblePizzaOrPasta(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> pasta() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> pasta() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::FlexiblePizzaOrPasta>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 3>
      kMembers = {std::nullopt, std::nullopt, std::nullopt};

  explicit FlexiblePizzaOrPasta(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::test_union::FlexiblePizzaOrPasta::Tag tag) {
    switch (tag) {
      case ::test_union::FlexiblePizzaOrPasta::Tag::kPizza:
        return 1;
      case ::test_union::FlexiblePizzaOrPasta::Tag::kPasta:
        return 2;
      case ::test_union::FlexiblePizzaOrPasta::Tag::kUnknown:
        return 0;
    }
  }

  static constexpr ::test_union::FlexiblePizzaOrPasta::Tag IndexToTag(
      size_t index) {
    switch (index) {
      case 1:
        return ::test_union::FlexiblePizzaOrPasta::Tag::kPizza;
      case 2:
        return ::test_union::FlexiblePizzaOrPasta::Tag::kPasta;
      default:
        return ::test_union::FlexiblePizzaOrPasta::Tag::kUnknown;
    }
  }
};

extern "C" const fidl_type_t test_union_ExplicitPizzaOrPastaTable;

class ExplicitPizzaOrPasta final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, ::test_union::Pizza,
                                  ::test_union::Pasta>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 4,  // 0x4
  };

  // Create an unknown value of this union.
  ExplicitPizzaOrPasta() : storage_(std::make_shared<Storage_>()) {}

  ExplicitPizzaOrPasta(ExplicitPizzaOrPasta&&) noexcept = default;
  ExplicitPizzaOrPasta& operator=(ExplicitPizzaOrPasta&&) noexcept = default;
  ExplicitPizzaOrPasta(const ExplicitPizzaOrPasta& other) noexcept
      : ExplicitPizzaOrPasta(other.CloneStorage_()) {}
  ExplicitPizzaOrPasta& operator=(const ExplicitPizzaOrPasta& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const ExplicitPizzaOrPasta& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const ExplicitPizzaOrPasta& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::ExplicitPizzaOrPasta::Tag Which() const {
    return ExplicitPizzaOrPasta::IndexToTag(storage_->index());
  }
  static ExplicitPizzaOrPasta WithPizza(::test_union::Pizza val) {
    return ExplicitPizzaOrPasta(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> pizza() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> pizza() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static ExplicitPizzaOrPasta WithPasta(::test_union::Pasta val) {
    return ExplicitPizzaOrPasta(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> pasta() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> pasta() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::ExplicitPizzaOrPasta>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 3>
      kMembers = {std::nullopt, std::nullopt, std::nullopt};

  explicit ExplicitPizzaOrPasta(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::test_union::ExplicitPizzaOrPasta::Tag tag) {
    switch (tag) {
      case ::test_union::ExplicitPizzaOrPasta::Tag::kPizza:
        return 1;
      case ::test_union::ExplicitPizzaOrPasta::Tag::kPasta:
        return 2;
    }
  }

  static constexpr ::test_union::ExplicitPizzaOrPasta::Tag IndexToTag(
      size_t index) {
    switch (index) {
      case 1:
        return ::test_union::ExplicitPizzaOrPasta::Tag::kPizza;
      case 2:
        return ::test_union::ExplicitPizzaOrPasta::Tag::kPasta;
      // TODO: what's the right thing to do here?
      default:
        return ::test_union::ExplicitPizzaOrPasta::Tag::kPizza;
    }
  }
};

extern "C" const fidl_type_t test_union_OlderSimpleUnionTable;

class OlderSimpleUnion final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, int64_t, float>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kI = 1,  // 0x1
    kF = 2,  // 0x2
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  // Create an unknown value of this union.
  OlderSimpleUnion() : storage_(std::make_shared<Storage_>()) {}

  OlderSimpleUnion(OlderSimpleUnion&&) noexcept = default;
  OlderSimpleUnion& operator=(OlderSimpleUnion&&) noexcept = default;
  OlderSimpleUnion(const OlderSimpleUnion& other) noexcept
      : OlderSimpleUnion(other.CloneStorage_()) {}
  OlderSimpleUnion& operator=(const OlderSimpleUnion& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const OlderSimpleUnion& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const OlderSimpleUnion& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::OlderSimpleUnion::Tag Which() const {
    return OlderSimpleUnion::IndexToTag(storage_->index());
  }
  static OlderSimpleUnion WithI(int64_t val) {
    return OlderSimpleUnion(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> i() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> i() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static OlderSimpleUnion WithF(float val) {
    return OlderSimpleUnion(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> f() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> f() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::OlderSimpleUnion>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 3>
      kMembers = {std::nullopt, std::nullopt, std::nullopt};

  explicit OlderSimpleUnion(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::test_union::OlderSimpleUnion::Tag tag) {
    switch (tag) {
      case ::test_union::OlderSimpleUnion::Tag::kI:
        return 1;
      case ::test_union::OlderSimpleUnion::Tag::kF:
        return 2;
      case ::test_union::OlderSimpleUnion::Tag::kUnknown:
        return 0;
    }
  }

  static constexpr ::test_union::OlderSimpleUnion::Tag IndexToTag(
      size_t index) {
    switch (index) {
      case 1:
        return ::test_union::OlderSimpleUnion::Tag::kI;
      case 2:
        return ::test_union::OlderSimpleUnion::Tag::kF;
      default:
        return ::test_union::OlderSimpleUnion::Tag::kUnknown;
    }
  }
};

extern "C" const fidl_type_t
    test_union_TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponseTable;

class TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse
    final {
 private:
  struct Storage_;

 public:
  TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse(
      Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse(
      ::test_union::OlderSimpleUnion xu) noexcept
      : storage_({.xu = std::move(xu)}) {}
  TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse()
      : TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse(
            Storage_{}) {}

  TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse(
      TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse&&) noexcept =
      default;
  TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse&
  operator=(
      TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse&&) noexcept =
      default;
  TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse(
      const TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse&
          other) noexcept
      : TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse(
            other.CloneStorage_()) {}
  TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse&
  operator=(
      const TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse&
          other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse&
          other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_union::
            TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse,
        24, 16>::Equal(this, &other);
  }
  bool operator!=(
      const TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse&
          other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_union::
            TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse,
        24, 16>::Equal(this, &other);
  }

  const ::test_union::OlderSimpleUnion& xu() const { return storage_.xu; }

  ::test_union::OlderSimpleUnion& xu() { return storage_.xu; }

 private:
  struct Storage_ final {
    ::test_union::OlderSimpleUnion xu{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_union::
          TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse,
      24, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_union::
          TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_,
                                            ::test_union::OlderSimpleUnion>{
          &Storage_::xu, 0, 0});
};

extern "C" const fidl_type_t test_union_NullableUnionStructTable;

class NullableUnionStruct final {
 private:
  struct Storage_;

 public:
  NullableUnionStruct(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  NullableUnionStruct(::std::unique_ptr<::test_union::Union> the_union) noexcept
      : storage_({.the_union = std::move(the_union)}) {}
  NullableUnionStruct() : NullableUnionStruct(Storage_{}) {}

  NullableUnionStruct(NullableUnionStruct&&) noexcept = default;
  NullableUnionStruct& operator=(NullableUnionStruct&&) noexcept = default;
  NullableUnionStruct(const NullableUnionStruct& other) noexcept
      : NullableUnionStruct(other.CloneStorage_()) {}
  NullableUnionStruct& operator=(const NullableUnionStruct& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const NullableUnionStruct& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_union::NullableUnionStruct, 24, 16>::Equal(this, &other);
  }
  bool operator!=(const NullableUnionStruct& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_union::NullableUnionStruct, 24, 16>::Equal(this, &other);
  }

  const ::std::unique_ptr<::test_union::Union>& the_union() const {
    return storage_.the_union;
  }

  ::std::unique_ptr<::test_union::Union>& the_union() {
    return storage_.the_union;
  }

 private:
  struct Storage_ final {
    ::std::unique_ptr<::test_union::Union> the_union{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_union::NullableUnionStruct, 24, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_union::NullableUnionStruct>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<
                      Storage_, ::std::unique_ptr<::test_union::Union>>{
          &Storage_::the_union, 0, 0});
};

extern "C" const fidl_type_t test_union_NewerSimpleUnionTable;

class NewerSimpleUnion final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, int64_t, ::std::string,
                                  ::std::vector<::std::string>>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kI = 1,  // 0x1
    kS = 2,  // 0x2
    kV = 3,  // 0x3
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  // Create an unknown value of this union.
  NewerSimpleUnion() : storage_(std::make_shared<Storage_>()) {}

  NewerSimpleUnion(NewerSimpleUnion&&) noexcept = default;
  NewerSimpleUnion& operator=(NewerSimpleUnion&&) noexcept = default;
  NewerSimpleUnion(const NewerSimpleUnion& other) noexcept
      : NewerSimpleUnion(other.CloneStorage_()) {}
  NewerSimpleUnion& operator=(const NewerSimpleUnion& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const NewerSimpleUnion& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const NewerSimpleUnion& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::NewerSimpleUnion::Tag Which() const {
    return NewerSimpleUnion::IndexToTag(storage_->index());
  }
  static NewerSimpleUnion WithI(int64_t val) {
    return NewerSimpleUnion(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> i() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> i() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static NewerSimpleUnion WithS(::std::string val) {
    return NewerSimpleUnion(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> s() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> s() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  static NewerSimpleUnion WithV(::std::vector<::std::string> val) {
    return NewerSimpleUnion(
        std::make_shared<Storage_>(std::in_place_index_t<3>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<3, Storage_> v() const {
    return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<3, Storage_> v() {
    return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::NewerSimpleUnion>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 4>
      kMembers = {std::nullopt, std::nullopt, std::nullopt, std::nullopt};

  explicit NewerSimpleUnion(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::test_union::NewerSimpleUnion::Tag tag) {
    switch (tag) {
      case ::test_union::NewerSimpleUnion::Tag::kI:
        return 1;
      case ::test_union::NewerSimpleUnion::Tag::kS:
        return 2;
      case ::test_union::NewerSimpleUnion::Tag::kV:
        return 3;
      case ::test_union::NewerSimpleUnion::Tag::kUnknown:
        return 0;
    }
  }

  static constexpr ::test_union::NewerSimpleUnion::Tag IndexToTag(
      size_t index) {
    switch (index) {
      case 1:
        return ::test_union::NewerSimpleUnion::Tag::kI;
      case 2:
        return ::test_union::NewerSimpleUnion::Tag::kS;
      case 3:
        return ::test_union::NewerSimpleUnion::Tag::kV;
      default:
        return ::test_union::NewerSimpleUnion::Tag::kUnknown;
    }
  }
};

extern "C" const fidl_type_t test_union_FlexibleUnionTable;

class FlexibleUnion final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, int32_t, ::std::string,
                                  ::std::vector<::std::string>>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  // Create an unknown value of this union.
  FlexibleUnion() : storage_(std::make_shared<Storage_>()) {}

  FlexibleUnion(FlexibleUnion&&) noexcept = default;
  FlexibleUnion& operator=(FlexibleUnion&&) noexcept = default;
  FlexibleUnion(const FlexibleUnion& other) noexcept
      : FlexibleUnion(other.CloneStorage_()) {}
  FlexibleUnion& operator=(const FlexibleUnion& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const FlexibleUnion& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const FlexibleUnion& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::FlexibleUnion::Tag Which() const {
    return FlexibleUnion::IndexToTag(storage_->index());
  }
  static FlexibleUnion WithPrimitive(int32_t val) {
    return FlexibleUnion(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> primitive() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> primitive() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static FlexibleUnion WithStringNeedsConstructor(::std::string val) {
    return FlexibleUnion(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_>
  string_needs_constructor() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> string_needs_constructor() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  static FlexibleUnion WithVectorStringAlsoNeedsConstructor(
      ::std::vector<::std::string> val) {
    return FlexibleUnion(
        std::make_shared<Storage_>(std::in_place_index_t<3>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<3, Storage_>
  vector_string_also_needs_constructor() const {
    return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<3, Storage_>
  vector_string_also_needs_constructor() {
    return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::FlexibleUnion>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 4>
      kMembers = {std::nullopt, std::nullopt, std::nullopt, std::nullopt};

  explicit FlexibleUnion(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::test_union::FlexibleUnion::Tag tag) {
    switch (tag) {
      case ::test_union::FlexibleUnion::Tag::kPrimitive:
        return 1;
      case ::test_union::FlexibleUnion::Tag::kStringNeedsConstructor:
        return 2;
      case ::test_union::FlexibleUnion::Tag::kVectorStringAlsoNeedsConstructor:
        return 3;
      case ::test_union::FlexibleUnion::Tag::kUnknown:
        return 0;
    }
  }

  static constexpr ::test_union::FlexibleUnion::Tag IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_union::FlexibleUnion::Tag::kPrimitive;
      case 2:
        return ::test_union::FlexibleUnion::Tag::kStringNeedsConstructor;
      case 3:
        return ::test_union::FlexibleUnion::Tag::
            kVectorStringAlsoNeedsConstructor;
      default:
        return ::test_union::FlexibleUnion::Tag::kUnknown;
    }
  }
};

extern "C" const fidl_type_t test_union_FlexibleFooTable;

class FlexibleFoo final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, ::std::string, int32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kS = 1,  // 0x1
    kI = 2,  // 0x2
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  // Create an unknown value of this union.
  FlexibleFoo() : storage_(std::make_shared<Storage_>()) {}

  FlexibleFoo(FlexibleFoo&&) noexcept = default;
  FlexibleFoo& operator=(FlexibleFoo&&) noexcept = default;
  FlexibleFoo(const FlexibleFoo& other) noexcept
      : FlexibleFoo(other.CloneStorage_()) {}
  FlexibleFoo& operator=(const FlexibleFoo& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const FlexibleFoo& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const FlexibleFoo& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::FlexibleFoo::Tag Which() const {
    return FlexibleFoo::IndexToTag(storage_->index());
  }
  static FlexibleFoo WithS(::std::string val) {
    return FlexibleFoo(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> s() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> s() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static FlexibleFoo WithI(int32_t val) {
    return FlexibleFoo(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> i() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> i() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::FlexibleFoo>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 3>
      kMembers = {std::nullopt, std::nullopt, std::nullopt};

  explicit FlexibleFoo(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::test_union::FlexibleFoo::Tag tag) {
    switch (tag) {
      case ::test_union::FlexibleFoo::Tag::kS:
        return 1;
      case ::test_union::FlexibleFoo::Tag::kI:
        return 2;
      case ::test_union::FlexibleFoo::Tag::kUnknown:
        return 0;
    }
  }

  static constexpr ::test_union::FlexibleFoo::Tag IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_union::FlexibleFoo::Tag::kS;
      case 2:
        return ::test_union::FlexibleFoo::Tag::kI;
      default:
        return ::test_union::FlexibleFoo::Tag::kUnknown;
    }
  }
};

extern "C" const fidl_type_t test_union_FieldCollisionTable;

class FieldCollision final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, int32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kFieldCollisionTag = 1,  // 0x1
  };

  // Create an unknown value of this union.
  FieldCollision() : storage_(std::make_shared<Storage_>()) {}

  FieldCollision(FieldCollision&&) noexcept = default;
  FieldCollision& operator=(FieldCollision&&) noexcept = default;
  FieldCollision(const FieldCollision& other) noexcept
      : FieldCollision(other.CloneStorage_()) {}
  FieldCollision& operator=(const FieldCollision& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const FieldCollision& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const FieldCollision& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::FieldCollision::Tag Which() const {
    return FieldCollision::IndexToTag(storage_->index());
  }
  static FieldCollision WithFieldCollisionTag(int32_t val) {
    return FieldCollision(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> field_collision_tag()
      const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> field_collision_tag() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::FieldCollision>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 2>
      kMembers = {std::nullopt, std::nullopt};

  explicit FieldCollision(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::test_union::FieldCollision::Tag tag) {
    switch (tag) {
      case ::test_union::FieldCollision::Tag::kFieldCollisionTag:
        return 1;
    }
  }

  static constexpr ::test_union::FieldCollision::Tag IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_union::FieldCollision::Tag::kFieldCollisionTag;
      // TODO: what's the right thing to do here?
      default:
        return ::test_union::FieldCollision::Tag::kFieldCollisionTag;
    }
  }
};

extern "C" const fidl_type_t test_union_ExplicitXUnionTable;

class ExplicitXUnion final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, int64_t, float>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kI = 1,  // 0x1
    kF = 4,  // 0x4
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  // Create an unknown value of this union.
  ExplicitXUnion() : storage_(std::make_shared<Storage_>()) {}

  ExplicitXUnion(ExplicitXUnion&&) noexcept = default;
  ExplicitXUnion& operator=(ExplicitXUnion&&) noexcept = default;
  ExplicitXUnion(const ExplicitXUnion& other) noexcept
      : ExplicitXUnion(other.CloneStorage_()) {}
  ExplicitXUnion& operator=(const ExplicitXUnion& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const ExplicitXUnion& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const ExplicitXUnion& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::ExplicitXUnion::Tag Which() const {
    return ExplicitXUnion::IndexToTag(storage_->index());
  }
  static ExplicitXUnion WithI(int64_t val) {
    return ExplicitXUnion(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> i() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> i() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static ExplicitXUnion WithF(float val) {
    return ExplicitXUnion(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> f() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> f() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::ExplicitXUnion>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 3>
      kMembers = {std::nullopt, std::nullopt, std::nullopt};

  explicit ExplicitXUnion(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::test_union::ExplicitXUnion::Tag tag) {
    switch (tag) {
      case ::test_union::ExplicitXUnion::Tag::kI:
        return 1;
      case ::test_union::ExplicitXUnion::Tag::kF:
        return 2;
      case ::test_union::ExplicitXUnion::Tag::kUnknown:
        return 0;
    }
  }

  static constexpr ::test_union::ExplicitXUnion::Tag IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_union::ExplicitXUnion::Tag::kI;
      case 2:
        return ::test_union::ExplicitXUnion::Tag::kF;
      default:
        return ::test_union::ExplicitXUnion::Tag::kUnknown;
    }
  }
};

extern "C" const fidl_type_t test_union_UnionSandwichTable;

class UnionSandwich final {
 private:
  struct Storage_;

 public:
  UnionSandwich(Storage_ storage) noexcept : storage_(std::move(storage)) {}
  UnionSandwich(uint32_t a, ::test_union::ExplicitXUnion u, uint32_t b) noexcept
      : storage_({.a = std::move(a), .u = std::move(u), .b = std::move(b)}) {}
  UnionSandwich() : UnionSandwich(Storage_{}) {}

  UnionSandwich(UnionSandwich&&) noexcept = default;
  UnionSandwich& operator=(UnionSandwich&&) noexcept = default;
  UnionSandwich(const UnionSandwich& other) noexcept
      : UnionSandwich(other.CloneStorage_()) {}
  UnionSandwich& operator=(const UnionSandwich& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const UnionSandwich& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_union::UnionSandwich, 40, 32>::Equal(this, &other);
  }
  bool operator!=(const UnionSandwich& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_union::UnionSandwich, 40, 32>::Equal(this, &other);
  }

  uint32_t a() const { return storage_.a; }

  uint32_t& a() { return storage_.a; }

  const ::test_union::ExplicitXUnion& u() const { return storage_.u; }

  ::test_union::ExplicitXUnion& u() { return storage_.u; }

  uint32_t b() const { return storage_.b; }

  uint32_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    uint32_t a{};
    ::test_union::ExplicitXUnion u{};
    uint32_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_union::UnionSandwich, 40, 32>;
  friend struct ::fidl::internal::MemberVisitor<::test_union::UnionSandwich>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<Storage_, uint32_t>{&Storage_::a, 0,
                                                                0},
      ::fidl::internal::NaturalStructMember<Storage_,
                                            ::test_union::ExplicitXUnion>{
          &Storage_::u, 8, 8},
      ::fidl::internal::NaturalStructMember<Storage_, uint32_t>{&Storage_::b,
                                                                32, 24});
};

extern "C" const fidl_type_t test_union_ExplicitUnionTable;

class ExplicitUnion final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, int32_t, ::std::string>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kPrimitive = 1,               // 0x1
    kStringNeedsConstructor = 3,  // 0x3
  };

  // Create an unknown value of this union.
  ExplicitUnion() : storage_(std::make_shared<Storage_>()) {}

  ExplicitUnion(ExplicitUnion&&) noexcept = default;
  ExplicitUnion& operator=(ExplicitUnion&&) noexcept = default;
  ExplicitUnion(const ExplicitUnion& other) noexcept
      : ExplicitUnion(other.CloneStorage_()) {}
  ExplicitUnion& operator=(const ExplicitUnion& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const ExplicitUnion& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const ExplicitUnion& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::ExplicitUnion::Tag Which() const {
    return ExplicitUnion::IndexToTag(storage_->index());
  }
  static ExplicitUnion WithPrimitive(int32_t val) {
    return ExplicitUnion(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> primitive() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> primitive() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static ExplicitUnion WithStringNeedsConstructor(::std::string val) {
    return ExplicitUnion(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_>
  string_needs_constructor() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> string_needs_constructor() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::ExplicitUnion>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 3>
      kMembers = {std::nullopt, std::nullopt, std::nullopt};

  explicit ExplicitUnion(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::test_union::ExplicitUnion::Tag tag) {
    switch (tag) {
      case ::test_union::ExplicitUnion::Tag::kPrimitive:
        return 1;
      case ::test_union::ExplicitUnion::Tag::kStringNeedsConstructor:
        return 2;
    }
  }

  static constexpr ::test_union::ExplicitUnion::Tag IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_union::ExplicitUnion::Tag::kPrimitive;
      case 2:
        return ::test_union::ExplicitUnion::Tag::kStringNeedsConstructor;
      // TODO: what's the right thing to do here?
      default:
        return ::test_union::ExplicitUnion::Tag::kPrimitive;
    }
  }
};

extern "C" const fidl_type_t test_union_ExplicitStrictFooTable;

class ExplicitStrictFoo final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, ::std::string, int32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kS = 3,  // 0x3
    kI = 2,  // 0x2
  };

  // Create an unknown value of this union.
  ExplicitStrictFoo() : storage_(std::make_shared<Storage_>()) {}

  ExplicitStrictFoo(ExplicitStrictFoo&&) noexcept = default;
  ExplicitStrictFoo& operator=(ExplicitStrictFoo&&) noexcept = default;
  ExplicitStrictFoo(const ExplicitStrictFoo& other) noexcept
      : ExplicitStrictFoo(other.CloneStorage_()) {}
  ExplicitStrictFoo& operator=(const ExplicitStrictFoo& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const ExplicitStrictFoo& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const ExplicitStrictFoo& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::ExplicitStrictFoo::Tag Which() const {
    return ExplicitStrictFoo::IndexToTag(storage_->index());
  }
  static ExplicitStrictFoo WithS(::std::string val) {
    return ExplicitStrictFoo(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> s() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> s() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static ExplicitStrictFoo WithI(int32_t val) {
    return ExplicitStrictFoo(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> i() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> i() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::ExplicitStrictFoo>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 3>
      kMembers = {std::nullopt, std::nullopt, std::nullopt};

  explicit ExplicitStrictFoo(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::test_union::ExplicitStrictFoo::Tag tag) {
    switch (tag) {
      case ::test_union::ExplicitStrictFoo::Tag::kS:
        return 1;
      case ::test_union::ExplicitStrictFoo::Tag::kI:
        return 2;
    }
  }

  static constexpr ::test_union::ExplicitStrictFoo::Tag IndexToTag(
      size_t index) {
    switch (index) {
      case 1:
        return ::test_union::ExplicitStrictFoo::Tag::kS;
      case 2:
        return ::test_union::ExplicitStrictFoo::Tag::kI;
      // TODO: what's the right thing to do here?
      default:
        return ::test_union::ExplicitStrictFoo::Tag::kS;
    }
  }
};

extern "C" const fidl_type_t test_union_ExplicitFooTable;

class ExplicitFoo final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, ::std::string, int32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kS = 2,  // 0x2
    kI = 1,  // 0x1
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  // Create an unknown value of this union.
  ExplicitFoo() : storage_(std::make_shared<Storage_>()) {}

  ExplicitFoo(ExplicitFoo&&) noexcept = default;
  ExplicitFoo& operator=(ExplicitFoo&&) noexcept = default;
  ExplicitFoo(const ExplicitFoo& other) noexcept
      : ExplicitFoo(other.CloneStorage_()) {}
  ExplicitFoo& operator=(const ExplicitFoo& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const ExplicitFoo& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const ExplicitFoo& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::ExplicitFoo::Tag Which() const {
    return ExplicitFoo::IndexToTag(storage_->index());
  }
  static ExplicitFoo WithS(::std::string val) {
    return ExplicitFoo(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> s() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> s() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static ExplicitFoo WithI(int32_t val) {
    return ExplicitFoo(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> i() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> i() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::ExplicitFoo>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 3>
      kMembers = {std::nullopt, std::nullopt, std::nullopt};

  explicit ExplicitFoo(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::test_union::ExplicitFoo::Tag tag) {
    switch (tag) {
      case ::test_union::ExplicitFoo::Tag::kS:
        return 1;
      case ::test_union::ExplicitFoo::Tag::kI:
        return 2;
      case ::test_union::ExplicitFoo::Tag::kUnknown:
        return 0;
    }
  }

  static constexpr ::test_union::ExplicitFoo::Tag IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_union::ExplicitFoo::Tag::kS;
      case 2:
        return ::test_union::ExplicitFoo::Tag::kI;
      default:
        return ::test_union::ExplicitFoo::Tag::kUnknown;
    }
  }
};

extern "C" const fidl_type_t test_union_EmptyTable;

class Empty final {
 private:
  struct Storage_;

 public:
  Empty(Storage_ storage) noexcept : storage_(std::move(storage)) {}
  Empty(uint8_t __reserved) noexcept
      : storage_({.__reserved = std::move(__reserved)}) {}
  Empty() : Empty(Storage_{}) {}

  Empty(Empty&&) noexcept = default;
  Empty& operator=(Empty&&) noexcept = default;
  Empty(const Empty& other) noexcept : Empty(other.CloneStorage_()) {}
  Empty& operator=(const Empty& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const Empty& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<::test_union::Empty, 1,
                                                       1>::Equal(this, &other);
  }
  bool operator!=(const Empty& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<::test_union::Empty, 1,
                                                        1>::Equal(this, &other);
  }

  uint8_t __reserved() const { return storage_.__reserved; }

  uint8_t& __reserved() { return storage_.__reserved; }

 private:
  struct Storage_ final {
    uint8_t __reserved = 0u;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_union::Empty,
                                                            1, 1>;
  friend struct ::fidl::internal::MemberVisitor<::test_union::Empty>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, uint8_t>{
          &Storage_::__reserved, 0, 0});
};

extern "C" const fidl_type_t test_union_XUnionContainingEmptyStructTable;

class XUnionContainingEmptyStruct final {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, ::test_union::Empty>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kEmpty = 1,  // 0x1
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  // Create an unknown value of this union.
  XUnionContainingEmptyStruct() : storage_(std::make_shared<Storage_>()) {}

  XUnionContainingEmptyStruct(XUnionContainingEmptyStruct&&) noexcept = default;
  XUnionContainingEmptyStruct& operator=(
      XUnionContainingEmptyStruct&&) noexcept = default;
  XUnionContainingEmptyStruct(const XUnionContainingEmptyStruct& other) noexcept
      : XUnionContainingEmptyStruct(other.CloneStorage_()) {}
  XUnionContainingEmptyStruct& operator=(
      const XUnionContainingEmptyStruct& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const XUnionContainingEmptyStruct& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const XUnionContainingEmptyStruct& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_union::XUnionContainingEmptyStruct::Tag Which() const {
    return XUnionContainingEmptyStruct::IndexToTag(storage_->index());
  }
  static XUnionContainingEmptyStruct WithEmpty(::test_union::Empty val) {
    return XUnionContainingEmptyStruct(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> empty() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> empty() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_union::XUnionContainingEmptyStruct>;
  static constexpr std::array<
      std::optional<::fidl::internal::NaturalHandleInformation>, 2>
      kMembers = {std::nullopt, std::nullopt};

  explicit XUnionContainingEmptyStruct(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::test_union::XUnionContainingEmptyStruct::Tag tag) {
    switch (tag) {
      case ::test_union::XUnionContainingEmptyStruct::Tag::kEmpty:
        return 1;
      case ::test_union::XUnionContainingEmptyStruct::Tag::kUnknown:
        return 0;
    }
  }

  static constexpr ::test_union::XUnionContainingEmptyStruct::Tag IndexToTag(
      size_t index) {
    switch (index) {
      case 1:
        return ::test_union::XUnionContainingEmptyStruct::Tag::kEmpty;
      default:
        return ::test_union::XUnionContainingEmptyStruct::Tag::kUnknown;
    }
  }
};

}  // namespace test_union
namespace fidl {

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_union_StructWithNullableXUnionTable;

template <>
struct IsFidlType<::test_union::StructWithNullableXUnion>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_union::StructWithNullableXUnion>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_union_StructWithNullableXUnionTable;
};

template <>
struct internal::NaturalCodingTraits<::test_union::StructWithNullableXUnion>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_union::StructWithNullableXUnion, 24, 16> {};

template <>
struct HasPadding<::test_union::StructWithNullableXUnion>
    : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_union::StructWithNullableXUnion>
    : public internal::BoolConstant<
          !HasPadding<::test_union::StructWithNullableXUnion>::value &&
          internal::NaturalIsMemcpyCompatible<
              ::std::unique_ptr<::test_union::OlderSimpleUnion>>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_union_TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponseTable;

template <>
struct IsFidlType<
    ::test_union::
        TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_union::
        TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_union_TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_union::
        TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_union::
              TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse,
          24, 16> {};

template <>
struct HasPadding<
    ::test_union::
        TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse>
    : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_union::
        TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse>
    : public internal::BoolConstant<
          !HasPadding<
              ::test_union::
                  TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse>::
              value &&
          internal::NaturalIsMemcpyCompatible<
              ::test_union::StrictBoundedXUnion>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_union_PizzaTable;

template <>
struct IsFidlType<::test_union::Pizza> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_union::Pizza> final {
 public:
  static constexpr const fidl_type_t* kCodingTable = &test_union_PizzaTable;
};

template <>
struct internal::NaturalCodingTraits<::test_union::Pizza> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_union::Pizza,
                                                         16, 16> {};

template <>
struct HasPadding<::test_union::Pizza> : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_union::Pizza>
    : public internal::BoolConstant<!HasPadding<::test_union::Pizza>::value &&
                                    internal::NaturalIsMemcpyCompatible<
                                        ::std::vector<::std::string>>::value> {
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_union_PastaTable;

template <>
struct IsFidlType<::test_union::Pasta> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_union::Pasta> final {
 public:
  static constexpr const fidl_type_t* kCodingTable = &test_union_PastaTable;
};

template <>
struct internal::NaturalCodingTraits<::test_union::Pasta> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_union::Pasta,
                                                         16, 16> {};

template <>
struct HasPadding<::test_union::Pasta> : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_union::Pasta>
    : public internal::BoolConstant<
          !HasPadding<::test_union::Pasta>::value &&
          internal::NaturalIsMemcpyCompatible<::std::string>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_union_TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponseTable;

template <>
struct IsFidlType<
    ::test_union::
        TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_union::
        TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_union_TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_union::
        TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_union::
              TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse,
          24, 16> {};

template <>
struct HasPadding<
    ::test_union::
        TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse>
    : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<
    ::test_union::
        TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse>
    : public internal::BoolConstant<
          !HasPadding<
              ::test_union::
                  TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse>::
              value &&
          internal::NaturalIsMemcpyCompatible<
              ::test_union::OlderSimpleUnion>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_union_NullableUnionStructTable;

template <>
struct IsFidlType<::test_union::NullableUnionStruct> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_union::NullableUnionStruct> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_union_NullableUnionStructTable;
};

template <>
struct internal::NaturalCodingTraits<::test_union::NullableUnionStruct> final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_union::NullableUnionStruct, 24, 16> {};

template <>
struct HasPadding<::test_union::NullableUnionStruct> : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_union::NullableUnionStruct>
    : public internal::BoolConstant<
          !HasPadding<::test_union::NullableUnionStruct>::value &&
          internal::NaturalIsMemcpyCompatible<
              ::std::unique_ptr<::test_union::Union>>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_union_UnionSandwichTable;

template <>
struct IsFidlType<::test_union::UnionSandwich> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_union::UnionSandwich> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_union_UnionSandwichTable;
};

template <>
struct internal::NaturalCodingTraits<::test_union::UnionSandwich> final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_union::UnionSandwich, 40, 32> {};

template <>
struct HasPadding<::test_union::UnionSandwich> : public std::true_type {};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_union::UnionSandwich>
    : public internal::BoolConstant<
          !HasPadding<::test_union::UnionSandwich>::value &&
          internal::NaturalIsMemcpyCompatible<uint32_t>::value &&
          internal::NaturalIsMemcpyCompatible<
              ::test_union::ExplicitXUnion>::value> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_union_EmptyTable;

template <>
struct IsFidlType<::test_union::Empty> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_union::Empty> final {
 public:
  static constexpr const fidl_type_t* kCodingTable = &test_union_EmptyTable;
};

template <>
struct internal::NaturalCodingTraits<::test_union::Empty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_union::Empty, 1,
                                                         1> {};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_union::Empty>
    : public internal::BoolConstant<
          !HasPadding<::test_union::Empty>::value &&
          internal::NaturalIsMemcpyCompatible<uint8_t>::value> {};

#endif  // __Fuchsia__

template <>
struct IsFidlType<::test_union::UnionWithAttributes> : public std::true_type {};
template <>
struct IsUnion<::test_union::UnionWithAttributes> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::UnionWithAttributes> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_union::UnionWithAttributes> {};

template <>
struct IsFidlType<::test_union::Union> : public std::true_type {};
template <>
struct IsUnion<::test_union::Union> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::Union> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::Union> {};

template <>
struct IsFidlType<::test_union::StrictUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::StrictUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::StrictUnion> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_union::StrictUnion> {};

template <>
struct IsFidlType<::test_union::StrictSimpleXUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::StrictSimpleXUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::StrictSimpleXUnion> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_union::StrictSimpleXUnion> {};

template <>
struct IsFidlType<::test_union::StrictFoo> : public std::true_type {};
template <>
struct IsUnion<::test_union::StrictFoo> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::StrictFoo> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_union::StrictFoo> {};

template <>
struct IsFidlType<::test_union::StrictBoundedXUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::StrictBoundedXUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::StrictBoundedXUnion> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_union::StrictBoundedXUnion> {};

template <>
struct IsFidlType<::test_union::ReverseOrdinalUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::ReverseOrdinalUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::ReverseOrdinalUnion> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_union::ReverseOrdinalUnion> {};

template <>
struct IsFidlType<::test_union::StrictPizzaOrPasta> : public std::true_type {};
template <>
struct IsUnion<::test_union::StrictPizzaOrPasta> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::StrictPizzaOrPasta> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_union::StrictPizzaOrPasta> {};

template <>
struct IsFidlType<::test_union::PizzaOrPasta> : public std::true_type {};
template <>
struct IsUnion<::test_union::PizzaOrPasta> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::PizzaOrPasta> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_union::PizzaOrPasta> {};

template <>
struct IsFidlType<::test_union::FlexiblePizzaOrPasta> : public std::true_type {
};
template <>
struct IsUnion<::test_union::FlexiblePizzaOrPasta> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::FlexiblePizzaOrPasta> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_union::FlexiblePizzaOrPasta> {};

template <>
struct IsFidlType<::test_union::ExplicitPizzaOrPasta> : public std::true_type {
};
template <>
struct IsUnion<::test_union::ExplicitPizzaOrPasta> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::ExplicitPizzaOrPasta> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_union::ExplicitPizzaOrPasta> {};

template <>
struct IsFidlType<::test_union::OlderSimpleUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::OlderSimpleUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::OlderSimpleUnion> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_union::OlderSimpleUnion> {};

template <>
struct IsFidlType<::test_union::NewerSimpleUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::NewerSimpleUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::NewerSimpleUnion> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_union::NewerSimpleUnion> {};

template <>
struct IsFidlType<::test_union::FlexibleUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::FlexibleUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::FlexibleUnion> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_union::FlexibleUnion> {};

template <>
struct IsFidlType<::test_union::FlexibleFoo> : public std::true_type {};
template <>
struct IsUnion<::test_union::FlexibleFoo> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::FlexibleFoo> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_union::FlexibleFoo> {};

template <>
struct IsFidlType<::test_union::FieldCollision> : public std::true_type {};
template <>
struct IsUnion<::test_union::FieldCollision> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::FieldCollision> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_union::FieldCollision> {};

template <>
struct IsFidlType<::test_union::ExplicitXUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::ExplicitXUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::ExplicitXUnion> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_union::ExplicitXUnion> {};

template <>
struct IsFidlType<::test_union::ExplicitUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::ExplicitUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::ExplicitUnion> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_union::ExplicitUnion> {};

template <>
struct IsFidlType<::test_union::ExplicitStrictFoo> : public std::true_type {};
template <>
struct IsUnion<::test_union::ExplicitStrictFoo> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::ExplicitStrictFoo> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_union::ExplicitStrictFoo> {};

template <>
struct IsFidlType<::test_union::ExplicitFoo> : public std::true_type {};
template <>
struct IsUnion<::test_union::ExplicitFoo> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::ExplicitFoo> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_union::ExplicitFoo> {};

template <>
struct IsFidlType<::test_union::XUnionContainingEmptyStruct>
    : public std::true_type {};
template <>
struct IsUnion<::test_union::XUnionContainingEmptyStruct>
    : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::XUnionContainingEmptyStruct>
    final : public ::fidl::internal::NaturalUnionCodingTraits<
                ::test_union::XUnionContainingEmptyStruct> {};

}  // namespace fidl
