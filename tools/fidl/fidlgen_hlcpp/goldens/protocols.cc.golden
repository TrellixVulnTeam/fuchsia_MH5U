// WARNING: This file is machine generated by fidlgen.

#include <test/protocols/cpp/fidl.h>

#include "lib/fidl/cpp/internal/implementation.h"

//
// Domain objects definitions (i.e. "natural types" in unified bindings)
//
namespace test {
namespace protocols {

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_HandleInResult_ResponseTable;
const fidl_type_t* WithErrorSyntax_HandleInResult_Response::FidlType =
    &test_protocols_WithErrorSyntax_HandleInResult_ResponseTable;

void WithErrorSyntax_HandleInResult_Response::Encode(
    ::fidl::Encoder* _encoder, size_t _offset,
    cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<
          WithErrorSyntax_HandleInResult_Response>::value) {
    memcpy(_encoder->template GetPtr<WithErrorSyntax_HandleInResult_Response>(
               _offset),
           this, sizeof(WithErrorSyntax_HandleInResult_Response));
  } else {
    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, &h, _offset + 0,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_NONE,
                         .rights = 0x80000000,
                     });

    } else {
      ::fidl::Encode(_encoder, &h, _offset + 0,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_NONE,
                         .rights = 0x80000000,
                     });
    }
  }
}

void WithErrorSyntax_HandleInResult_Response::Decode(
    ::fidl::Decoder* _decoder, WithErrorSyntax_HandleInResult_Response* _value,
    size_t _offset) {
  if (::fidl::IsMemcpyCompatible<
          WithErrorSyntax_HandleInResult_Response>::value) {
    memcpy(_value,
           _decoder->template GetPtr<WithErrorSyntax_HandleInResult_Response>(
               _offset),
           sizeof(WithErrorSyntax_HandleInResult_Response));
  } else {
    ::fidl::Decode(_decoder, &_value->h, _offset + 0);
  }
}

zx_status_t WithErrorSyntax_HandleInResult_Response::Clone(
    WithErrorSyntax_HandleInResult_Response* _result) const {
  zx_status_t _status = ::fidl::Clone(h, &_result->h);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_HandleInResult_ResultTable;
const fidl_type_t* WithErrorSyntax_HandleInResult_Result::FidlType =
    &test_protocols_WithErrorSyntax_HandleInResult_ResultTable;

WithErrorSyntax_HandleInResult_Result::WithErrorSyntax_HandleInResult_Result() {
}

WithErrorSyntax_HandleInResult_Result::
    ~WithErrorSyntax_HandleInResult_Result() {
  Destroy();
}

WithErrorSyntax_HandleInResult_Result::WithErrorSyntax_HandleInResult_Result(
    WithErrorSyntax_HandleInResult_Result&& other)
    : tag_(other.tag_) {
  switch (tag_) {
    case ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::
        kResponse:
      new (&response_)::test::protocols::
          WithErrorSyntax_HandleInResult_Response();
      response_ = std::move(other.response_);
      break;
    case ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(
        ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::Invalid):
      break;
  }
}

WithErrorSyntax_HandleInResult_Result&
WithErrorSyntax_HandleInResult_Result::operator=(
    WithErrorSyntax_HandleInResult_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::
          kResponse:
        new (&response_)::test::protocols::
            WithErrorSyntax_HandleInResult_Response();
        response_ = std::move(other.response_);
        break;
      case ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(
          ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::
              Invalid):
        break;
    }
  }
  return *this;
}

WithErrorSyntax_HandleInResult_Result
WithErrorSyntax_HandleInResult_Result::WithResponse(
    ::test::protocols::WithErrorSyntax_HandleInResult_Response&& val) {
  WithErrorSyntax_HandleInResult_Result result;
  result.set_response(std::move(val));
  return result;
}
WithErrorSyntax_HandleInResult_Result
WithErrorSyntax_HandleInResult_Result::WithErr(uint32_t&& val) {
  WithErrorSyntax_HandleInResult_Result result;
  result.set_err(std::move(val));
  return result;
}

void WithErrorSyntax_HandleInResult_Result::Encode(
    ::fidl::Encoder* encoder, size_t offset,
    cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::
        kResponse: {
      switch (encoder->wire_format()) {
        case ::fidl::internal::WireFormatVersion::kV1: {
          ::fidl::Encode(
              encoder, &response_,
              encoder->Alloc(::fidl::EncodingInlineSize<
                             ::test::protocols::
                                 WithErrorSyntax_HandleInResult_Response,
                             ::fidl::Encoder>(encoder)));

          fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
          xunion->tag = tag_;
          xunion->envelope.num_bytes =
              static_cast<uint32_t>(encoder->CurrentLength() - length_before);
          xunion->envelope.num_handles = static_cast<uint32_t>(
              encoder->CurrentHandleCount() - handles_before);
          xunion->envelope.presence = FIDL_ALLOC_PRESENT;
          break;
        }
        case ::fidl::internal::WireFormatVersion::kV2: {
          if (::fidl::EncodingInlineSize<
                  ::test::protocols::WithErrorSyntax_HandleInResult_Response>(
                  encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
            ::fidl::Encode(encoder, &response_,
                           offset + offsetof(fidl_xunion_v2_t, envelope));

            fidl_xunion_v2_t* xunion =
                encoder->GetPtr<fidl_xunion_v2_t>(offset);
            xunion->tag = tag_;
            xunion->envelope.num_handles = static_cast<uint16_t>(
                encoder->CurrentHandleCount() - handles_before);
            xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
            break;
          }

          ::fidl::Encode(
              encoder, &response_,
              encoder->Alloc(::fidl::EncodingInlineSize<
                             ::test::protocols::
                                 WithErrorSyntax_HandleInResult_Response,
                             ::fidl::Encoder>(encoder)));

          fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
          xunion->tag = tag_;
          xunion->envelope.num_bytes =
              static_cast<uint32_t>(encoder->CurrentLength() - length_before);
          xunion->envelope.num_handles = static_cast<uint16_t>(
              encoder->CurrentHandleCount() - handles_before);
          xunion->envelope.flags = 0;
          break;
        }
      }
      break;
    }
    case ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::kErr: {
      switch (encoder->wire_format()) {
        case ::fidl::internal::WireFormatVersion::kV1: {
          ::fidl::Encode(
              encoder, &err_,
              encoder->Alloc(
                  ::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(
                      encoder)));

          fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
          xunion->tag = tag_;
          xunion->envelope.num_bytes =
              static_cast<uint32_t>(encoder->CurrentLength() - length_before);
          xunion->envelope.num_handles = static_cast<uint32_t>(
              encoder->CurrentHandleCount() - handles_before);
          xunion->envelope.presence = FIDL_ALLOC_PRESENT;
          break;
        }
        case ::fidl::internal::WireFormatVersion::kV2: {
          if (::fidl::EncodingInlineSize<uint32_t>(encoder) <=
              FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
            ::fidl::Encode(encoder, &err_,
                           offset + offsetof(fidl_xunion_v2_t, envelope));

            fidl_xunion_v2_t* xunion =
                encoder->GetPtr<fidl_xunion_v2_t>(offset);
            xunion->tag = tag_;
            xunion->envelope.num_handles = static_cast<uint16_t>(
                encoder->CurrentHandleCount() - handles_before);
            xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
            break;
          }

          ::fidl::Encode(
              encoder, &err_,
              encoder->Alloc(
                  ::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(
                      encoder)));

          fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
          xunion->tag = tag_;
          xunion->envelope.num_bytes =
              static_cast<uint32_t>(encoder->CurrentLength() - length_before);
          xunion->envelope.num_handles = static_cast<uint16_t>(
              encoder->CurrentHandleCount() - handles_before);
          xunion->envelope.flags = 0;
          break;
        }
      }
      break;
    }
    default:
      break;
  }
}

void WithErrorSyntax_HandleInResult_Result::Decode(
    ::fidl::Decoder* _decoder, WithErrorSyntax_HandleInResult_Result* value,
    size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 && xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(
        ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::
            Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);

  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::
        kResponse: {
      new (&value->response_)::test::protocols::
          WithErrorSyntax_HandleInResult_Response();
      ::fidl::Decode(_decoder, &value->response_, value_offset);
      break;
    }
    case ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::kErr: {
      ::fidl::Decode(_decoder, &value->err_, value_offset);
      break;
    }
    default: {
      break;
    }
  }
}

zx_status_t WithErrorSyntax_HandleInResult_Result::Clone(
    WithErrorSyntax_HandleInResult_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::Invalid:
      return ZX_OK;
    case ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::
        kResponse:
      new (&result->response_)::test::protocols::
          WithErrorSyntax_HandleInResult_Response();
      return ::fidl::Clone(response_, &result->response_);
    case ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:
      return ZX_OK;
  }
}

WithErrorSyntax_HandleInResult_Result&
WithErrorSyntax_HandleInResult_Result::set_response(
    ::test::protocols::WithErrorSyntax_HandleInResult_Response value) {
  EnsureStorageInitialized(
      ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

WithErrorSyntax_HandleInResult_Result&
WithErrorSyntax_HandleInResult_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(
      ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void WithErrorSyntax_HandleInResult_Result::Destroy() {
  switch (tag_) {
    case ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::
        kResponse:
      response_.~decltype(response_)();
      break;
    case ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::kErr:
      break;

    default:
      break;
  }
  tag_ = static_cast<fidl_xunion_tag_t>(
      ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::Invalid);
}

void WithErrorSyntax_HandleInResult_Result::EnsureStorageInitialized(
    ::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(
          ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::
              Invalid):
        break;
      case ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::
          kResponse:
        new (&response_)::test::protocols::
            WithErrorSyntax_HandleInResult_Response();
        break;
      case ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}
#endif  // __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ResponseAsStruct_ResponseTable;
const fidl_type_t* WithErrorSyntax_ResponseAsStruct_Response::FidlType =
    &test_protocols_WithErrorSyntax_ResponseAsStruct_ResponseTable;

void WithErrorSyntax_ResponseAsStruct_Response::Encode(
    ::fidl::Encoder* _encoder, size_t _offset,
    cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<
          WithErrorSyntax_ResponseAsStruct_Response>::value) {
    memcpy(_encoder->template GetPtr<WithErrorSyntax_ResponseAsStruct_Response>(
               _offset),
           this, sizeof(WithErrorSyntax_ResponseAsStruct_Response));
  } else {
    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, &a, _offset + 0);
      ::fidl::Encode(_encoder, &b, _offset + 8);
      ::fidl::Encode(_encoder, &c, _offset + 16);

    } else {
      ::fidl::Encode(_encoder, &a, _offset + 0);
      ::fidl::Encode(_encoder, &b, _offset + 8);
      ::fidl::Encode(_encoder, &c, _offset + 16);
    }
  }
}

void WithErrorSyntax_ResponseAsStruct_Response::Decode(
    ::fidl::Decoder* _decoder,
    WithErrorSyntax_ResponseAsStruct_Response* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<
          WithErrorSyntax_ResponseAsStruct_Response>::value) {
    memcpy(_value,
           _decoder->template GetPtr<WithErrorSyntax_ResponseAsStruct_Response>(
               _offset),
           sizeof(WithErrorSyntax_ResponseAsStruct_Response));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 8);
    ::fidl::Decode(_decoder, &_value->c, _offset + 16);
  }
}

zx_status_t WithErrorSyntax_ResponseAsStruct_Response::Clone(
    WithErrorSyntax_ResponseAsStruct_Response* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(c, &_result->c);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ResponseAsStruct_ResultTable;
const fidl_type_t* WithErrorSyntax_ResponseAsStruct_Result::FidlType =
    &test_protocols_WithErrorSyntax_ResponseAsStruct_ResultTable;

WithErrorSyntax_ResponseAsStruct_Result::
    WithErrorSyntax_ResponseAsStruct_Result() {}

WithErrorSyntax_ResponseAsStruct_Result::
    ~WithErrorSyntax_ResponseAsStruct_Result() {
  Destroy();
}

WithErrorSyntax_ResponseAsStruct_Result::
    WithErrorSyntax_ResponseAsStruct_Result(
        WithErrorSyntax_ResponseAsStruct_Result&& other)
    : tag_(other.tag_) {
  switch (tag_) {
    case ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
        kResponse:
      new (&response_)::test::protocols::
          WithErrorSyntax_ResponseAsStruct_Response();
      response_ = std::move(other.response_);
      break;
    case ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(
        ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
            Invalid):
      break;
  }
}

WithErrorSyntax_ResponseAsStruct_Result&
WithErrorSyntax_ResponseAsStruct_Result::operator=(
    WithErrorSyntax_ResponseAsStruct_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
          kResponse:
        new (&response_)::test::protocols::
            WithErrorSyntax_ResponseAsStruct_Response();
        response_ = std::move(other.response_);
        break;
      case ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
          kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(
          ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
              Invalid):
        break;
    }
  }
  return *this;
}

WithErrorSyntax_ResponseAsStruct_Result
WithErrorSyntax_ResponseAsStruct_Result::WithResponse(
    ::test::protocols::WithErrorSyntax_ResponseAsStruct_Response&& val) {
  WithErrorSyntax_ResponseAsStruct_Result result;
  result.set_response(std::move(val));
  return result;
}
WithErrorSyntax_ResponseAsStruct_Result
WithErrorSyntax_ResponseAsStruct_Result::WithErr(uint32_t&& val) {
  WithErrorSyntax_ResponseAsStruct_Result result;
  result.set_err(std::move(val));
  return result;
}

void WithErrorSyntax_ResponseAsStruct_Result::Encode(
    ::fidl::Encoder* encoder, size_t offset,
    cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
        kResponse: {
      switch (encoder->wire_format()) {
        case ::fidl::internal::WireFormatVersion::kV1: {
          ::fidl::Encode(
              encoder, &response_,
              encoder->Alloc(::fidl::EncodingInlineSize<
                             ::test::protocols::
                                 WithErrorSyntax_ResponseAsStruct_Response,
                             ::fidl::Encoder>(encoder)));

          fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
          xunion->tag = tag_;
          xunion->envelope.num_bytes =
              static_cast<uint32_t>(encoder->CurrentLength() - length_before);
          xunion->envelope.num_handles = static_cast<uint32_t>(
              encoder->CurrentHandleCount() - handles_before);
          xunion->envelope.presence = FIDL_ALLOC_PRESENT;
          break;
        }
        case ::fidl::internal::WireFormatVersion::kV2: {
          if (::fidl::EncodingInlineSize<
                  ::test::protocols::WithErrorSyntax_ResponseAsStruct_Response>(
                  encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
            ::fidl::Encode(encoder, &response_,
                           offset + offsetof(fidl_xunion_v2_t, envelope));

            fidl_xunion_v2_t* xunion =
                encoder->GetPtr<fidl_xunion_v2_t>(offset);
            xunion->tag = tag_;
            xunion->envelope.num_handles = static_cast<uint16_t>(
                encoder->CurrentHandleCount() - handles_before);
            xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
            break;
          }

          ::fidl::Encode(
              encoder, &response_,
              encoder->Alloc(::fidl::EncodingInlineSize<
                             ::test::protocols::
                                 WithErrorSyntax_ResponseAsStruct_Response,
                             ::fidl::Encoder>(encoder)));

          fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
          xunion->tag = tag_;
          xunion->envelope.num_bytes =
              static_cast<uint32_t>(encoder->CurrentLength() - length_before);
          xunion->envelope.num_handles = static_cast<uint16_t>(
              encoder->CurrentHandleCount() - handles_before);
          xunion->envelope.flags = 0;
          break;
        }
      }
      break;
    }
    case ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
        kErr: {
      switch (encoder->wire_format()) {
        case ::fidl::internal::WireFormatVersion::kV1: {
          ::fidl::Encode(
              encoder, &err_,
              encoder->Alloc(
                  ::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(
                      encoder)));

          fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
          xunion->tag = tag_;
          xunion->envelope.num_bytes =
              static_cast<uint32_t>(encoder->CurrentLength() - length_before);
          xunion->envelope.num_handles = static_cast<uint32_t>(
              encoder->CurrentHandleCount() - handles_before);
          xunion->envelope.presence = FIDL_ALLOC_PRESENT;
          break;
        }
        case ::fidl::internal::WireFormatVersion::kV2: {
          if (::fidl::EncodingInlineSize<uint32_t>(encoder) <=
              FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
            ::fidl::Encode(encoder, &err_,
                           offset + offsetof(fidl_xunion_v2_t, envelope));

            fidl_xunion_v2_t* xunion =
                encoder->GetPtr<fidl_xunion_v2_t>(offset);
            xunion->tag = tag_;
            xunion->envelope.num_handles = static_cast<uint16_t>(
                encoder->CurrentHandleCount() - handles_before);
            xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
            break;
          }

          ::fidl::Encode(
              encoder, &err_,
              encoder->Alloc(
                  ::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(
                      encoder)));

          fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
          xunion->tag = tag_;
          xunion->envelope.num_bytes =
              static_cast<uint32_t>(encoder->CurrentLength() - length_before);
          xunion->envelope.num_handles = static_cast<uint16_t>(
              encoder->CurrentHandleCount() - handles_before);
          xunion->envelope.flags = 0;
          break;
        }
      }
      break;
    }
    default:
      break;
  }
}

void WithErrorSyntax_ResponseAsStruct_Result::Decode(
    ::fidl::Decoder* _decoder, WithErrorSyntax_ResponseAsStruct_Result* value,
    size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 && xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(
        ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
            Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);

  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
        kResponse: {
      new (&value->response_)::test::protocols::
          WithErrorSyntax_ResponseAsStruct_Response();
      ::fidl::Decode(_decoder, &value->response_, value_offset);
      break;
    }
    case ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
        kErr: {
      ::fidl::Decode(_decoder, &value->err_, value_offset);
      break;
    }
    default: {
      break;
    }
  }
}

zx_status_t WithErrorSyntax_ResponseAsStruct_Result::Clone(
    WithErrorSyntax_ResponseAsStruct_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
        Invalid:
      return ZX_OK;
    case ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
        kResponse:
      new (&result->response_)::test::protocols::
          WithErrorSyntax_ResponseAsStruct_Response();
      return ::fidl::Clone(response_, &result->response_);
    case ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:
      return ZX_OK;
  }
}

WithErrorSyntax_ResponseAsStruct_Result&
WithErrorSyntax_ResponseAsStruct_Result::set_response(
    ::test::protocols::WithErrorSyntax_ResponseAsStruct_Response value) {
  EnsureStorageInitialized(
      ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
          kResponse);
  response_ = std::move(value);
  return *this;
}

WithErrorSyntax_ResponseAsStruct_Result&
WithErrorSyntax_ResponseAsStruct_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(
      ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void WithErrorSyntax_ResponseAsStruct_Result::Destroy() {
  switch (tag_) {
    case ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
        kResponse:
      response_.~decltype(response_)();
      break;
    case ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::kErr:
      break;

    default:
      break;
  }
  tag_ = static_cast<fidl_xunion_tag_t>(
      ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::Invalid);
}

void WithErrorSyntax_ResponseAsStruct_Result::EnsureStorageInitialized(
    ::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(
          ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
              Invalid):
        break;
      case ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
          kResponse:
        new (&response_)::test::protocols::
            WithErrorSyntax_ResponseAsStruct_Response();
        break;
      case ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
          kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;
const fidl_type_t* WithErrorSyntax_ErrorAsPrimitive_Response::FidlType =
    &test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;

void WithErrorSyntax_ErrorAsPrimitive_Response::Encode(
    ::fidl::Encoder* _encoder, size_t _offset,
    cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<
          WithErrorSyntax_ErrorAsPrimitive_Response>::value) {
    memcpy(_encoder->template GetPtr<WithErrorSyntax_ErrorAsPrimitive_Response>(
               _offset),
           this, sizeof(WithErrorSyntax_ErrorAsPrimitive_Response));
  } else {
    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, &__reserved, _offset + 0);

    } else {
      ::fidl::Encode(_encoder, &__reserved, _offset + 0);
    }
  }
}

void WithErrorSyntax_ErrorAsPrimitive_Response::Decode(
    ::fidl::Decoder* _decoder,
    WithErrorSyntax_ErrorAsPrimitive_Response* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<
          WithErrorSyntax_ErrorAsPrimitive_Response>::value) {
    memcpy(_value,
           _decoder->template GetPtr<WithErrorSyntax_ErrorAsPrimitive_Response>(
               _offset),
           sizeof(WithErrorSyntax_ErrorAsPrimitive_Response));
  } else {
    ::fidl::Decode(_decoder, &_value->__reserved, _offset + 0);
  }
}

zx_status_t WithErrorSyntax_ErrorAsPrimitive_Response::Clone(
    WithErrorSyntax_ErrorAsPrimitive_Response* _result) const {
  zx_status_t _status = ::fidl::Clone(__reserved, &_result->__reserved);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResultTable;
const fidl_type_t* WithErrorSyntax_ErrorAsPrimitive_Result::FidlType =
    &test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResultTable;

WithErrorSyntax_ErrorAsPrimitive_Result::
    WithErrorSyntax_ErrorAsPrimitive_Result() {}

WithErrorSyntax_ErrorAsPrimitive_Result::
    ~WithErrorSyntax_ErrorAsPrimitive_Result() {
  Destroy();
}

WithErrorSyntax_ErrorAsPrimitive_Result::
    WithErrorSyntax_ErrorAsPrimitive_Result(
        WithErrorSyntax_ErrorAsPrimitive_Result&& other)
    : tag_(other.tag_) {
  switch (tag_) {
    case ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
        kResponse:
      new (&response_)::test::protocols::
          WithErrorSyntax_ErrorAsPrimitive_Response();
      response_ = std::move(other.response_);
      break;
    case ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(
        ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
            Invalid):
      break;
  }
}

WithErrorSyntax_ErrorAsPrimitive_Result&
WithErrorSyntax_ErrorAsPrimitive_Result::operator=(
    WithErrorSyntax_ErrorAsPrimitive_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
          kResponse:
        new (&response_)::test::protocols::
            WithErrorSyntax_ErrorAsPrimitive_Response();
        response_ = std::move(other.response_);
        break;
      case ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
          kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(
          ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
              Invalid):
        break;
    }
  }
  return *this;
}

WithErrorSyntax_ErrorAsPrimitive_Result
WithErrorSyntax_ErrorAsPrimitive_Result::WithResponse(
    ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response&& val) {
  WithErrorSyntax_ErrorAsPrimitive_Result result;
  result.set_response(std::move(val));
  return result;
}
WithErrorSyntax_ErrorAsPrimitive_Result
WithErrorSyntax_ErrorAsPrimitive_Result::WithErr(uint32_t&& val) {
  WithErrorSyntax_ErrorAsPrimitive_Result result;
  result.set_err(std::move(val));
  return result;
}

void WithErrorSyntax_ErrorAsPrimitive_Result::Encode(
    ::fidl::Encoder* encoder, size_t offset,
    cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
        kResponse: {
      switch (encoder->wire_format()) {
        case ::fidl::internal::WireFormatVersion::kV1: {
          ::fidl::Encode(
              encoder, &response_,
              encoder->Alloc(::fidl::EncodingInlineSize<
                             ::test::protocols::
                                 WithErrorSyntax_ErrorAsPrimitive_Response,
                             ::fidl::Encoder>(encoder)));

          fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
          xunion->tag = tag_;
          xunion->envelope.num_bytes =
              static_cast<uint32_t>(encoder->CurrentLength() - length_before);
          xunion->envelope.num_handles = static_cast<uint32_t>(
              encoder->CurrentHandleCount() - handles_before);
          xunion->envelope.presence = FIDL_ALLOC_PRESENT;
          break;
        }
        case ::fidl::internal::WireFormatVersion::kV2: {
          if (::fidl::EncodingInlineSize<
                  ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response>(
                  encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
            ::fidl::Encode(encoder, &response_,
                           offset + offsetof(fidl_xunion_v2_t, envelope));

            fidl_xunion_v2_t* xunion =
                encoder->GetPtr<fidl_xunion_v2_t>(offset);
            xunion->tag = tag_;
            xunion->envelope.num_handles = static_cast<uint16_t>(
                encoder->CurrentHandleCount() - handles_before);
            xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
            break;
          }

          ::fidl::Encode(
              encoder, &response_,
              encoder->Alloc(::fidl::EncodingInlineSize<
                             ::test::protocols::
                                 WithErrorSyntax_ErrorAsPrimitive_Response,
                             ::fidl::Encoder>(encoder)));

          fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
          xunion->tag = tag_;
          xunion->envelope.num_bytes =
              static_cast<uint32_t>(encoder->CurrentLength() - length_before);
          xunion->envelope.num_handles = static_cast<uint16_t>(
              encoder->CurrentHandleCount() - handles_before);
          xunion->envelope.flags = 0;
          break;
        }
      }
      break;
    }
    case ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
        kErr: {
      switch (encoder->wire_format()) {
        case ::fidl::internal::WireFormatVersion::kV1: {
          ::fidl::Encode(
              encoder, &err_,
              encoder->Alloc(
                  ::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(
                      encoder)));

          fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
          xunion->tag = tag_;
          xunion->envelope.num_bytes =
              static_cast<uint32_t>(encoder->CurrentLength() - length_before);
          xunion->envelope.num_handles = static_cast<uint32_t>(
              encoder->CurrentHandleCount() - handles_before);
          xunion->envelope.presence = FIDL_ALLOC_PRESENT;
          break;
        }
        case ::fidl::internal::WireFormatVersion::kV2: {
          if (::fidl::EncodingInlineSize<uint32_t>(encoder) <=
              FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
            ::fidl::Encode(encoder, &err_,
                           offset + offsetof(fidl_xunion_v2_t, envelope));

            fidl_xunion_v2_t* xunion =
                encoder->GetPtr<fidl_xunion_v2_t>(offset);
            xunion->tag = tag_;
            xunion->envelope.num_handles = static_cast<uint16_t>(
                encoder->CurrentHandleCount() - handles_before);
            xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
            break;
          }

          ::fidl::Encode(
              encoder, &err_,
              encoder->Alloc(
                  ::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(
                      encoder)));

          fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
          xunion->tag = tag_;
          xunion->envelope.num_bytes =
              static_cast<uint32_t>(encoder->CurrentLength() - length_before);
          xunion->envelope.num_handles = static_cast<uint16_t>(
              encoder->CurrentHandleCount() - handles_before);
          xunion->envelope.flags = 0;
          break;
        }
      }
      break;
    }
    default:
      break;
  }
}

void WithErrorSyntax_ErrorAsPrimitive_Result::Decode(
    ::fidl::Decoder* _decoder, WithErrorSyntax_ErrorAsPrimitive_Result* value,
    size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 && xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(
        ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
            Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);

  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
        kResponse: {
      new (&value->response_)::test::protocols::
          WithErrorSyntax_ErrorAsPrimitive_Response();
      ::fidl::Decode(_decoder, &value->response_, value_offset);
      break;
    }
    case ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
        kErr: {
      ::fidl::Decode(_decoder, &value->err_, value_offset);
      break;
    }
    default: {
      break;
    }
  }
}

zx_status_t WithErrorSyntax_ErrorAsPrimitive_Result::Clone(
    WithErrorSyntax_ErrorAsPrimitive_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
        Invalid:
      return ZX_OK;
    case ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
        kResponse:
      new (&result->response_)::test::protocols::
          WithErrorSyntax_ErrorAsPrimitive_Response();
      return ::fidl::Clone(response_, &result->response_);
    case ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:
      return ZX_OK;
  }
}

WithErrorSyntax_ErrorAsPrimitive_Result&
WithErrorSyntax_ErrorAsPrimitive_Result::set_response(
    ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response value) {
  EnsureStorageInitialized(
      ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
          kResponse);
  response_ = std::move(value);
  return *this;
}

WithErrorSyntax_ErrorAsPrimitive_Result&
WithErrorSyntax_ErrorAsPrimitive_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(
      ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void WithErrorSyntax_ErrorAsPrimitive_Result::Destroy() {
  switch (tag_) {
    case ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
        kResponse:
      response_.~decltype(response_)();
      break;
    case ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::kErr:
      break;

    default:
      break;
  }
  tag_ = static_cast<fidl_xunion_tag_t>(
      ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::Invalid);
}

void WithErrorSyntax_ErrorAsPrimitive_Result::EnsureStorageInitialized(
    ::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(
          ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
              Invalid):
        break;
      case ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
          kResponse:
        new (&response_)::test::protocols::
            WithErrorSyntax_ErrorAsPrimitive_Response();
        break;
      case ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
          kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsEnum_ResponseTable;
const fidl_type_t* WithErrorSyntax_ErrorAsEnum_Response::FidlType =
    &test_protocols_WithErrorSyntax_ErrorAsEnum_ResponseTable;

void WithErrorSyntax_ErrorAsEnum_Response::Encode(
    ::fidl::Encoder* _encoder, size_t _offset,
    cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<WithErrorSyntax_ErrorAsEnum_Response>::value) {
    memcpy(_encoder->template GetPtr<WithErrorSyntax_ErrorAsEnum_Response>(
               _offset),
           this, sizeof(WithErrorSyntax_ErrorAsEnum_Response));
  } else {
    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, &__reserved, _offset + 0);

    } else {
      ::fidl::Encode(_encoder, &__reserved, _offset + 0);
    }
  }
}

void WithErrorSyntax_ErrorAsEnum_Response::Decode(
    ::fidl::Decoder* _decoder, WithErrorSyntax_ErrorAsEnum_Response* _value,
    size_t _offset) {
  if (::fidl::IsMemcpyCompatible<WithErrorSyntax_ErrorAsEnum_Response>::value) {
    memcpy(_value,
           _decoder->template GetPtr<WithErrorSyntax_ErrorAsEnum_Response>(
               _offset),
           sizeof(WithErrorSyntax_ErrorAsEnum_Response));
  } else {
    ::fidl::Decode(_decoder, &_value->__reserved, _offset + 0);
  }
}

zx_status_t WithErrorSyntax_ErrorAsEnum_Response::Clone(
    WithErrorSyntax_ErrorAsEnum_Response* _result) const {
  zx_status_t _status = ::fidl::Clone(__reserved, &_result->__reserved);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_protocols_TheUnionTable;
const fidl_type_t* TheUnion::FidlType = &test_protocols_TheUnionTable;

TheUnion::TheUnion() {}

TheUnion::~TheUnion() { Destroy(); }

TheUnion::TheUnion(TheUnion&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::protocols::TheUnion::Tag::kV:
      v_ = std::move(other.v_);
      break;
    case static_cast<fidl_xunion_tag_t>(
        ::test::protocols::TheUnion::Tag::Invalid):
      break;
    default:
      new (&unknown_data_) decltype(unknown_data_);
      unknown_data_ = std::move(other.unknown_data_);
      break;
  }
}

TheUnion& TheUnion::operator=(TheUnion&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::protocols::TheUnion::Tag::kV:
        v_ = std::move(other.v_);
        break;
      case static_cast<fidl_xunion_tag_t>(
          ::test::protocols::TheUnion::Tag::Invalid):
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        unknown_data_ = std::move(other.unknown_data_);
        break;
    }
  }
  return *this;
}

TheUnion TheUnion::WithV(uint32_t&& val) {
  TheUnion result;
  result.set_v(std::move(val));
  return result;
}

void TheUnion::Encode(
    ::fidl::Encoder* encoder, size_t offset,
    cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::protocols::TheUnion::Tag::kV: {
      switch (encoder->wire_format()) {
        case ::fidl::internal::WireFormatVersion::kV1: {
          ::fidl::Encode(
              encoder, &v_,
              encoder->Alloc(
                  ::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(
                      encoder)));

          fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
          xunion->tag = tag_;
          xunion->envelope.num_bytes =
              static_cast<uint32_t>(encoder->CurrentLength() - length_before);
          xunion->envelope.num_handles = static_cast<uint32_t>(
              encoder->CurrentHandleCount() - handles_before);
          xunion->envelope.presence = FIDL_ALLOC_PRESENT;
          break;
        }
        case ::fidl::internal::WireFormatVersion::kV2: {
          if (::fidl::EncodingInlineSize<uint32_t>(encoder) <=
              FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
            ::fidl::Encode(encoder, &v_,
                           offset + offsetof(fidl_xunion_v2_t, envelope));

            fidl_xunion_v2_t* xunion =
                encoder->GetPtr<fidl_xunion_v2_t>(offset);
            xunion->tag = tag_;
            xunion->envelope.num_handles = static_cast<uint16_t>(
                encoder->CurrentHandleCount() - handles_before);
            xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
            break;
          }

          ::fidl::Encode(
              encoder, &v_,
              encoder->Alloc(
                  ::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(
                      encoder)));

          fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
          xunion->tag = tag_;
          xunion->envelope.num_bytes =
              static_cast<uint32_t>(encoder->CurrentLength() - length_before);
          xunion->envelope.num_handles = static_cast<uint16_t>(
              encoder->CurrentHandleCount() - handles_before);
          xunion->envelope.flags = 0;
          break;
        }
      }
      break;
    }
    case ::test::protocols::TheUnion::Tag::kUnknown: {
      ::fidl::EncodeUnknownBytes(encoder, &unknown_data_,
                                 offset + offsetof(fidl_xunion_t, envelope));
      *encoder->GetPtr<uint64_t>(offset) = tag_;
      break;
    }
    default:
      break;
  }
}

void TheUnion::Decode(::fidl::Decoder* _decoder, TheUnion* value,
                      size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 && xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(
        ::test::protocols::TheUnion::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);

  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::protocols::TheUnion::Tag::kV: {
      ::fidl::Decode(_decoder, &value->v_, value_offset);
      break;
    }
    default: {
      auto unknown_info = _decoder->EnvelopeUnknownDataInfo(&xunion->envelope);
      value->unknown_data_.resize(unknown_info.num_bytes);
      ::fidl::DecodeUnknownBytesContents(_decoder, &value->unknown_data_,
                                         unknown_info.value_offset);
      break;
    }
  }
}

zx_status_t TheUnion::Clone(TheUnion* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::protocols::TheUnion::Tag::Invalid:
      return ZX_OK;
    case ::test::protocols::TheUnion::Tag::kV:
      return ::fidl::Clone(v_, &result->v_);
    default:
      new (&result->unknown_data_) decltype(unknown_data_);
      return ::fidl::Clone(unknown_data_, &result->unknown_data_);
      return ZX_OK;
  }
}

TheUnion& TheUnion::set_v(uint32_t value) {
  EnsureStorageInitialized(::test::protocols::TheUnion::Tag::kV);
  v_ = std::move(value);
  return *this;
}
TheUnion& TheUnion::SetUnknownData(fidl_xunion_tag_t ordinal,
                                   std::vector<uint8_t> bytes) {
  EnsureStorageInitialized(ordinal);
  unknown_data_ = std::move(bytes);
  return *this;
}

void TheUnion::Destroy() {
  switch (tag_) {
    case ::test::protocols::TheUnion::Tag::kV:
      break;

    case static_cast<fidl_xunion_tag_t>(
        ::test::protocols::TheUnion::Tag::Invalid):
      break;
    default:
      unknown_data_.~decltype(unknown_data_)();
      break;
  }
  tag_ =
      static_cast<fidl_xunion_tag_t>(::test::protocols::TheUnion::Tag::Invalid);
}

void TheUnion::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(
          ::test::protocols::TheUnion::Tag::Invalid):
        break;
      case ::test::protocols::TheUnion::Tag::kV:
        new (&v_) uint32_t();
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        break;
    }
  }
}

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_ProtocolEndsTable;
const fidl_type_t* ProtocolEnds::FidlType = &test_protocols_ProtocolEndsTable;

void ProtocolEnds::Encode(
    ::fidl::Encoder* _encoder, size_t _offset,
    cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<ProtocolEnds>::value) {
    memcpy(_encoder->template GetPtr<ProtocolEnds>(_offset), this,
           sizeof(ProtocolEnds));
  } else {
    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, &client, _offset + 0,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });

      ::fidl::Encode(_encoder, &server, _offset + 4,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });

      ::fidl::Encode(_encoder, &client_opt, _offset + 8,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });

      ::fidl::Encode(_encoder, &server_opt, _offset + 12,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });

    } else {
      ::fidl::Encode(_encoder, &client, _offset + 0,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });

      ::fidl::Encode(_encoder, &server, _offset + 4,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });

      ::fidl::Encode(_encoder, &client_opt, _offset + 8,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });

      ::fidl::Encode(_encoder, &server_opt, _offset + 12,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });
    }
  }
}

void ProtocolEnds::Decode(::fidl::Decoder* _decoder, ProtocolEnds* _value,
                          size_t _offset) {
  if (::fidl::IsMemcpyCompatible<ProtocolEnds>::value) {
    memcpy(_value, _decoder->template GetPtr<ProtocolEnds>(_offset),
           sizeof(ProtocolEnds));
  } else {
    ::fidl::Decode(_decoder, &_value->client, _offset + 0);
    ::fidl::Decode(_decoder, &_value->server, _offset + 4);
    ::fidl::Decode(_decoder, &_value->client_opt, _offset + 8);
    ::fidl::Decode(_decoder, &_value->server_opt, _offset + 12);
  }
}

zx_status_t ProtocolEnds::Clone(ProtocolEnds* _result) const {
  zx_status_t _status = ::fidl::Clone(client, &_result->client);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(server, &_result->server);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(client_opt, &_result->client_opt);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(server_opt, &_result->server_opt);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
#endif  // __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsEnum_ResultTable;
const fidl_type_t* WithErrorSyntax_ErrorAsEnum_Result::FidlType =
    &test_protocols_WithErrorSyntax_ErrorAsEnum_ResultTable;

WithErrorSyntax_ErrorAsEnum_Result::WithErrorSyntax_ErrorAsEnum_Result() {}

WithErrorSyntax_ErrorAsEnum_Result::~WithErrorSyntax_ErrorAsEnum_Result() {
  Destroy();
}

WithErrorSyntax_ErrorAsEnum_Result::WithErrorSyntax_ErrorAsEnum_Result(
    WithErrorSyntax_ErrorAsEnum_Result&& other)
    : tag_(other.tag_) {
  switch (tag_) {
    case ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kResponse:
      new (&response_)::test::protocols::WithErrorSyntax_ErrorAsEnum_Response();
      response_ = std::move(other.response_);
      break;
    case ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr:
      new (&err_)::test::protocols::ErrorEnum();
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(
        ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::Invalid):
      break;
  }
}

WithErrorSyntax_ErrorAsEnum_Result&
WithErrorSyntax_ErrorAsEnum_Result::operator=(
    WithErrorSyntax_ErrorAsEnum_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::
          kResponse:
        new (&response_)::test::protocols::
            WithErrorSyntax_ErrorAsEnum_Response();
        response_ = std::move(other.response_);
        break;
      case ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr:
        new (&err_)::test::protocols::ErrorEnum();
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(
          ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::Invalid):
        break;
    }
  }
  return *this;
}

WithErrorSyntax_ErrorAsEnum_Result
WithErrorSyntax_ErrorAsEnum_Result::WithResponse(
    ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response&& val) {
  WithErrorSyntax_ErrorAsEnum_Result result;
  result.set_response(std::move(val));
  return result;
}
WithErrorSyntax_ErrorAsEnum_Result WithErrorSyntax_ErrorAsEnum_Result::WithErr(
    ::test::protocols::ErrorEnum&& val) {
  WithErrorSyntax_ErrorAsEnum_Result result;
  result.set_err(std::move(val));
  return result;
}

void WithErrorSyntax_ErrorAsEnum_Result::Encode(
    ::fidl::Encoder* encoder, size_t offset,
    cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::
        kResponse: {
      switch (encoder->wire_format()) {
        case ::fidl::internal::WireFormatVersion::kV1: {
          ::fidl::Encode(
              encoder, &response_,
              encoder->Alloc(
                  ::fidl::EncodingInlineSize<
                      ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response,
                      ::fidl::Encoder>(encoder)));

          fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
          xunion->tag = tag_;
          xunion->envelope.num_bytes =
              static_cast<uint32_t>(encoder->CurrentLength() - length_before);
          xunion->envelope.num_handles = static_cast<uint32_t>(
              encoder->CurrentHandleCount() - handles_before);
          xunion->envelope.presence = FIDL_ALLOC_PRESENT;
          break;
        }
        case ::fidl::internal::WireFormatVersion::kV2: {
          if (::fidl::EncodingInlineSize<
                  ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response>(
                  encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
            ::fidl::Encode(encoder, &response_,
                           offset + offsetof(fidl_xunion_v2_t, envelope));

            fidl_xunion_v2_t* xunion =
                encoder->GetPtr<fidl_xunion_v2_t>(offset);
            xunion->tag = tag_;
            xunion->envelope.num_handles = static_cast<uint16_t>(
                encoder->CurrentHandleCount() - handles_before);
            xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
            break;
          }

          ::fidl::Encode(
              encoder, &response_,
              encoder->Alloc(
                  ::fidl::EncodingInlineSize<
                      ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response,
                      ::fidl::Encoder>(encoder)));

          fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
          xunion->tag = tag_;
          xunion->envelope.num_bytes =
              static_cast<uint32_t>(encoder->CurrentLength() - length_before);
          xunion->envelope.num_handles = static_cast<uint16_t>(
              encoder->CurrentHandleCount() - handles_before);
          xunion->envelope.flags = 0;
          break;
        }
      }
      break;
    }
    case ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr: {
      switch (encoder->wire_format()) {
        case ::fidl::internal::WireFormatVersion::kV1: {
          ::fidl::Encode(
              encoder, &err_,
              encoder->Alloc(
                  ::fidl::EncodingInlineSize<::test::protocols::ErrorEnum,
                                             ::fidl::Encoder>(encoder)));

          fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
          xunion->tag = tag_;
          xunion->envelope.num_bytes =
              static_cast<uint32_t>(encoder->CurrentLength() - length_before);
          xunion->envelope.num_handles = static_cast<uint32_t>(
              encoder->CurrentHandleCount() - handles_before);
          xunion->envelope.presence = FIDL_ALLOC_PRESENT;
          break;
        }
        case ::fidl::internal::WireFormatVersion::kV2: {
          if (::fidl::EncodingInlineSize<::test::protocols::ErrorEnum>(
                  encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
            ::fidl::Encode(encoder, &err_,
                           offset + offsetof(fidl_xunion_v2_t, envelope));

            fidl_xunion_v2_t* xunion =
                encoder->GetPtr<fidl_xunion_v2_t>(offset);
            xunion->tag = tag_;
            xunion->envelope.num_handles = static_cast<uint16_t>(
                encoder->CurrentHandleCount() - handles_before);
            xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
            break;
          }

          ::fidl::Encode(
              encoder, &err_,
              encoder->Alloc(
                  ::fidl::EncodingInlineSize<::test::protocols::ErrorEnum,
                                             ::fidl::Encoder>(encoder)));

          fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
          xunion->tag = tag_;
          xunion->envelope.num_bytes =
              static_cast<uint32_t>(encoder->CurrentLength() - length_before);
          xunion->envelope.num_handles = static_cast<uint16_t>(
              encoder->CurrentHandleCount() - handles_before);
          xunion->envelope.flags = 0;
          break;
        }
      }
      break;
    }
    default:
      break;
  }
}

void WithErrorSyntax_ErrorAsEnum_Result::Decode(
    ::fidl::Decoder* _decoder, WithErrorSyntax_ErrorAsEnum_Result* value,
    size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 && xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(
        ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);

  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::
        kResponse: {
      new (&value->response_)::test::protocols::
          WithErrorSyntax_ErrorAsEnum_Response();
      ::fidl::Decode(_decoder, &value->response_, value_offset);
      break;
    }
    case ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr: {
      new (&value->err_)::test::protocols::ErrorEnum();
      ::fidl::Decode(_decoder, &value->err_, value_offset);
      break;
    }
    default: {
      break;
    }
  }
}

zx_status_t WithErrorSyntax_ErrorAsEnum_Result::Clone(
    WithErrorSyntax_ErrorAsEnum_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::Invalid:
      return ZX_OK;
    case ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kResponse:
      new (&result->response_)::test::protocols::
          WithErrorSyntax_ErrorAsEnum_Response();
      return ::fidl::Clone(response_, &result->response_);
    case ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr:
      new (&result->err_)::test::protocols::ErrorEnum();
      return ::fidl::Clone(err_, &result->err_);
    default:
      return ZX_OK;
  }
}

WithErrorSyntax_ErrorAsEnum_Result&
WithErrorSyntax_ErrorAsEnum_Result::set_response(
    ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response value) {
  EnsureStorageInitialized(
      ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

WithErrorSyntax_ErrorAsEnum_Result& WithErrorSyntax_ErrorAsEnum_Result::set_err(
    ::test::protocols::ErrorEnum value) {
  EnsureStorageInitialized(
      ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void WithErrorSyntax_ErrorAsEnum_Result::Destroy() {
  switch (tag_) {
    case ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kResponse:
      response_.~decltype(response_)();
      break;
    case ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr:
      err_.~decltype(err_)();
      break;

    default:
      break;
  }
  tag_ = static_cast<fidl_xunion_tag_t>(
      ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::Invalid);
}

void WithErrorSyntax_ErrorAsEnum_Result::EnsureStorageInitialized(
    ::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(
          ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::Invalid):
        break;
      case ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::
          kResponse:
        new (&response_)::test::protocols::
            WithErrorSyntax_ErrorAsEnum_Response();
        break;
      case ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr:
        new (&err_)::test::protocols::ErrorEnum();
        break;
      default:
        break;
    }
  }
}

//
// Proxies and stubs definitions
//
#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolAnEventRequestTable;

}  // namespace _internal
HandleRightsProtocol::~HandleRightsProtocol() = default;

const fidl_type_t* ::test::protocols::HandleRightsProtocol_RequestDecoder::
    GetType(uint64_t ordinal, bool* out_needs_response) {
  *out_needs_response = false;
  switch (ordinal) {
    case ::test::protocols::internal::
        kHandleRightsProtocol_NoResponseMethod_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;
      ;
    case ::test::protocols::internal::
        kHandleRightsProtocol_ResponseMethod_Ordinal:
      *out_needs_response = true;
      return &::test::protocols::_internal::
          test_protocols_HandleRightsProtocolResponseMethodRequestTable;
      ;
    default:
      return nullptr;
  }
}

const fidl_type_t* HandleRightsProtocol_ResponseDecoder::GetType(
    uint64_t ordinal) {
  switch (ordinal) {
    case ::test::protocols::internal::
        kHandleRightsProtocol_ResponseMethod_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;
      ;
    case ::test::protocols::internal::kHandleRightsProtocol_AnEvent_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_HandleRightsProtocolAnEventRequestTable;
      ;
    default:
      return nullptr;
  }
}

HandleRightsProtocol_EventSender::~HandleRightsProtocol_EventSender() = default;

HandleRightsProtocol_Sync::~HandleRightsProtocol_Sync() = default;

HandleRightsProtocol_Proxy::HandleRightsProtocol_Proxy(
    ::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

HandleRightsProtocol_Proxy::~HandleRightsProtocol_Proxy() = default;

zx_status_t HandleRightsProtocol_Proxy::Dispatch_(
    ::fidl::HLCPPIncomingMessage message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    case ::test::protocols::internal::kHandleRightsProtocol_AnEvent_Ordinal: {
      if (!AnEvent) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(
          &::test::protocols::_internal::
              test_protocols_HandleRightsProtocolAnEventRequestTable,
          &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(
            message,
            &::test::protocols::_internal::
                test_protocols_HandleRightsProtocolAnEventRequestTable,
            error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      AnEvent(::fidl::DecodeAs<::zx::socket>(
          &decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}

void HandleRightsProtocol_Proxy::NoResponseMethod(::zx::socket h) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kHandleRightsProtocol_NoResponseMethod_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;
  controller_->Send(
      req_type,
      ::test::protocols::HandleRightsProtocol_RequestEncoder::NoResponseMethod(
          &_encoder, &h),
      nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
HandleRightsProtocol_ResponseMethod_ResponseHandler(
    HandleRightsProtocol::ResponseMethodCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback,
      "Callback must not be empty for HandleRightsProtocol::ResponseMethod\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ =
           std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::zx::socket>(
            &decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      },
      &::test::protocols::_internal::
          test_protocols_HandleRightsProtocolResponseMethodTopResponseTable);
}

}  // namespace
void HandleRightsProtocol_Proxy::ResponseMethod(
    ::zx::socket h, ResponseMethodCallback callback) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kHandleRightsProtocol_ResponseMethod_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_HandleRightsProtocolResponseMethodRequestTable;
  controller_->Send(
      req_type,
      ::test::protocols::HandleRightsProtocol_RequestEncoder::ResponseMethod(
          &_encoder, &h),
      HandleRightsProtocol_ResponseMethod_ResponseHandler(std::move(callback)));
}

HandleRightsProtocol_Stub::HandleRightsProtocol_Stub(
    ::test::protocols::HandleRightsProtocol_Stub::HandleRightsProtocol_clazz*
        impl)
    : impl_(impl) {
  (void)impl_;
}

HandleRightsProtocol_Stub::~HandleRightsProtocol_Stub() = default;

namespace {

class HandleRightsProtocol_ResponseMethod_Responder final {
 public:
  HandleRightsProtocol_ResponseMethod_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::zx::socket h) {
    ::fidl::MessageEncoder _encoder(
        ::test::protocols::internal::
            kHandleRightsProtocol_ResponseMethod_Ordinal);
    const fidl_type_t* resp_type =
        &::test::protocols::_internal::
            test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;
    response_.Send(
        resp_type,
        ::test::protocols::HandleRightsProtocol_ResponseEncoder::ResponseMethod(
            &_encoder, &h));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

}  // namespace

zx_status_t HandleRightsProtocol_Stub::Dispatch_(
    ::fidl::HLCPPIncomingMessage message,
    ::fidl::internal::PendingResponse response) {
  bool needs_response;
  const fidl_type_t* request_type =
      ::test::protocols::HandleRightsProtocol_RequestDecoder::GetType(
          message.ordinal(), &needs_response);
  if (!message.has_only_header()) {
    if (request_type == nullptr) {
      return ZX_ERR_NOT_SUPPORTED;
    }
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(request_type, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, request_type, error_msg);
      return status;
    }
  }

  if (response.needs_response() != needs_response) {
    if (needs_response) {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message needing a response with no txid");
    } else {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message not needing a response with a txid");
    }
    return ZX_ERR_INVALID_ARGS;
  }

  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case ::test::protocols::internal::
        kHandleRightsProtocol_NoResponseMethod_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->NoResponseMethod(::fidl::DecodeAs<::zx::socket>(
          &decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::protocols::internal::
        kHandleRightsProtocol_ResponseMethod_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->ResponseMethod(
          ::fidl::DecodeAs<::zx::socket>(&decoder,
                                         0 + sizeof(fidl_message_header_t)),
          HandleRightsProtocol_ResponseMethod_Responder(std::move(response)));
      break;
    }
    default: {
      return ZX_ERR_NOT_SUPPORTED;
    }
  }
  return ZX_OK;
}
void HandleRightsProtocol_Stub::AnEvent(::zx::socket h) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kHandleRightsProtocol_AnEvent_Ordinal);
  const fidl_type_t* resp_type =
      &::test::protocols::_internal::
          test_protocols_HandleRightsProtocolAnEventRequestTable;
  sender_()->Send(
      resp_type,
      ::test::protocols::HandleRightsProtocol_ResponseEncoder::AnEvent(
          &_encoder, &h));
}

HandleRightsProtocol_SyncProxy::HandleRightsProtocol_SyncProxy(
    ::zx::channel channel)
    : proxy_(::std::move(channel)) {}

HandleRightsProtocol_SyncProxy::~HandleRightsProtocol_SyncProxy() = default;

zx_status_t HandleRightsProtocol_SyncProxy::NoResponseMethod(::zx::socket h) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kHandleRightsProtocol_NoResponseMethod_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;
  return proxy_.Send(
      req_type,
      ::test::protocols::HandleRightsProtocol_RequestEncoder::NoResponseMethod(
          &_encoder, &h));
}

zx_status_t HandleRightsProtocol_SyncProxy::ResponseMethod(
    ::zx::socket h, ::zx::socket* out_h) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kHandleRightsProtocol_ResponseMethod_Ordinal);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_HandleRightsProtocolResponseMethodRequestTable;
  const fidl_type_t* resp_type =
      &::test::protocols::_internal::
          test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;
  zx_status_t status_ = proxy_.Call(
      req_type, resp_type,
      ::test::protocols::HandleRightsProtocol_RequestEncoder::ResponseMethod(
          &_encoder, &h),
      &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_h = ::fidl::DecodeAs<::zx::socket>(&decoder_,
                                          0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;

}  // namespace _internal
WithAndWithoutRequestResponse::~WithAndWithoutRequestResponse() = default;

const fidl_type_t* ::test::protocols::
    WithAndWithoutRequestResponse_RequestDecoder::GetType(
        uint64_t ordinal, bool* out_needs_response) {
  *out_needs_response = false;
  switch (ordinal) {
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal:
      return nullptr;
      ;
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal:
      *out_needs_response = true;
      return nullptr;
      ;
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal:
      *out_needs_response = true;
      return nullptr;
      ;
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
      ;
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal:
      *out_needs_response = true;
      return &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
      ;
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal:
      *out_needs_response = true;
      return &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
      ;
    default:
      return nullptr;
  }
}

const fidl_type_t* WithAndWithoutRequestResponse_ResponseDecoder::GetType(
    uint64_t ordinal) {
  switch (ordinal) {
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal:
      return nullptr;
      ;
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;
      ;
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal:
      return nullptr;
      ;
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;
      ;
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal:
      return nullptr;
      ;
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_OnWithResponse_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;
      ;
    default:
      return nullptr;
  }
}

WithAndWithoutRequestResponse_EventSender::
    ~WithAndWithoutRequestResponse_EventSender() = default;

WithAndWithoutRequestResponse_Sync::~WithAndWithoutRequestResponse_Sync() =
    default;

WithAndWithoutRequestResponse_Proxy::WithAndWithoutRequestResponse_Proxy(
    ::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

WithAndWithoutRequestResponse_Proxy::~WithAndWithoutRequestResponse_Proxy() =
    default;

zx_status_t WithAndWithoutRequestResponse_Proxy::Dispatch_(
    ::fidl::HLCPPIncomingMessage message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal: {
      if (!OnEmptyResponse) {
        status = ZX_OK;
        break;
      }
      OnEmptyResponse();
      break;
    }
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_OnWithResponse_Ordinal: {
      if (!OnWithResponse) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(
          &::test::protocols::_internal::
              test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable,
          &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(
            message,
            &::test::protocols::_internal::
                test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable,
            error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      OnWithResponse(::fidl::DecodeAs<::std::string>(
          &decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}

void WithAndWithoutRequestResponse_Proxy::NoRequestNoResponse() {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal);
  const fidl_type_t* req_type = nullptr;
  controller_->Send(
      req_type,
      ::test::protocols::WithAndWithoutRequestResponse_RequestEncoder::
          NoRequestNoResponse(&_encoder),
      nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
WithAndWithoutRequestResponse_NoRequestEmptyResponse_ResponseHandler(
    WithAndWithoutRequestResponse::NoRequestEmptyResponseCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback,
      "Callback must not be empty for "
      "WithAndWithoutRequestResponse::NoRequestEmptyResponse\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ =
           std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        callback_();
        return ZX_OK;
      },
      nullptr);
}

}  // namespace
void WithAndWithoutRequestResponse_Proxy::NoRequestEmptyResponse(
    NoRequestEmptyResponseCallback callback) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal);
  const fidl_type_t* req_type = nullptr;
  controller_->Send(
      req_type,
      ::test::protocols::WithAndWithoutRequestResponse_RequestEncoder::
          NoRequestEmptyResponse(&_encoder),
      WithAndWithoutRequestResponse_NoRequestEmptyResponse_ResponseHandler(
          std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
WithAndWithoutRequestResponse_NoRequestWithResponse_ResponseHandler(
    WithAndWithoutRequestResponse::NoRequestWithResponseCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for "
                      "WithAndWithoutRequestResponse::NoRequestWithResponse\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ =
           std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::std::string>(
            &decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      },
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable);
}

}  // namespace
void WithAndWithoutRequestResponse_Proxy::NoRequestWithResponse(
    NoRequestWithResponseCallback callback) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal);
  const fidl_type_t* req_type = nullptr;
  controller_->Send(
      req_type,
      ::test::protocols::WithAndWithoutRequestResponse_RequestEncoder::
          NoRequestWithResponse(&_encoder),
      WithAndWithoutRequestResponse_NoRequestWithResponse_ResponseHandler(
          std::move(callback)));
}
void WithAndWithoutRequestResponse_Proxy::WithRequestNoResponse(
    ::std::string arg) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
  controller_->Send(
      req_type,
      ::test::protocols::WithAndWithoutRequestResponse_RequestEncoder::
          WithRequestNoResponse(&_encoder, &arg),
      nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
WithAndWithoutRequestResponse_WithRequestEmptyResponse_ResponseHandler(
    WithAndWithoutRequestResponse::WithRequestEmptyResponseCallback&&
        callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback,
      "Callback must not be empty for "
      "WithAndWithoutRequestResponse::WithRequestEmptyResponse\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ =
           std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        callback_();
        return ZX_OK;
      },
      nullptr);
}

}  // namespace
void WithAndWithoutRequestResponse_Proxy::WithRequestEmptyResponse(
    ::std::string arg, WithRequestEmptyResponseCallback callback) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
  controller_->Send(
      req_type,
      ::test::protocols::WithAndWithoutRequestResponse_RequestEncoder::
          WithRequestEmptyResponse(&_encoder, &arg),
      WithAndWithoutRequestResponse_WithRequestEmptyResponse_ResponseHandler(
          std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
WithAndWithoutRequestResponse_WithRequestWithResponse_ResponseHandler(
    WithAndWithoutRequestResponse::WithRequestWithResponseCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback,
      "Callback must not be empty for "
      "WithAndWithoutRequestResponse::WithRequestWithResponse\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ =
           std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::std::string>(
            &decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      },
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable);
}

}  // namespace
void WithAndWithoutRequestResponse_Proxy::WithRequestWithResponse(
    ::std::string arg, WithRequestWithResponseCallback callback) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
  controller_->Send(
      req_type,
      ::test::protocols::WithAndWithoutRequestResponse_RequestEncoder::
          WithRequestWithResponse(&_encoder, &arg),
      WithAndWithoutRequestResponse_WithRequestWithResponse_ResponseHandler(
          std::move(callback)));
}

WithAndWithoutRequestResponse_Stub::WithAndWithoutRequestResponse_Stub(
    ::test::protocols::WithAndWithoutRequestResponse_Stub::
        WithAndWithoutRequestResponse_clazz* impl)
    : impl_(impl) {
  (void)impl_;
}

WithAndWithoutRequestResponse_Stub::~WithAndWithoutRequestResponse_Stub() =
    default;

namespace {

class WithAndWithoutRequestResponse_NoRequestEmptyResponse_Responder final {
 public:
  WithAndWithoutRequestResponse_NoRequestEmptyResponse_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()() {
    ::fidl::MessageEncoder _encoder(
        ::test::protocols::internal::
            kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal);
    const fidl_type_t* resp_type = nullptr;
    response_.Send(
        resp_type,
        ::test::protocols::WithAndWithoutRequestResponse_ResponseEncoder::
            NoRequestEmptyResponse(&_encoder));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class WithAndWithoutRequestResponse_NoRequestWithResponse_Responder final {
 public:
  WithAndWithoutRequestResponse_NoRequestWithResponse_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::std::string ret) {
    ::fidl::MessageEncoder _encoder(
        ::test::protocols::internal::
            kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal);
    const fidl_type_t* resp_type =
        &::test::protocols::_internal::
            test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;
    response_.Send(
        resp_type,
        ::test::protocols::WithAndWithoutRequestResponse_ResponseEncoder::
            NoRequestWithResponse(&_encoder, &ret));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class WithAndWithoutRequestResponse_WithRequestEmptyResponse_Responder final {
 public:
  WithAndWithoutRequestResponse_WithRequestEmptyResponse_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()() {
    ::fidl::MessageEncoder _encoder(
        ::test::protocols::internal::
            kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal);
    const fidl_type_t* resp_type = nullptr;
    response_.Send(
        resp_type,
        ::test::protocols::WithAndWithoutRequestResponse_ResponseEncoder::
            WithRequestEmptyResponse(&_encoder));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class WithAndWithoutRequestResponse_WithRequestWithResponse_Responder final {
 public:
  WithAndWithoutRequestResponse_WithRequestWithResponse_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::std::string ret) {
    ::fidl::MessageEncoder _encoder(
        ::test::protocols::internal::
            kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal);
    const fidl_type_t* resp_type =
        &::test::protocols::_internal::
            test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;
    response_.Send(
        resp_type,
        ::test::protocols::WithAndWithoutRequestResponse_ResponseEncoder::
            WithRequestWithResponse(&_encoder, &ret));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

}  // namespace

zx_status_t WithAndWithoutRequestResponse_Stub::Dispatch_(
    ::fidl::HLCPPIncomingMessage message,
    ::fidl::internal::PendingResponse response) {
  bool needs_response;
  const fidl_type_t* request_type =
      ::test::protocols::WithAndWithoutRequestResponse_RequestDecoder::GetType(
          message.ordinal(), &needs_response);
  if (!message.has_only_header()) {
    if (request_type == nullptr) {
      return ZX_ERR_NOT_SUPPORTED;
    }
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(request_type, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, request_type, error_msg);
      return status;
    }
  }

  if (response.needs_response() != needs_response) {
    if (needs_response) {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message needing a response with no txid");
    } else {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message not needing a response with a txid");
    }
    return ZX_ERR_INVALID_ARGS;
  }

  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal: {
      impl_->NoRequestNoResponse();
      break;
    }
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal: {
      impl_->NoRequestEmptyResponse(
          WithAndWithoutRequestResponse_NoRequestEmptyResponse_Responder(
              std::move(response)));
      break;
    }
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal: {
      impl_->NoRequestWithResponse(
          WithAndWithoutRequestResponse_NoRequestWithResponse_Responder(
              std::move(response)));
      break;
    }
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->WithRequestNoResponse(::fidl::DecodeAs<::std::string>(
          &decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->WithRequestEmptyResponse(
          ::fidl::DecodeAs<::std::string>(&decoder,
                                          0 + sizeof(fidl_message_header_t)),
          WithAndWithoutRequestResponse_WithRequestEmptyResponse_Responder(
              std::move(response)));
      break;
    }
    case ::test::protocols::internal::
        kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->WithRequestWithResponse(
          ::fidl::DecodeAs<::std::string>(&decoder,
                                          0 + sizeof(fidl_message_header_t)),
          WithAndWithoutRequestResponse_WithRequestWithResponse_Responder(
              std::move(response)));
      break;
    }
    default: {
      return ZX_ERR_NOT_SUPPORTED;
    }
  }
  return ZX_OK;
}
void WithAndWithoutRequestResponse_Stub::OnEmptyResponse() {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal);
  const fidl_type_t* resp_type = nullptr;
  sender_()->Send(
      resp_type,
      ::test::protocols::WithAndWithoutRequestResponse_ResponseEncoder::
          OnEmptyResponse(&_encoder));
}
void WithAndWithoutRequestResponse_Stub::OnWithResponse(::std::string ret) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kWithAndWithoutRequestResponse_OnWithResponse_Ordinal);
  const fidl_type_t* resp_type =
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;
  sender_()->Send(
      resp_type,
      ::test::protocols::WithAndWithoutRequestResponse_ResponseEncoder::
          OnWithResponse(&_encoder, &ret));
}

WithAndWithoutRequestResponse_SyncProxy::
    WithAndWithoutRequestResponse_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

WithAndWithoutRequestResponse_SyncProxy::
    ~WithAndWithoutRequestResponse_SyncProxy() = default;

zx_status_t WithAndWithoutRequestResponse_SyncProxy::NoRequestNoResponse() {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal);
  const fidl_type_t* req_type = nullptr;
  return proxy_.Send(
      req_type,
      ::test::protocols::WithAndWithoutRequestResponse_RequestEncoder::
          NoRequestNoResponse(&_encoder));
}

zx_status_t WithAndWithoutRequestResponse_SyncProxy::NoRequestEmptyResponse() {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type = nullptr;
  const fidl_type_t* resp_type = nullptr;
  zx_status_t status_ = proxy_.Call(
      req_type, resp_type,
      ::test::protocols::WithAndWithoutRequestResponse_RequestEncoder::
          NoRequestEmptyResponse(&_encoder),
      &response_);
  if (status_ != ZX_OK) return status_;
  return ZX_OK;
}

zx_status_t WithAndWithoutRequestResponse_SyncProxy::NoRequestWithResponse(
    ::std::string* out_ret) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type = nullptr;
  const fidl_type_t* resp_type =
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;
  zx_status_t status_ = proxy_.Call(
      req_type, resp_type,
      ::test::protocols::WithAndWithoutRequestResponse_RequestEncoder::
          NoRequestWithResponse(&_encoder),
      &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_ret = ::fidl::DecodeAs<::std::string>(&decoder_,
                                             0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t WithAndWithoutRequestResponse_SyncProxy::WithRequestNoResponse(
    ::std::string arg) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
  return proxy_.Send(
      req_type,
      ::test::protocols::WithAndWithoutRequestResponse_RequestEncoder::
          WithRequestNoResponse(&_encoder, &arg));
}

zx_status_t WithAndWithoutRequestResponse_SyncProxy::WithRequestEmptyResponse(
    ::std::string arg) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
  const fidl_type_t* resp_type = nullptr;
  zx_status_t status_ = proxy_.Call(
      req_type, resp_type,
      ::test::protocols::WithAndWithoutRequestResponse_RequestEncoder::
          WithRequestEmptyResponse(&_encoder, &arg),
      &response_);
  if (status_ != ZX_OK) return status_;
  return ZX_OK;
}

zx_status_t WithAndWithoutRequestResponse_SyncProxy::WithRequestWithResponse(
    ::std::string arg, ::std::string* out_ret) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
  const fidl_type_t* resp_type =
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;
  zx_status_t status_ = proxy_.Call(
      req_type, resp_type,
      ::test::protocols::WithAndWithoutRequestResponse_RequestEncoder::
          WithRequestWithResponse(&_encoder, &arg),
      &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_ret = ::fidl::DecodeAs<::std::string>(&decoder_,
                                             0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalRequestRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalRequestTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalOneWayRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalEventRequestTable;

}  // namespace _internal
Transitional::~Transitional() = default;

const fidl_type_t* ::test::protocols::Transitional_RequestDecoder::GetType(
    uint64_t ordinal, bool* out_needs_response) {
  *out_needs_response = false;
  switch (ordinal) {
    case ::test::protocols::internal::kTransitional_Request_Ordinal:
      *out_needs_response = true;
      return &::test::protocols::_internal::
          test_protocols_TransitionalRequestRequestTable;
      ;
    case ::test::protocols::internal::kTransitional_OneWay_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_TransitionalOneWayRequestTable;
      ;
    default:
      return nullptr;
  }
}

const fidl_type_t* Transitional_ResponseDecoder::GetType(uint64_t ordinal) {
  switch (ordinal) {
    case ::test::protocols::internal::kTransitional_Request_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_TransitionalRequestTopResponseTable;
      ;
    case ::test::protocols::internal::kTransitional_Event_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_TransitionalEventRequestTable;
      ;
    default:
      return nullptr;
  }
}

Transitional_EventSender::~Transitional_EventSender() = default;

Transitional_Sync::~Transitional_Sync() = default;

Transitional_Proxy::Transitional_Proxy(
    ::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

Transitional_Proxy::~Transitional_Proxy() = default;

zx_status_t Transitional_Proxy::Dispatch_(
    ::fidl::HLCPPIncomingMessage message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    case ::test::protocols::internal::kTransitional_Event_Ordinal: {
      if (!Event) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::protocols::_internal::
                                  test_protocols_TransitionalEventRequestTable,
                              &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(
            message,
            &::test::protocols::_internal::
                test_protocols_TransitionalEventRequestTable,
            error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      Event(::fidl::DecodeAs<int64_t>(&decoder,
                                      0 + sizeof(fidl_message_header_t)));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}

namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Transitional_Request_ResponseHandler(Transitional::RequestCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Transitional::Request\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ =
           std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<int64_t>(&decoder,
                                            0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      },
      &::test::protocols::_internal::
          test_protocols_TransitionalRequestTopResponseTable);
}

}  // namespace
void Transitional_Proxy::Request(int64_t x, RequestCallback callback) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kTransitional_Request_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_TransitionalRequestRequestTable;
  controller_->Send(
      req_type,
      ::test::protocols::Transitional_RequestEncoder::Request(&_encoder, &x),
      Transitional_Request_ResponseHandler(std::move(callback)));
}
void Transitional_Proxy::OneWay(int64_t x) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kTransitional_OneWay_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_TransitionalOneWayRequestTable;
  controller_->Send(
      req_type,
      ::test::protocols::Transitional_RequestEncoder::OneWay(&_encoder, &x),
      nullptr);
}

Transitional_Stub::Transitional_Stub(
    ::test::protocols::Transitional_Stub::Transitional_clazz* impl)
    : impl_(impl) {
  (void)impl_;
}

Transitional_Stub::~Transitional_Stub() = default;

namespace {

class Transitional_Request_Responder final {
 public:
  Transitional_Request_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(int64_t y) {
    ::fidl::MessageEncoder _encoder(
        ::test::protocols::internal::kTransitional_Request_Ordinal);
    const fidl_type_t* resp_type =
        &::test::protocols::_internal::
            test_protocols_TransitionalRequestTopResponseTable;
    response_.Send(resp_type,
                   ::test::protocols::Transitional_ResponseEncoder::Request(
                       &_encoder, &y));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

}  // namespace

zx_status_t Transitional_Stub::Dispatch_(
    ::fidl::HLCPPIncomingMessage message,
    ::fidl::internal::PendingResponse response) {
  bool needs_response;
  const fidl_type_t* request_type =
      ::test::protocols::Transitional_RequestDecoder::GetType(message.ordinal(),
                                                              &needs_response);
  if (!message.has_only_header()) {
    if (request_type == nullptr) {
      return ZX_ERR_NOT_SUPPORTED;
    }
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(request_type, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, request_type, error_msg);
      return status;
    }
  }

  if (response.needs_response() != needs_response) {
    if (needs_response) {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message needing a response with no txid");
    } else {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message not needing a response with a txid");
    }
    return ZX_ERR_INVALID_ARGS;
  }

  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case ::test::protocols::internal::kTransitional_Request_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->Request(::fidl::DecodeAs<int64_t>(
                         &decoder, 0 + sizeof(fidl_message_header_t)),
                     Transitional_Request_Responder(std::move(response)));
      break;
    }
    case ::test::protocols::internal::kTransitional_OneWay_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->OneWay(::fidl::DecodeAs<int64_t>(
          &decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    default: {
      return ZX_ERR_NOT_SUPPORTED;
    }
  }
  return ZX_OK;
}
void Transitional_Stub::Event(int64_t x) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kTransitional_Event_Ordinal);
  const fidl_type_t* resp_type =
      &::test::protocols::_internal::
          test_protocols_TransitionalEventRequestTable;
  sender_()->Send(
      resp_type,
      ::test::protocols::Transitional_ResponseEncoder::Event(&_encoder, &x));
}

Transitional_SyncProxy::Transitional_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

Transitional_SyncProxy::~Transitional_SyncProxy() = default;

zx_status_t Transitional_SyncProxy::Request(int64_t x, int64_t* out_y) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kTransitional_Request_Ordinal);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_TransitionalRequestRequestTable;
  const fidl_type_t* resp_type =
      &::test::protocols::_internal::
          test_protocols_TransitionalRequestTopResponseTable;
  zx_status_t status_ = proxy_.Call(
      req_type, resp_type,
      ::test::protocols::Transitional_RequestEncoder::Request(&_encoder, &x),
      &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_y =
      ::fidl::DecodeAs<int64_t>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Transitional_SyncProxy::OneWay(int64_t x) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kTransitional_OneWay_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_TransitionalOneWayRequestTable;
  return proxy_.Send(
      req_type,
      ::test::protocols::Transitional_RequestEncoder::OneWay(&_encoder, &x));
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_MethodWithUnionUnionMethodRequestTable;

}  // namespace _internal
MethodWithUnion::~MethodWithUnion() = default;

const fidl_type_t* ::test::protocols::MethodWithUnion_RequestDecoder::GetType(
    uint64_t ordinal, bool* out_needs_response) {
  *out_needs_response = false;
  switch (ordinal) {
    case ::test::protocols::internal::kMethodWithUnion_UnionMethod_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_MethodWithUnionUnionMethodRequestTable;
      ;
    default:
      return nullptr;
  }
}

const fidl_type_t* MethodWithUnion_ResponseDecoder::GetType(uint64_t ordinal) {
  switch (ordinal) {
    default:
      return nullptr;
  }
}

MethodWithUnion_EventSender::~MethodWithUnion_EventSender() = default;

MethodWithUnion_Sync::~MethodWithUnion_Sync() = default;

MethodWithUnion_Proxy::MethodWithUnion_Proxy(
    ::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

MethodWithUnion_Proxy::~MethodWithUnion_Proxy() = default;

zx_status_t MethodWithUnion_Proxy::Dispatch_(
    ::fidl::HLCPPIncomingMessage message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}

void MethodWithUnion_Proxy::UnionMethod(::test::protocols::TheUnion u) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kMethodWithUnion_UnionMethod_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_MethodWithUnionUnionMethodRequestTable;
  controller_->Send(
      req_type,
      ::test::protocols::MethodWithUnion_RequestEncoder::UnionMethod(&_encoder,
                                                                     &u),
      nullptr);
}

MethodWithUnion_Stub::MethodWithUnion_Stub(
    ::test::protocols::MethodWithUnion_Stub::MethodWithUnion_clazz* impl)
    : impl_(impl) {
  (void)impl_;
}

MethodWithUnion_Stub::~MethodWithUnion_Stub() = default;

namespace {}  // namespace

zx_status_t MethodWithUnion_Stub::Dispatch_(
    ::fidl::HLCPPIncomingMessage message,
    ::fidl::internal::PendingResponse response) {
  bool needs_response;
  const fidl_type_t* request_type =
      ::test::protocols::MethodWithUnion_RequestDecoder::GetType(
          message.ordinal(), &needs_response);
  if (!message.has_only_header()) {
    if (request_type == nullptr) {
      return ZX_ERR_NOT_SUPPORTED;
    }
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(request_type, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, request_type, error_msg);
      return status;
    }
  }

  if (response.needs_response() != needs_response) {
    if (needs_response) {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message needing a response with no txid");
    } else {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message not needing a response with a txid");
    }
    return ZX_ERR_INVALID_ARGS;
  }

  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case ::test::protocols::internal::kMethodWithUnion_UnionMethod_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->UnionMethod(::fidl::DecodeAs<::test::protocols::TheUnion>(
          &decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    default: {
      return ZX_ERR_NOT_SUPPORTED;
    }
  }
  return ZX_OK;
}

MethodWithUnion_SyncProxy::MethodWithUnion_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

MethodWithUnion_SyncProxy::~MethodWithUnion_SyncProxy() = default;

zx_status_t MethodWithUnion_SyncProxy::UnionMethod(
    ::test::protocols::TheUnion u) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kMethodWithUnion_UnionMethod_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_MethodWithUnionUnionMethodRequestTable;
  return proxy_.Send(
      req_type, ::test::protocols::MethodWithUnion_RequestEncoder::UnionMethod(
                    &_encoder, &u));
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;

}  // namespace _internal
WithProtocolEnds::~WithProtocolEnds() = default;

const fidl_type_t* ::test::protocols::WithProtocolEnds_RequestDecoder::GetType(
    uint64_t ordinal, bool* out_needs_response) {
  *out_needs_response = false;
  switch (ordinal) {
    case ::test::protocols::internal::kWithProtocolEnds_ClientEnds_Ordinal:
      *out_needs_response = true;
      return &::test::protocols::_internal::
          test_protocols_WithProtocolEndsClientEndsRequestTable;
      ;
    case ::test::protocols::internal::kWithProtocolEnds_ServerEnds_Ordinal:
      *out_needs_response = true;
      return &::test::protocols::_internal::
          test_protocols_WithProtocolEndsServerEndsRequestTable;
      ;
    case ::test::protocols::internal::
        kWithProtocolEnds_StructContainingEnds_Ordinal:
      *out_needs_response = true;
      return &::test::protocols::_internal::
          test_protocols_WithProtocolEndsStructContainingEndsRequestTable;
      ;
    default:
      return nullptr;
  }
}

const fidl_type_t* WithProtocolEnds_ResponseDecoder::GetType(uint64_t ordinal) {
  switch (ordinal) {
    case ::test::protocols::internal::kWithProtocolEnds_ClientEnds_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_WithProtocolEndsClientEndsTopResponseTable;
      ;
    case ::test::protocols::internal::kWithProtocolEnds_ServerEnds_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_WithProtocolEndsServerEndsTopResponseTable;
      ;
    case ::test::protocols::internal::
        kWithProtocolEnds_StructContainingEnds_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;
      ;
    default:
      return nullptr;
  }
}

WithProtocolEnds_EventSender::~WithProtocolEnds_EventSender() = default;

WithProtocolEnds_Sync::~WithProtocolEnds_Sync() = default;

WithProtocolEnds_Proxy::WithProtocolEnds_Proxy(
    ::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

WithProtocolEnds_Proxy::~WithProtocolEnds_Proxy() = default;

zx_status_t WithProtocolEnds_Proxy::Dispatch_(
    ::fidl::HLCPPIncomingMessage message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}

namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
WithProtocolEnds_ClientEnds_ResponseHandler(
    WithProtocolEnds::ClientEndsCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback,
      "Callback must not be empty for WithProtocolEnds::ClientEnds\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ =
           std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::fidl::InterfaceHandle<
                      ::test::protocols::DiscoverableProtocol>>(
            &decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      },
      &::test::protocols::_internal::
          test_protocols_WithProtocolEndsClientEndsTopResponseTable);
}

}  // namespace
void WithProtocolEnds_Proxy::ClientEnds(
    ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol> in,
    ClientEndsCallback callback) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kWithProtocolEnds_ClientEnds_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_WithProtocolEndsClientEndsRequestTable;
  controller_->Send(
      req_type,
      ::test::protocols::WithProtocolEnds_RequestEncoder::ClientEnds(&_encoder,
                                                                     &in),
      WithProtocolEnds_ClientEnds_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
WithProtocolEnds_ServerEnds_ResponseHandler(
    WithProtocolEnds::ServerEndsCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback,
      "Callback must not be empty for WithProtocolEnds::ServerEnds\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ =
           std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::fidl::InterfaceRequest<
                      ::test::protocols::DiscoverableProtocol>>(
            &decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      },
      &::test::protocols::_internal::
          test_protocols_WithProtocolEndsServerEndsTopResponseTable);
}

}  // namespace
void WithProtocolEnds_Proxy::ServerEnds(
    ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol> in,
    ServerEndsCallback callback) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kWithProtocolEnds_ServerEnds_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_WithProtocolEndsServerEndsRequestTable;
  controller_->Send(
      req_type,
      ::test::protocols::WithProtocolEnds_RequestEncoder::ServerEnds(&_encoder,
                                                                     &in),
      WithProtocolEnds_ServerEnds_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
WithProtocolEnds_StructContainingEnds_ResponseHandler(
    WithProtocolEnds::StructContainingEndsCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for "
                      "WithProtocolEnds::StructContainingEnds\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ =
           std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::protocols::ProtocolEnds>(
            &decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      },
      &::test::protocols::_internal::
          test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable);
}

}  // namespace
void WithProtocolEnds_Proxy::StructContainingEnds(
    ::test::protocols::ProtocolEnds in, StructContainingEndsCallback callback) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kWithProtocolEnds_StructContainingEnds_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_WithProtocolEndsStructContainingEndsRequestTable;
  controller_->Send(
      req_type,
      ::test::protocols::WithProtocolEnds_RequestEncoder::StructContainingEnds(
          &_encoder, &in),
      WithProtocolEnds_StructContainingEnds_ResponseHandler(
          std::move(callback)));
}

WithProtocolEnds_Stub::WithProtocolEnds_Stub(
    ::test::protocols::WithProtocolEnds_Stub::WithProtocolEnds_clazz* impl)
    : impl_(impl) {
  (void)impl_;
}

WithProtocolEnds_Stub::~WithProtocolEnds_Stub() = default;

namespace {

class WithProtocolEnds_ClientEnds_Responder final {
 public:
  WithProtocolEnds_ClientEnds_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(
      ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol> out) {
    ::fidl::MessageEncoder _encoder(
        ::test::protocols::internal::kWithProtocolEnds_ClientEnds_Ordinal);
    const fidl_type_t* resp_type =
        &::test::protocols::_internal::
            test_protocols_WithProtocolEndsClientEndsTopResponseTable;
    response_.Send(
        resp_type,
        ::test::protocols::WithProtocolEnds_ResponseEncoder::ClientEnds(
            &_encoder, &out));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class WithProtocolEnds_ServerEnds_Responder final {
 public:
  WithProtocolEnds_ServerEnds_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(
      ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol> out) {
    ::fidl::MessageEncoder _encoder(
        ::test::protocols::internal::kWithProtocolEnds_ServerEnds_Ordinal);
    const fidl_type_t* resp_type =
        &::test::protocols::_internal::
            test_protocols_WithProtocolEndsServerEndsTopResponseTable;
    response_.Send(
        resp_type,
        ::test::protocols::WithProtocolEnds_ResponseEncoder::ServerEnds(
            &_encoder, &out));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class WithProtocolEnds_StructContainingEnds_Responder final {
 public:
  WithProtocolEnds_StructContainingEnds_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::protocols::ProtocolEnds out) {
    ::fidl::MessageEncoder _encoder(
        ::test::protocols::internal::
            kWithProtocolEnds_StructContainingEnds_Ordinal);
    const fidl_type_t* resp_type =
        &::test::protocols::_internal::
            test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;
    response_.Send(resp_type,
                   ::test::protocols::WithProtocolEnds_ResponseEncoder::
                       StructContainingEnds(&_encoder, &out));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

}  // namespace

zx_status_t WithProtocolEnds_Stub::Dispatch_(
    ::fidl::HLCPPIncomingMessage message,
    ::fidl::internal::PendingResponse response) {
  bool needs_response;
  const fidl_type_t* request_type =
      ::test::protocols::WithProtocolEnds_RequestDecoder::GetType(
          message.ordinal(), &needs_response);
  if (!message.has_only_header()) {
    if (request_type == nullptr) {
      return ZX_ERR_NOT_SUPPORTED;
    }
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(request_type, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, request_type, error_msg);
      return status;
    }
  }

  if (response.needs_response() != needs_response) {
    if (needs_response) {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message needing a response with no txid");
    } else {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message not needing a response with a txid");
    }
    return ZX_ERR_INVALID_ARGS;
  }

  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case ::test::protocols::internal::kWithProtocolEnds_ClientEnds_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->ClientEnds(
          ::fidl::DecodeAs<
              ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>>(
              &decoder, 0 + sizeof(fidl_message_header_t)),
          WithProtocolEnds_ClientEnds_Responder(std::move(response)));
      break;
    }
    case ::test::protocols::internal::kWithProtocolEnds_ServerEnds_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->ServerEnds(
          ::fidl::DecodeAs<::fidl::InterfaceRequest<
              ::test::protocols::DiscoverableProtocol>>(
              &decoder, 0 + sizeof(fidl_message_header_t)),
          WithProtocolEnds_ServerEnds_Responder(std::move(response)));
      break;
    }
    case ::test::protocols::internal::
        kWithProtocolEnds_StructContainingEnds_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->StructContainingEnds(
          ::fidl::DecodeAs<::test::protocols::ProtocolEnds>(
              &decoder, 0 + sizeof(fidl_message_header_t)),
          WithProtocolEnds_StructContainingEnds_Responder(std::move(response)));
      break;
    }
    default: {
      return ZX_ERR_NOT_SUPPORTED;
    }
  }
  return ZX_OK;
}

WithProtocolEnds_SyncProxy::WithProtocolEnds_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

WithProtocolEnds_SyncProxy::~WithProtocolEnds_SyncProxy() = default;

zx_status_t WithProtocolEnds_SyncProxy::ClientEnds(
    ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol> in,
    ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>* out_out) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kWithProtocolEnds_ClientEnds_Ordinal);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_WithProtocolEndsClientEndsRequestTable;
  const fidl_type_t* resp_type =
      &::test::protocols::_internal::
          test_protocols_WithProtocolEndsClientEndsTopResponseTable;
  zx_status_t status_ = proxy_.Call(
      req_type, resp_type,
      ::test::protocols::WithProtocolEnds_RequestEncoder::ClientEnds(&_encoder,
                                                                     &in),
      &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_out = ::fidl::DecodeAs<
      ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>>(
      &decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t WithProtocolEnds_SyncProxy::ServerEnds(
    ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol> in,
    ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>*
        out_out) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kWithProtocolEnds_ServerEnds_Ordinal);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_WithProtocolEndsServerEndsRequestTable;
  const fidl_type_t* resp_type =
      &::test::protocols::_internal::
          test_protocols_WithProtocolEndsServerEndsTopResponseTable;
  zx_status_t status_ = proxy_.Call(
      req_type, resp_type,
      ::test::protocols::WithProtocolEnds_RequestEncoder::ServerEnds(&_encoder,
                                                                     &in),
      &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_out = ::fidl::DecodeAs<
      ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>>(
      &decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t WithProtocolEnds_SyncProxy::StructContainingEnds(
    ::test::protocols::ProtocolEnds in,
    ::test::protocols::ProtocolEnds* out_out) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::
          kWithProtocolEnds_StructContainingEnds_Ordinal);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_WithProtocolEndsStructContainingEndsRequestTable;
  const fidl_type_t* resp_type =
      &::test::protocols::_internal::
          test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;
  zx_status_t status_ = proxy_.Call(
      req_type, resp_type,
      ::test::protocols::WithProtocolEnds_RequestEncoder::StructContainingEnds(
          &_encoder, &in),
      &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_out = ::fidl::DecodeAs<::test::protocols::ProtocolEnds>(
      &decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_ManyParametersFifteenRequestTable;

}  // namespace _internal
ManyParameters::~ManyParameters() = default;

const fidl_type_t* ::test::protocols::ManyParameters_RequestDecoder::GetType(
    uint64_t ordinal, bool* out_needs_response) {
  *out_needs_response = false;
  switch (ordinal) {
    case ::test::protocols::internal::kManyParameters_Fifteen_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_ManyParametersFifteenRequestTable;
      ;
    default:
      return nullptr;
  }
}

const fidl_type_t* ManyParameters_ResponseDecoder::GetType(uint64_t ordinal) {
  switch (ordinal) {
    default:
      return nullptr;
  }
}

ManyParameters_EventSender::~ManyParameters_EventSender() = default;

ManyParameters_Sync::~ManyParameters_Sync() = default;

ManyParameters_Proxy::ManyParameters_Proxy(
    ::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

ManyParameters_Proxy::~ManyParameters_Proxy() = default;

zx_status_t ManyParameters_Proxy::Dispatch_(
    ::fidl::HLCPPIncomingMessage message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}

void ManyParameters_Proxy::Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5,
                                   bool p6, bool p7, bool p8, bool p9, bool p10,
                                   bool p11, bool p12, bool p13, bool p14,
                                   bool p15) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kManyParameters_Fifteen_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_ManyParametersFifteenRequestTable;
  controller_->Send(req_type,
                    ::test::protocols::ManyParameters_RequestEncoder::Fifteen(
                        &_encoder, &p1, &p2, &p3, &p4, &p5, &p6, &p7, &p8, &p9,
                        &p10, &p11, &p12, &p13, &p14, &p15),
                    nullptr);
}

ManyParameters_Stub::ManyParameters_Stub(
    ::test::protocols::ManyParameters_Stub::ManyParameters_clazz* impl)
    : impl_(impl) {
  (void)impl_;
}

ManyParameters_Stub::~ManyParameters_Stub() = default;

namespace {}  // namespace

zx_status_t ManyParameters_Stub::Dispatch_(
    ::fidl::HLCPPIncomingMessage message,
    ::fidl::internal::PendingResponse response) {
  bool needs_response;
  const fidl_type_t* request_type =
      ::test::protocols::ManyParameters_RequestDecoder::GetType(
          message.ordinal(), &needs_response);
  if (!message.has_only_header()) {
    if (request_type == nullptr) {
      return ZX_ERR_NOT_SUPPORTED;
    }
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(request_type, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, request_type, error_msg);
      return status;
    }
  }

  if (response.needs_response() != needs_response) {
    if (needs_response) {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message needing a response with no txid");
    } else {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message not needing a response with a txid");
    }
    return ZX_ERR_INVALID_ARGS;
  }

  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case ::test::protocols::internal::kManyParameters_Fifteen_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->Fifteen(
          ::fidl::DecodeAs<bool>(&decoder, 0 + sizeof(fidl_message_header_t)),
          ::fidl::DecodeAs<bool>(&decoder, 1 + sizeof(fidl_message_header_t)),
          ::fidl::DecodeAs<bool>(&decoder, 2 + sizeof(fidl_message_header_t)),
          ::fidl::DecodeAs<bool>(&decoder, 3 + sizeof(fidl_message_header_t)),
          ::fidl::DecodeAs<bool>(&decoder, 4 + sizeof(fidl_message_header_t)),
          ::fidl::DecodeAs<bool>(&decoder, 5 + sizeof(fidl_message_header_t)),
          ::fidl::DecodeAs<bool>(&decoder, 6 + sizeof(fidl_message_header_t)),
          ::fidl::DecodeAs<bool>(&decoder, 7 + sizeof(fidl_message_header_t)),
          ::fidl::DecodeAs<bool>(&decoder, 8 + sizeof(fidl_message_header_t)),
          ::fidl::DecodeAs<bool>(&decoder, 9 + sizeof(fidl_message_header_t)),
          ::fidl::DecodeAs<bool>(&decoder, 10 + sizeof(fidl_message_header_t)),
          ::fidl::DecodeAs<bool>(&decoder, 11 + sizeof(fidl_message_header_t)),
          ::fidl::DecodeAs<bool>(&decoder, 12 + sizeof(fidl_message_header_t)),
          ::fidl::DecodeAs<bool>(&decoder, 13 + sizeof(fidl_message_header_t)),
          ::fidl::DecodeAs<bool>(&decoder, 14 + sizeof(fidl_message_header_t)));
      break;
    }
    default: {
      return ZX_ERR_NOT_SUPPORTED;
    }
  }
  return ZX_OK;
}

ManyParameters_SyncProxy::ManyParameters_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

ManyParameters_SyncProxy::~ManyParameters_SyncProxy() = default;

zx_status_t ManyParameters_SyncProxy::Fifteen(bool p1, bool p2, bool p3,
                                              bool p4, bool p5, bool p6,
                                              bool p7, bool p8, bool p9,
                                              bool p10, bool p11, bool p12,
                                              bool p13, bool p14, bool p15) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kManyParameters_Fifteen_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_ManyParametersFifteenRequestTable;
  return proxy_.Send(req_type,
                     ::test::protocols::ManyParameters_RequestEncoder::Fifteen(
                         &_encoder, &p1, &p2, &p3, &p4, &p5, &p6, &p7, &p8, &p9,
                         &p10, &p11, &p12, &p13, &p14, &p15));
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;

}  // namespace _internal
WithErrorSyntax::~WithErrorSyntax() = default;

const fidl_type_t* ::test::protocols::WithErrorSyntax_RequestDecoder::GetType(
    uint64_t ordinal, bool* out_needs_response) {
  *out_needs_response = false;
  switch (ordinal) {
    case ::test::protocols::internal::kWithErrorSyntax_ResponseAsStruct_Ordinal:
      *out_needs_response = true;
      return nullptr;
      ;
    case ::test::protocols::internal::kWithErrorSyntax_ErrorAsPrimitive_Ordinal:
      *out_needs_response = true;
      return nullptr;
      ;
    case ::test::protocols::internal::kWithErrorSyntax_ErrorAsEnum_Ordinal:
      *out_needs_response = true;
      return nullptr;
      ;
    case ::test::protocols::internal::kWithErrorSyntax_HandleInResult_Ordinal:
      *out_needs_response = true;
      return nullptr;
      ;
    default:
      return nullptr;
  }
}

const fidl_type_t* WithErrorSyntax_ResponseDecoder::GetType(uint64_t ordinal) {
  switch (ordinal) {
    case ::test::protocols::internal::kWithErrorSyntax_ResponseAsStruct_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;
      ;
    case ::test::protocols::internal::kWithErrorSyntax_ErrorAsPrimitive_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;
      ;
    case ::test::protocols::internal::kWithErrorSyntax_ErrorAsEnum_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;
      ;
    case ::test::protocols::internal::kWithErrorSyntax_HandleInResult_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;
      ;
    default:
      return nullptr;
  }
}

WithErrorSyntax_EventSender::~WithErrorSyntax_EventSender() = default;

WithErrorSyntax_Sync::~WithErrorSyntax_Sync() = default;

WithErrorSyntax_Proxy::WithErrorSyntax_Proxy(
    ::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

WithErrorSyntax_Proxy::~WithErrorSyntax_Proxy() = default;

zx_status_t WithErrorSyntax_Proxy::Dispatch_(
    ::fidl::HLCPPIncomingMessage message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}

namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
WithErrorSyntax_ResponseAsStruct_ResponseHandler(
    WithErrorSyntax::ResponseAsStructCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback,
      "Callback must not be empty for WithErrorSyntax::ResponseAsStruct\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ =
           std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<
                  ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result>(
            &decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      },
      &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable);
}

}  // namespace
void WithErrorSyntax_Proxy::ResponseAsStruct(
    ResponseAsStructCallback callback) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kWithErrorSyntax_ResponseAsStruct_Ordinal);
  const fidl_type_t* req_type = nullptr;
  controller_->Send(
      req_type,
      ::test::protocols::WithErrorSyntax_RequestEncoder::ResponseAsStruct(
          &_encoder),
      WithErrorSyntax_ResponseAsStruct_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
WithErrorSyntax_ErrorAsPrimitive_ResponseHandler(
    WithErrorSyntax::ErrorAsPrimitiveCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback,
      "Callback must not be empty for WithErrorSyntax::ErrorAsPrimitive\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ =
           std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<
                  ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result>(
            &decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      },
      &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable);
}

}  // namespace
void WithErrorSyntax_Proxy::ErrorAsPrimitive(
    ErrorAsPrimitiveCallback callback) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kWithErrorSyntax_ErrorAsPrimitive_Ordinal);
  const fidl_type_t* req_type = nullptr;
  controller_->Send(
      req_type,
      ::test::protocols::WithErrorSyntax_RequestEncoder::ErrorAsPrimitive(
          &_encoder),
      WithErrorSyntax_ErrorAsPrimitive_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
WithErrorSyntax_ErrorAsEnum_ResponseHandler(
    WithErrorSyntax::ErrorAsEnumCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback,
      "Callback must not be empty for WithErrorSyntax::ErrorAsEnum\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ =
           std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<
                  ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result>(
            &decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      },
      &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable);
}

}  // namespace
void WithErrorSyntax_Proxy::ErrorAsEnum(ErrorAsEnumCallback callback) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kWithErrorSyntax_ErrorAsEnum_Ordinal);
  const fidl_type_t* req_type = nullptr;
  controller_->Send(
      req_type,
      ::test::protocols::WithErrorSyntax_RequestEncoder::ErrorAsEnum(&_encoder),
      WithErrorSyntax_ErrorAsEnum_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
WithErrorSyntax_HandleInResult_ResponseHandler(
    WithErrorSyntax::HandleInResultCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback,
      "Callback must not be empty for WithErrorSyntax::HandleInResult\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ =
           std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<
                  ::test::protocols::WithErrorSyntax_HandleInResult_Result>(
            &decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      },
      &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxHandleInResultTopResponseTable);
}

}  // namespace
void WithErrorSyntax_Proxy::HandleInResult(HandleInResultCallback callback) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kWithErrorSyntax_HandleInResult_Ordinal);
  const fidl_type_t* req_type = nullptr;
  controller_->Send(
      req_type,
      ::test::protocols::WithErrorSyntax_RequestEncoder::HandleInResult(
          &_encoder),
      WithErrorSyntax_HandleInResult_ResponseHandler(std::move(callback)));
}

WithErrorSyntax_Stub::WithErrorSyntax_Stub(
    ::test::protocols::WithErrorSyntax_Stub::WithErrorSyntax_clazz* impl)
    : impl_(impl) {
  (void)impl_;
}

WithErrorSyntax_Stub::~WithErrorSyntax_Stub() = default;

namespace {

class WithErrorSyntax_ResponseAsStruct_Responder final {
 public:
  WithErrorSyntax_ResponseAsStruct_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(
      ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result result) {
    ::fidl::MessageEncoder _encoder(
        ::test::protocols::internal::kWithErrorSyntax_ResponseAsStruct_Ordinal);
    const fidl_type_t* resp_type =
        &::test::protocols::_internal::
            test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;
    response_.Send(
        resp_type,
        ::test::protocols::WithErrorSyntax_ResponseEncoder::ResponseAsStruct(
            &_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class WithErrorSyntax_ErrorAsPrimitive_Responder final {
 public:
  WithErrorSyntax_ErrorAsPrimitive_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(
      ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result result) {
    ::fidl::MessageEncoder _encoder(
        ::test::protocols::internal::kWithErrorSyntax_ErrorAsPrimitive_Ordinal);
    const fidl_type_t* resp_type =
        &::test::protocols::_internal::
            test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;
    response_.Send(
        resp_type,
        ::test::protocols::WithErrorSyntax_ResponseEncoder::ErrorAsPrimitive(
            &_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class WithErrorSyntax_ErrorAsEnum_Responder final {
 public:
  WithErrorSyntax_ErrorAsEnum_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(
      ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result result) {
    ::fidl::MessageEncoder _encoder(
        ::test::protocols::internal::kWithErrorSyntax_ErrorAsEnum_Ordinal);
    const fidl_type_t* resp_type =
        &::test::protocols::_internal::
            test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;
    response_.Send(
        resp_type,
        ::test::protocols::WithErrorSyntax_ResponseEncoder::ErrorAsEnum(
            &_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class WithErrorSyntax_HandleInResult_Responder final {
 public:
  WithErrorSyntax_HandleInResult_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(
      ::test::protocols::WithErrorSyntax_HandleInResult_Result result) {
    ::fidl::MessageEncoder _encoder(
        ::test::protocols::internal::kWithErrorSyntax_HandleInResult_Ordinal);
    const fidl_type_t* resp_type =
        &::test::protocols::_internal::
            test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;
    response_.Send(
        resp_type,
        ::test::protocols::WithErrorSyntax_ResponseEncoder::HandleInResult(
            &_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

}  // namespace

zx_status_t WithErrorSyntax_Stub::Dispatch_(
    ::fidl::HLCPPIncomingMessage message,
    ::fidl::internal::PendingResponse response) {
  bool needs_response;
  const fidl_type_t* request_type =
      ::test::protocols::WithErrorSyntax_RequestDecoder::GetType(
          message.ordinal(), &needs_response);
  if (!message.has_only_header()) {
    if (request_type == nullptr) {
      return ZX_ERR_NOT_SUPPORTED;
    }
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(request_type, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, request_type, error_msg);
      return status;
    }
  }

  if (response.needs_response() != needs_response) {
    if (needs_response) {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message needing a response with no txid");
    } else {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message not needing a response with a txid");
    }
    return ZX_ERR_INVALID_ARGS;
  }

  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case ::test::protocols::internal::
        kWithErrorSyntax_ResponseAsStruct_Ordinal: {
      impl_->ResponseAsStruct(
          WithErrorSyntax_ResponseAsStruct_Responder(std::move(response)));
      break;
    }
    case ::test::protocols::internal::
        kWithErrorSyntax_ErrorAsPrimitive_Ordinal: {
      impl_->ErrorAsPrimitive(
          WithErrorSyntax_ErrorAsPrimitive_Responder(std::move(response)));
      break;
    }
    case ::test::protocols::internal::kWithErrorSyntax_ErrorAsEnum_Ordinal: {
      impl_->ErrorAsEnum(
          WithErrorSyntax_ErrorAsEnum_Responder(std::move(response)));
      break;
    }
    case ::test::protocols::internal::kWithErrorSyntax_HandleInResult_Ordinal: {
      impl_->HandleInResult(
          WithErrorSyntax_HandleInResult_Responder(std::move(response)));
      break;
    }
    default: {
      return ZX_ERR_NOT_SUPPORTED;
    }
  }
  return ZX_OK;
}

WithErrorSyntax_SyncProxy::WithErrorSyntax_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

WithErrorSyntax_SyncProxy::~WithErrorSyntax_SyncProxy() = default;

zx_status_t WithErrorSyntax_SyncProxy::ResponseAsStruct(
    ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result* out_result) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kWithErrorSyntax_ResponseAsStruct_Ordinal);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type = nullptr;
  const fidl_type_t* resp_type =
      &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;
  zx_status_t status_ = proxy_.Call(
      req_type, resp_type,
      ::test::protocols::WithErrorSyntax_RequestEncoder::ResponseAsStruct(
          &_encoder),
      &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<
      ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result>(
      &decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t WithErrorSyntax_SyncProxy::ErrorAsPrimitive(
    ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result* out_result) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kWithErrorSyntax_ErrorAsPrimitive_Ordinal);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type = nullptr;
  const fidl_type_t* resp_type =
      &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;
  zx_status_t status_ = proxy_.Call(
      req_type, resp_type,
      ::test::protocols::WithErrorSyntax_RequestEncoder::ErrorAsPrimitive(
          &_encoder),
      &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<
      ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result>(
      &decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t WithErrorSyntax_SyncProxy::ErrorAsEnum(
    ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result* out_result) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kWithErrorSyntax_ErrorAsEnum_Ordinal);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type = nullptr;
  const fidl_type_t* resp_type =
      &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;
  zx_status_t status_ = proxy_.Call(
      req_type, resp_type,
      ::test::protocols::WithErrorSyntax_RequestEncoder::ErrorAsEnum(&_encoder),
      &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result =
      ::fidl::DecodeAs<::test::protocols::WithErrorSyntax_ErrorAsEnum_Result>(
          &decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t WithErrorSyntax_SyncProxy::HandleInResult(
    ::test::protocols::WithErrorSyntax_HandleInResult_Result* out_result) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kWithErrorSyntax_HandleInResult_Ordinal);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type = nullptr;
  const fidl_type_t* resp_type =
      &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;
  zx_status_t status_ = proxy_.Call(
      req_type, resp_type,
      ::test::protocols::WithErrorSyntax_RequestEncoder::HandleInResult(
          &_encoder),
      &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<
      ::test::protocols::WithErrorSyntax_HandleInResult_Result>(
      &decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

DiscoverableProtocol::~DiscoverableProtocol() = default;
const char DiscoverableProtocol::Name_[] =
    "test.protocols.DiscoverableProtocol";

const fidl_type_t* ::test::protocols::DiscoverableProtocol_RequestDecoder::
    GetType(uint64_t ordinal, bool* out_needs_response) {
  *out_needs_response = false;
  switch (ordinal) {
    case ::test::protocols::internal::kDiscoverableProtocol_Method_Ordinal:
      return nullptr;
      ;
    default:
      return nullptr;
  }
}

const fidl_type_t* DiscoverableProtocol_ResponseDecoder::GetType(
    uint64_t ordinal) {
  switch (ordinal) {
    default:
      return nullptr;
  }
}

DiscoverableProtocol_EventSender::~DiscoverableProtocol_EventSender() = default;

DiscoverableProtocol_Sync::~DiscoverableProtocol_Sync() = default;

DiscoverableProtocol_Proxy::DiscoverableProtocol_Proxy(
    ::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

DiscoverableProtocol_Proxy::~DiscoverableProtocol_Proxy() = default;

zx_status_t DiscoverableProtocol_Proxy::Dispatch_(
    ::fidl::HLCPPIncomingMessage message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}

void DiscoverableProtocol_Proxy::Method() {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kDiscoverableProtocol_Method_Ordinal);
  const fidl_type_t* req_type = nullptr;
  controller_->Send(
      req_type,
      ::test::protocols::DiscoverableProtocol_RequestEncoder::Method(&_encoder),
      nullptr);
}

DiscoverableProtocol_Stub::DiscoverableProtocol_Stub(
    ::test::protocols::DiscoverableProtocol_Stub::DiscoverableProtocol_clazz*
        impl)
    : impl_(impl) {
  (void)impl_;
}

DiscoverableProtocol_Stub::~DiscoverableProtocol_Stub() = default;

namespace {}  // namespace

zx_status_t DiscoverableProtocol_Stub::Dispatch_(
    ::fidl::HLCPPIncomingMessage message,
    ::fidl::internal::PendingResponse response) {
  bool needs_response;
  const fidl_type_t* request_type =
      ::test::protocols::DiscoverableProtocol_RequestDecoder::GetType(
          message.ordinal(), &needs_response);
  if (!message.has_only_header()) {
    if (request_type == nullptr) {
      return ZX_ERR_NOT_SUPPORTED;
    }
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(request_type, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, request_type, error_msg);
      return status;
    }
  }

  if (response.needs_response() != needs_response) {
    if (needs_response) {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message needing a response with no txid");
    } else {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message not needing a response with a txid");
    }
    return ZX_ERR_INVALID_ARGS;
  }

  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case ::test::protocols::internal::kDiscoverableProtocol_Method_Ordinal: {
      impl_->Method();
      break;
    }
    default: {
      return ZX_ERR_NOT_SUPPORTED;
    }
  }
  return ZX_OK;
}

DiscoverableProtocol_SyncProxy::DiscoverableProtocol_SyncProxy(
    ::zx::channel channel)
    : proxy_(::std::move(channel)) {}

DiscoverableProtocol_SyncProxy::~DiscoverableProtocol_SyncProxy() = default;

zx_status_t DiscoverableProtocol_SyncProxy::Method() {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kDiscoverableProtocol_Method_Ordinal);
  const fidl_type_t* req_type = nullptr;
  return proxy_.Send(
      req_type, ::test::protocols::DiscoverableProtocol_RequestEncoder::Method(
                    &_encoder));
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodARequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolEventARequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodBRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodBTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolTakeHandleRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketTopResponseTable;

}  // namespace _internal
ChannelProtocol::~ChannelProtocol() = default;

const fidl_type_t* ::test::protocols::ChannelProtocol_RequestDecoder::GetType(
    uint64_t ordinal, bool* out_needs_response) {
  *out_needs_response = false;
  switch (ordinal) {
    case ::test::protocols::internal::kChannelProtocol_MethodA_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_ChannelProtocolMethodARequestTable;
      ;
    case ::test::protocols::internal::kChannelProtocol_MethodB_Ordinal:
      *out_needs_response = true;
      return &::test::protocols::_internal::
          test_protocols_ChannelProtocolMethodBRequestTable;
      ;
    case ::test::protocols::internal::kChannelProtocol_TakeHandle_Ordinal:
      *out_needs_response = true;
      return &::test::protocols::_internal::
          test_protocols_ChannelProtocolTakeHandleRequestTable;
      ;
    case ::test::protocols::internal::kChannelProtocol_MutateSocket_Ordinal:
      *out_needs_response = true;
      return &::test::protocols::_internal::
          test_protocols_ChannelProtocolMutateSocketRequestTable;
      ;
    default:
      return nullptr;
  }
}

const fidl_type_t* ChannelProtocol_ResponseDecoder::GetType(uint64_t ordinal) {
  switch (ordinal) {
    case ::test::protocols::internal::kChannelProtocol_EventA_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_ChannelProtocolEventARequestTable;
      ;
    case ::test::protocols::internal::kChannelProtocol_MethodB_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_ChannelProtocolMethodBTopResponseTable;
      ;
    case ::test::protocols::internal::kChannelProtocol_TakeHandle_Ordinal:
      return nullptr;
      ;
    case ::test::protocols::internal::kChannelProtocol_MutateSocket_Ordinal:
      return &::test::protocols::_internal::
          test_protocols_ChannelProtocolMutateSocketTopResponseTable;
      ;
    default:
      return nullptr;
  }
}

ChannelProtocol_EventSender::~ChannelProtocol_EventSender() = default;

ChannelProtocol_Sync::~ChannelProtocol_Sync() = default;

ChannelProtocol_Proxy::ChannelProtocol_Proxy(
    ::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

ChannelProtocol_Proxy::~ChannelProtocol_Proxy() = default;

zx_status_t ChannelProtocol_Proxy::Dispatch_(
    ::fidl::HLCPPIncomingMessage message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    case ::test::protocols::internal::kChannelProtocol_EventA_Ordinal: {
      if (!EventA) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status =
          message.Decode(&::test::protocols::_internal::
                             test_protocols_ChannelProtocolEventARequestTable,
                         &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(
            message,
            &::test::protocols::_internal::
                test_protocols_ChannelProtocolEventARequestTable,
            error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      EventA(::fidl::DecodeAs<int64_t>(&decoder,
                                       0 + sizeof(fidl_message_header_t)),
             ::fidl::DecodeAs<int64_t>(&decoder,
                                       8 + sizeof(fidl_message_header_t)));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}

void ChannelProtocol_Proxy::MethodA(int64_t a, int64_t b) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kChannelProtocol_MethodA_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolMethodARequestTable;
  controller_->Send(req_type,
                    ::test::protocols::ChannelProtocol_RequestEncoder::MethodA(
                        &_encoder, &a, &b),
                    nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
ChannelProtocol_MethodB_ResponseHandler(
    ChannelProtocol::MethodBCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback, "Callback must not be empty for ChannelProtocol::MethodB\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ =
           std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<int64_t>(&decoder,
                                            0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      },
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolMethodBTopResponseTable);
}

}  // namespace
void ChannelProtocol_Proxy::MethodB(int64_t a, int64_t b,
                                    MethodBCallback callback) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kChannelProtocol_MethodB_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolMethodBRequestTable;
  controller_->Send(
      req_type,
      ::test::protocols::ChannelProtocol_RequestEncoder::MethodB(&_encoder, &a,
                                                                 &b),
      ChannelProtocol_MethodB_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
ChannelProtocol_TakeHandle_ResponseHandler(
    ChannelProtocol::TakeHandleCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback, "Callback must not be empty for ChannelProtocol::TakeHandle\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ =
           std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        callback_();
        return ZX_OK;
      },
      nullptr);
}

}  // namespace
void ChannelProtocol_Proxy::TakeHandle(::zx::handle h,
                                       TakeHandleCallback callback) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kChannelProtocol_TakeHandle_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolTakeHandleRequestTable;
  controller_->Send(
      req_type,
      ::test::protocols::ChannelProtocol_RequestEncoder::TakeHandle(&_encoder,
                                                                    &h),
      ChannelProtocol_TakeHandle_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
ChannelProtocol_MutateSocket_ResponseHandler(
    ChannelProtocol::MutateSocketCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback,
      "Callback must not be empty for ChannelProtocol::MutateSocket\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ =
           std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::zx::socket>(
            &decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      },
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolMutateSocketTopResponseTable);
}

}  // namespace
void ChannelProtocol_Proxy::MutateSocket(::zx::socket a,
                                         MutateSocketCallback callback) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kChannelProtocol_MutateSocket_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolMutateSocketRequestTable;
  controller_->Send(
      req_type,
      ::test::protocols::ChannelProtocol_RequestEncoder::MutateSocket(&_encoder,
                                                                      &a),
      ChannelProtocol_MutateSocket_ResponseHandler(std::move(callback)));
}

ChannelProtocol_Stub::ChannelProtocol_Stub(
    ::test::protocols::ChannelProtocol_Stub::ChannelProtocol_clazz* impl)
    : impl_(impl) {
  (void)impl_;
}

ChannelProtocol_Stub::~ChannelProtocol_Stub() = default;

namespace {

class ChannelProtocol_MethodB_Responder final {
 public:
  ChannelProtocol_MethodB_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(int64_t result) {
    ::fidl::MessageEncoder _encoder(
        ::test::protocols::internal::kChannelProtocol_MethodB_Ordinal);
    const fidl_type_t* resp_type =
        &::test::protocols::_internal::
            test_protocols_ChannelProtocolMethodBTopResponseTable;
    response_.Send(resp_type,
                   ::test::protocols::ChannelProtocol_ResponseEncoder::MethodB(
                       &_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class ChannelProtocol_TakeHandle_Responder final {
 public:
  ChannelProtocol_TakeHandle_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()() {
    ::fidl::MessageEncoder _encoder(
        ::test::protocols::internal::kChannelProtocol_TakeHandle_Ordinal);
    const fidl_type_t* resp_type = nullptr;
    response_.Send(
        resp_type,
        ::test::protocols::ChannelProtocol_ResponseEncoder::TakeHandle(
            &_encoder));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class ChannelProtocol_MutateSocket_Responder final {
 public:
  ChannelProtocol_MutateSocket_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::zx::socket b) {
    ::fidl::MessageEncoder _encoder(
        ::test::protocols::internal::kChannelProtocol_MutateSocket_Ordinal);
    const fidl_type_t* resp_type =
        &::test::protocols::_internal::
            test_protocols_ChannelProtocolMutateSocketTopResponseTable;
    response_.Send(
        resp_type,
        ::test::protocols::ChannelProtocol_ResponseEncoder::MutateSocket(
            &_encoder, &b));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

}  // namespace

zx_status_t ChannelProtocol_Stub::Dispatch_(
    ::fidl::HLCPPIncomingMessage message,
    ::fidl::internal::PendingResponse response) {
  bool needs_response;
  const fidl_type_t* request_type =
      ::test::protocols::ChannelProtocol_RequestDecoder::GetType(
          message.ordinal(), &needs_response);
  if (!message.has_only_header()) {
    if (request_type == nullptr) {
      return ZX_ERR_NOT_SUPPORTED;
    }
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(request_type, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, request_type, error_msg);
      return status;
    }
  }

  if (response.needs_response() != needs_response) {
    if (needs_response) {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message needing a response with no txid");
    } else {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message not needing a response with a txid");
    }
    return ZX_ERR_INVALID_ARGS;
  }

  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case ::test::protocols::internal::kChannelProtocol_MethodA_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->MethodA(::fidl::DecodeAs<int64_t>(
                         &decoder, 0 + sizeof(fidl_message_header_t)),
                     ::fidl::DecodeAs<int64_t>(
                         &decoder, 8 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::protocols::internal::kChannelProtocol_MethodB_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->MethodB(::fidl::DecodeAs<int64_t>(
                         &decoder, 0 + sizeof(fidl_message_header_t)),
                     ::fidl::DecodeAs<int64_t>(
                         &decoder, 8 + sizeof(fidl_message_header_t)),
                     ChannelProtocol_MethodB_Responder(std::move(response)));
      break;
    }
    case ::test::protocols::internal::kChannelProtocol_TakeHandle_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TakeHandle(
          ::fidl::DecodeAs<::zx::handle>(&decoder,
                                         0 + sizeof(fidl_message_header_t)),
          ChannelProtocol_TakeHandle_Responder(std::move(response)));
      break;
    }
    case ::test::protocols::internal::kChannelProtocol_MutateSocket_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->MutateSocket(
          ::fidl::DecodeAs<::zx::socket>(&decoder,
                                         0 + sizeof(fidl_message_header_t)),
          ChannelProtocol_MutateSocket_Responder(std::move(response)));
      break;
    }
    default: {
      return ZX_ERR_NOT_SUPPORTED;
    }
  }
  return ZX_OK;
}
void ChannelProtocol_Stub::EventA(int64_t a, int64_t b) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kChannelProtocol_EventA_Ordinal);
  const fidl_type_t* resp_type =
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolEventARequestTable;
  sender_()->Send(resp_type,
                  ::test::protocols::ChannelProtocol_ResponseEncoder::EventA(
                      &_encoder, &a, &b));
}

ChannelProtocol_SyncProxy::ChannelProtocol_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

ChannelProtocol_SyncProxy::~ChannelProtocol_SyncProxy() = default;

zx_status_t ChannelProtocol_SyncProxy::MethodA(int64_t a, int64_t b) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kChannelProtocol_MethodA_Ordinal);
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolMethodARequestTable;
  return proxy_.Send(req_type,
                     ::test::protocols::ChannelProtocol_RequestEncoder::MethodA(
                         &_encoder, &a, &b));
}

zx_status_t ChannelProtocol_SyncProxy::MethodB(int64_t a, int64_t b,
                                               int64_t* out_result) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kChannelProtocol_MethodB_Ordinal);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolMethodBRequestTable;
  const fidl_type_t* resp_type =
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolMethodBTopResponseTable;
  zx_status_t status_ =
      proxy_.Call(req_type, resp_type,
                  ::test::protocols::ChannelProtocol_RequestEncoder::MethodB(
                      &_encoder, &a, &b),
                  &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result =
      ::fidl::DecodeAs<int64_t>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t ChannelProtocol_SyncProxy::TakeHandle(::zx::handle h) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kChannelProtocol_TakeHandle_Ordinal);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolTakeHandleRequestTable;
  const fidl_type_t* resp_type = nullptr;
  zx_status_t status_ =
      proxy_.Call(req_type, resp_type,
                  ::test::protocols::ChannelProtocol_RequestEncoder::TakeHandle(
                      &_encoder, &h),
                  &response_);
  if (status_ != ZX_OK) return status_;
  return ZX_OK;
}

zx_status_t ChannelProtocol_SyncProxy::MutateSocket(::zx::socket a,
                                                    ::zx::socket* out_b) {
  ::fidl::MessageEncoder _encoder(
      ::test::protocols::internal::kChannelProtocol_MutateSocket_Ordinal);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolMutateSocketRequestTable;
  const fidl_type_t* resp_type =
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolMutateSocketTopResponseTable;
  zx_status_t status_ = proxy_.Call(
      req_type, resp_type,
      ::test::protocols::ChannelProtocol_RequestEncoder::MutateSocket(&_encoder,
                                                                      &a),
      &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_b = ::fidl::DecodeAs<::zx::socket>(&decoder_,
                                          0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}
#endif  // __Fuchsia__

}  // namespace protocols
}  // namespace test
