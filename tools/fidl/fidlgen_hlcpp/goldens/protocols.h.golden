// WARNING: This file is machine generated by fidlgen.

#pragma once

#include "lib/fidl/cpp/internal/header.h"

//
// Domain objects declarations (i.e. "natural types" in unified bindings).
//
namespace test {
namespace protocols {
enum class rights : uint32_t {

  TRANSFER = 1u,

  DUPLICATE = 2u,
};

const static rights rightsMask = static_cast<rights>(3u);

constexpr inline ::test::protocols::rights operator|(
    ::test::protocols::rights _lhs, ::test::protocols::rights _rhs) {
  return static_cast<::test::protocols::rights>(static_cast<uint32_t>(_lhs) |
                                                static_cast<uint32_t>(_rhs));
}

constexpr inline ::test::protocols::rights& operator|=(
    ::test::protocols::rights& _lhs, ::test::protocols::rights _rhs) {
  _lhs = _lhs | _rhs;
  return _lhs;
}

constexpr inline ::test::protocols::rights operator&(
    ::test::protocols::rights _lhs, ::test::protocols::rights _rhs) {
  return static_cast<::test::protocols::rights>(static_cast<uint32_t>(_lhs) &
                                                static_cast<uint32_t>(_rhs));
}

constexpr inline ::test::protocols::rights& operator&=(
    ::test::protocols::rights& _lhs, ::test::protocols::rights _rhs) {
  _lhs = _lhs & _rhs;
  return _lhs;
}

constexpr inline ::test::protocols::rights operator^(
    ::test::protocols::rights _lhs, ::test::protocols::rights _rhs) {
  return static_cast<::test::protocols::rights>(static_cast<uint32_t>(_lhs) ^
                                                static_cast<uint32_t>(_rhs));
}

constexpr inline ::test::protocols::rights& operator^=(
    ::test::protocols::rights& _lhs, ::test::protocols::rights _rhs) {
  _lhs = _lhs ^ _rhs;
  return _lhs;
}

constexpr inline ::test::protocols::rights operator~(
    ::test::protocols::rights _value) {
  return static_cast<::test::protocols::rights>(
      ~static_cast<uint32_t>(_value) &
      static_cast<uint32_t>(::test::protocols::rightsMask));
}

inline zx_status_t Clone(::test::protocols::rights value,
                         ::test::protocols::rights* result) {
  *result = value;
  return ZX_OK;
}

enum class obj_type : uint32_t {

  NONE = 0u,

  SOCKET = 14u,
};

inline zx_status_t Clone(::test::protocols::obj_type value,
                         ::test::protocols::obj_type* result) {
  *result = value;
  return ZX_OK;
}

class WithErrorSyntax_HandleInResult_Response;

class WithErrorSyntax_HandleInResult_Result;

#ifdef __Fuchsia__

class HandleRightsProtocol;
using HandleRightsProtocolHandle =
    ::fidl::InterfaceHandle<HandleRightsProtocol>;
#endif  // __Fuchsia__

class WithErrorSyntax_ResponseAsStruct_Response;

class WithErrorSyntax_ResponseAsStruct_Result;

class WithErrorSyntax_ErrorAsPrimitive_Response;

class WithErrorSyntax_ErrorAsPrimitive_Result;

class WithErrorSyntax_ErrorAsEnum_Response;

#ifdef __Fuchsia__

class WithAndWithoutRequestResponse;
using WithAndWithoutRequestResponseHandle =
    ::fidl::InterfaceHandle<WithAndWithoutRequestResponse>;
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class Transitional;
using TransitionalHandle = ::fidl::InterfaceHandle<Transitional>;
#endif  // __Fuchsia__

class TheUnion;

#ifdef __Fuchsia__

class MethodWithUnion;
using MethodWithUnionHandle = ::fidl::InterfaceHandle<MethodWithUnion>;
#endif  // __Fuchsia__

class ProtocolEnds;

#ifdef __Fuchsia__

class WithProtocolEnds;
using WithProtocolEndsHandle = ::fidl::InterfaceHandle<WithProtocolEnds>;
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class ManyParameters;
using ManyParametersHandle = ::fidl::InterfaceHandle<ManyParameters>;
#endif  // __Fuchsia__

enum class ErrorEnum : uint32_t {

  ERR_FOO = 1u,

  ERR_BAR = 2u,
};

inline zx_status_t Clone(::test::protocols::ErrorEnum value,
                         ::test::protocols::ErrorEnum* result) {
  *result = value;
  return ZX_OK;
}

class WithErrorSyntax_ErrorAsEnum_Result;

#ifdef __Fuchsia__

class WithErrorSyntax;
using WithErrorSyntaxHandle = ::fidl::InterfaceHandle<WithErrorSyntax>;
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class DiscoverableProtocol;
using DiscoverableProtocolHandle =
    ::fidl::InterfaceHandle<DiscoverableProtocol>;
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class ChannelProtocol;
using ChannelProtocolHandle = ::fidl::InterfaceHandle<ChannelProtocol>;
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class WithErrorSyntax_HandleInResult_Response final {
 public:
  static const fidl_type_t* FidlType;
  WithErrorSyntax_HandleInResult_Response() = default;
  explicit WithErrorSyntax_HandleInResult_Response(::zx::handle v)
      : h(std::move(v)) {}
  ::zx::handle ResultValue_() { return std::move(h); }
  explicit WithErrorSyntax_HandleInResult_Response(
      ::std::tuple<::zx::handle> _value_tuple) {
    std::tie(h) = std::move(_value_tuple);
  }
  operator ::std::tuple<::zx::handle>() && {
    return std::make_tuple(std::move(h));
  }

  ::zx::handle h{};

  static inline ::std::unique_ptr<WithErrorSyntax_HandleInResult_Response>
  New() {
    return ::std::make_unique<WithErrorSyntax_HandleInResult_Response>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder,
                     WithErrorSyntax_HandleInResult_Response* value,
                     size_t _offset);
  zx_status_t Clone(WithErrorSyntax_HandleInResult_Response* result) const;
};

inline zx_status_t Clone(
    const ::test::protocols::WithErrorSyntax_HandleInResult_Response& _value,
    ::test::protocols::WithErrorSyntax_HandleInResult_Response* _result) {
  return _value.Clone(_result);
}

using WithErrorSyntax_HandleInResult_ResponsePtr =
    ::std::unique_ptr<WithErrorSyntax_HandleInResult_Response>;
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class WithErrorSyntax_HandleInResult_Result final {
 public:
  static const fidl_type_t* FidlType;

  WithErrorSyntax_HandleInResult_Result();
  ~WithErrorSyntax_HandleInResult_Result();

  WithErrorSyntax_HandleInResult_Result(
      WithErrorSyntax_HandleInResult_Result&&);
  WithErrorSyntax_HandleInResult_Result& operator=(
      WithErrorSyntax_HandleInResult_Result&&);

  static WithErrorSyntax_HandleInResult_Result WithResponse(
      ::test::protocols::WithErrorSyntax_HandleInResult_Response&&);
  static WithErrorSyntax_HandleInResult_Result WithErr(uint32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<WithErrorSyntax_HandleInResult_Result> New() {
    return ::std::make_unique<WithErrorSyntax_HandleInResult_Result>();
  }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder,
                     WithErrorSyntax_HandleInResult_Result* value,
                     size_t offset);
  zx_status_t Clone(WithErrorSyntax_HandleInResult_Result* result) const;

  bool has_invalid_tag() const { return tag_ == Invalid; }

  bool is_response() const {
    return tag_ == ::test::protocols::WithErrorSyntax_HandleInResult_Result::
                       Tag::kResponse;
  }

  ::test::protocols::WithErrorSyntax_HandleInResult_Response& response() {
    EnsureStorageInitialized(
        ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::
            kResponse);
    return response_;
  }

  const ::test::protocols::WithErrorSyntax_HandleInResult_Response& response()
      const {
    ZX_ASSERT(is_response());
    return response_;
  }
  WithErrorSyntax_HandleInResult_Result& set_response(
      ::test::protocols::WithErrorSyntax_HandleInResult_Response value);

  bool is_err() const {
    return tag_ ==
           ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::kErr;
  }

  uint32_t& err() {
    EnsureStorageInitialized(
        ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::kErr);
    return err_;
  }

  const uint32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  WithErrorSyntax_HandleInResult_Result& set_err(uint32_t value);

  ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag Which() const {
    return ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal()
  // only when you need access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const { return tag_; }

  friend ::fidl::Equality<
      ::test::protocols::WithErrorSyntax_HandleInResult_Result>;
  WithErrorSyntax_HandleInResult_Result(
      fpromise::result<::zx::handle, uint32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::protocols::WithErrorSyntax_HandleInResult_Response{
          result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  WithErrorSyntax_HandleInResult_Result(
      fpromise::ok_result<::zx::handle>&& result)
      : WithErrorSyntax_HandleInResult_Result(
            fpromise::result<::zx::handle, uint32_t>(std::move(result))) {}
  WithErrorSyntax_HandleInResult_Result(
      fpromise::error_result<uint32_t>&& result)
      : WithErrorSyntax_HandleInResult_Result(
            fpromise::result<::zx::handle, uint32_t>(std::move(result))) {}
  operator fpromise::result<::zx::handle, uint32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::zx::handle> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(
      ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::Invalid);
  union {
    ::test::protocols::WithErrorSyntax_HandleInResult_Response response_;
    uint32_t err_;
  };
};

inline zx_status_t Clone(
    const ::test::protocols::WithErrorSyntax_HandleInResult_Result& value,
    ::test::protocols::WithErrorSyntax_HandleInResult_Result* result) {
  return value.Clone(result);
}

using WithErrorSyntax_HandleInResult_ResultPtr =
    ::std::unique_ptr<WithErrorSyntax_HandleInResult_Result>;
#endif  // __Fuchsia__

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodRequestTable;

}  // namespace _internal
class HandleRightsProtocol_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage NoResponseMethod(
      ::fidl::MessageEncoder* _encoder, ::zx::socket* h) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(4);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(4);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, h, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x3,
                     });

    } else {
      ::fidl::Encode(_encoder, h, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x3,
                     });
    }

    fidl_trace(
        DidHLCPPEncode,
        &::test::protocols::_internal::
            test_protocols_HandleRightsProtocolNoResponseMethodRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage ResponseMethod(
      ::fidl::MessageEncoder* _encoder, ::zx::socket* h) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(4);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(4);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, h, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x3,
                     });

    } else {
      ::fidl::Encode(_encoder, h, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x3,
                     });
    }

    fidl_trace(
        DidHLCPPEncode,
        &::test::protocols::_internal::
            test_protocols_HandleRightsProtocolResponseMethodRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolAnEventRequestTable;

}  // namespace _internal
class HandleRightsProtocol_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage ResponseMethod(
      ::fidl::MessageEncoder* _encoder, ::zx::socket* h) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(4);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(4);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, h, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x1,
                     });

    } else {
      ::fidl::Encode(_encoder, h, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x1,
                     });
    }

    fidl_trace(
        DidHLCPPEncode,
        &::test::protocols::_internal::
            test_protocols_HandleRightsProtocolResponseMethodTopResponseTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage AnEvent(::fidl::MessageEncoder* _encoder,
                                              ::zx::socket* h) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(4);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(4);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, h, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x3,
                     });

    } else {
      ::fidl::Encode(_encoder, h, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x3,
                     });
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_HandleRightsProtocolAnEventRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__

class WithErrorSyntax_ResponseAsStruct_Response final {
 public:
  static const fidl_type_t* FidlType;
  WithErrorSyntax_ResponseAsStruct_Response() = default;
  explicit WithErrorSyntax_ResponseAsStruct_Response(
      ::std::tuple<int64_t, int64_t, int64_t> _value_tuple) {
    std::tie(a, b, c) = std::move(_value_tuple);
  }
  operator ::std::tuple<int64_t, int64_t, int64_t>() && {
    return std::make_tuple(std::move(a), std::move(b), std::move(c));
  }

  int64_t a{};

  int64_t b{};

  int64_t c{};

  static inline ::std::unique_ptr<WithErrorSyntax_ResponseAsStruct_Response>
  New() {
    return ::std::make_unique<WithErrorSyntax_ResponseAsStruct_Response>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder,
                     WithErrorSyntax_ResponseAsStruct_Response* value,
                     size_t _offset);
  zx_status_t Clone(WithErrorSyntax_ResponseAsStruct_Response* result) const;
};

inline zx_status_t Clone(
    const ::test::protocols::WithErrorSyntax_ResponseAsStruct_Response& _value,
    ::test::protocols::WithErrorSyntax_ResponseAsStruct_Response* _result) {
  return _value.Clone(_result);
}

using WithErrorSyntax_ResponseAsStruct_ResponsePtr =
    ::std::unique_ptr<WithErrorSyntax_ResponseAsStruct_Response>;

class WithErrorSyntax_ResponseAsStruct_Result final {
 public:
  static const fidl_type_t* FidlType;

  WithErrorSyntax_ResponseAsStruct_Result();
  ~WithErrorSyntax_ResponseAsStruct_Result();

  WithErrorSyntax_ResponseAsStruct_Result(
      WithErrorSyntax_ResponseAsStruct_Result&&);
  WithErrorSyntax_ResponseAsStruct_Result& operator=(
      WithErrorSyntax_ResponseAsStruct_Result&&);

  static WithErrorSyntax_ResponseAsStruct_Result WithResponse(
      ::test::protocols::WithErrorSyntax_ResponseAsStruct_Response&&);
  static WithErrorSyntax_ResponseAsStruct_Result WithErr(uint32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<WithErrorSyntax_ResponseAsStruct_Result>
  New() {
    return ::std::make_unique<WithErrorSyntax_ResponseAsStruct_Result>();
  }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder,
                     WithErrorSyntax_ResponseAsStruct_Result* value,
                     size_t offset);
  zx_status_t Clone(WithErrorSyntax_ResponseAsStruct_Result* result) const;

  bool has_invalid_tag() const { return tag_ == Invalid; }

  bool is_response() const {
    return tag_ == ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::
                       Tag::kResponse;
  }

  ::test::protocols::WithErrorSyntax_ResponseAsStruct_Response& response() {
    EnsureStorageInitialized(
        ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
            kResponse);
    return response_;
  }

  const ::test::protocols::WithErrorSyntax_ResponseAsStruct_Response& response()
      const {
    ZX_ASSERT(is_response());
    return response_;
  }
  WithErrorSyntax_ResponseAsStruct_Result& set_response(
      ::test::protocols::WithErrorSyntax_ResponseAsStruct_Response value);

  bool is_err() const {
    return tag_ == ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::
                       Tag::kErr;
  }

  uint32_t& err() {
    EnsureStorageInitialized(
        ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::kErr);
    return err_;
  }

  const uint32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  WithErrorSyntax_ResponseAsStruct_Result& set_err(uint32_t value);

  ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag Which()
      const {
    return ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag(
        tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal()
  // only when you need access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const { return tag_; }

  friend ::fidl::Equality<
      ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result>;
  WithErrorSyntax_ResponseAsStruct_Result(
      fpromise::result<::std::tuple<int64_t, int64_t, int64_t>, uint32_t>&&
          result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::protocols::WithErrorSyntax_ResponseAsStruct_Response{
          result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  WithErrorSyntax_ResponseAsStruct_Result(
      fpromise::ok_result<::std::tuple<int64_t, int64_t, int64_t>>&& result)
      : WithErrorSyntax_ResponseAsStruct_Result(
            fpromise::result<::std::tuple<int64_t, int64_t, int64_t>, uint32_t>(
                std::move(result))) {}
  WithErrorSyntax_ResponseAsStruct_Result(
      fpromise::error_result<uint32_t>&& result)
      : WithErrorSyntax_ResponseAsStruct_Result(
            fpromise::result<::std::tuple<int64_t, int64_t, int64_t>, uint32_t>(
                std::move(result))) {}
  operator fpromise::result<::std::tuple<int64_t, int64_t, int64_t>,
                            uint32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok(std::move(response()));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(
      ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::Invalid);
  union {
    ::test::protocols::WithErrorSyntax_ResponseAsStruct_Response response_;
    uint32_t err_;
  };
};

inline zx_status_t Clone(
    const ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result& value,
    ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result* result) {
  return value.Clone(result);
}

using WithErrorSyntax_ResponseAsStruct_ResultPtr =
    ::std::unique_ptr<WithErrorSyntax_ResponseAsStruct_Result>;

class WithErrorSyntax_ErrorAsPrimitive_Response final {
 public:
  static const fidl_type_t* FidlType;
  WithErrorSyntax_ErrorAsPrimitive_Response() = default;
  explicit WithErrorSyntax_ErrorAsPrimitive_Response(uint8_t v)
      : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit WithErrorSyntax_ErrorAsPrimitive_Response(
      ::std::tuple<> _value_tuple) {}
  operator ::std::tuple<>() && { return std::make_tuple(); }

  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<WithErrorSyntax_ErrorAsPrimitive_Response>
  New() {
    return ::std::make_unique<WithErrorSyntax_ErrorAsPrimitive_Response>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder,
                     WithErrorSyntax_ErrorAsPrimitive_Response* value,
                     size_t _offset);
  zx_status_t Clone(WithErrorSyntax_ErrorAsPrimitive_Response* result) const;
};

inline zx_status_t Clone(
    const ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response& _value,
    ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response* _result) {
  return _value.Clone(_result);
}

using WithErrorSyntax_ErrorAsPrimitive_ResponsePtr =
    ::std::unique_ptr<WithErrorSyntax_ErrorAsPrimitive_Response>;

class WithErrorSyntax_ErrorAsPrimitive_Result final {
 public:
  static const fidl_type_t* FidlType;

  WithErrorSyntax_ErrorAsPrimitive_Result();
  ~WithErrorSyntax_ErrorAsPrimitive_Result();

  WithErrorSyntax_ErrorAsPrimitive_Result(
      WithErrorSyntax_ErrorAsPrimitive_Result&&);
  WithErrorSyntax_ErrorAsPrimitive_Result& operator=(
      WithErrorSyntax_ErrorAsPrimitive_Result&&);

  static WithErrorSyntax_ErrorAsPrimitive_Result WithResponse(
      ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response&&);
  static WithErrorSyntax_ErrorAsPrimitive_Result WithErr(uint32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<WithErrorSyntax_ErrorAsPrimitive_Result>
  New() {
    return ::std::make_unique<WithErrorSyntax_ErrorAsPrimitive_Result>();
  }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder,
                     WithErrorSyntax_ErrorAsPrimitive_Result* value,
                     size_t offset);
  zx_status_t Clone(WithErrorSyntax_ErrorAsPrimitive_Result* result) const;

  bool has_invalid_tag() const { return tag_ == Invalid; }

  bool is_response() const {
    return tag_ == ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::
                       Tag::kResponse;
  }

  ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response& response() {
    EnsureStorageInitialized(
        ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
            kResponse);
    return response_;
  }

  const ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response& response()
      const {
    ZX_ASSERT(is_response());
    return response_;
  }
  WithErrorSyntax_ErrorAsPrimitive_Result& set_response(
      ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response value);

  bool is_err() const {
    return tag_ == ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::
                       Tag::kErr;
  }

  uint32_t& err() {
    EnsureStorageInitialized(
        ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::kErr);
    return err_;
  }

  const uint32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  WithErrorSyntax_ErrorAsPrimitive_Result& set_err(uint32_t value);

  ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag Which()
      const {
    return ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag(
        tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal()
  // only when you need access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const { return tag_; }

  friend ::fidl::Equality<
      ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result>;
  WithErrorSyntax_ErrorAsPrimitive_Result(
      fpromise::result<void, uint32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(
          ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  WithErrorSyntax_ErrorAsPrimitive_Result(fpromise::ok_result<void>&& result)
      : WithErrorSyntax_ErrorAsPrimitive_Result(
            fpromise::result<void, uint32_t>(std::move(result))) {}
  WithErrorSyntax_ErrorAsPrimitive_Result(
      fpromise::error_result<uint32_t>&& result)
      : WithErrorSyntax_ErrorAsPrimitive_Result(
            fpromise::result<void, uint32_t>(std::move(result))) {}
  operator fpromise::result<void, uint32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(
      ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::Invalid);
  union {
    ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response response_;
    uint32_t err_;
  };
};

inline zx_status_t Clone(
    const ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result& value,
    ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result* result) {
  return value.Clone(result);
}

using WithErrorSyntax_ErrorAsPrimitive_ResultPtr =
    ::std::unique_ptr<WithErrorSyntax_ErrorAsPrimitive_Result>;

class WithErrorSyntax_ErrorAsEnum_Response final {
 public:
  static const fidl_type_t* FidlType;
  WithErrorSyntax_ErrorAsEnum_Response() = default;
  explicit WithErrorSyntax_ErrorAsEnum_Response(uint8_t v)
      : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit WithErrorSyntax_ErrorAsEnum_Response(::std::tuple<> _value_tuple) {}
  operator ::std::tuple<>() && { return std::make_tuple(); }

  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<WithErrorSyntax_ErrorAsEnum_Response> New() {
    return ::std::make_unique<WithErrorSyntax_ErrorAsEnum_Response>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder,
                     WithErrorSyntax_ErrorAsEnum_Response* value,
                     size_t _offset);
  zx_status_t Clone(WithErrorSyntax_ErrorAsEnum_Response* result) const;
};

inline zx_status_t Clone(
    const ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response& _value,
    ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response* _result) {
  return _value.Clone(_result);
}

using WithErrorSyntax_ErrorAsEnum_ResponsePtr =
    ::std::unique_ptr<WithErrorSyntax_ErrorAsEnum_Response>;

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;

}  // namespace _internal
class WithAndWithoutRequestResponse_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage NoRequestNoResponse(
      ::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage NoRequestEmptyResponse(
      ::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage NoRequestWithResponse(
      ::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage WithRequestNoResponse(
      ::fidl::MessageEncoder* _encoder, ::std::string* arg) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(16);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(16);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, arg, 0 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, arg, 0 + sizeof(fidl_message_header_t));
    }

    fidl_trace(
        DidHLCPPEncode,
        &::test::protocols::_internal::
            test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage WithRequestEmptyResponse(
      ::fidl::MessageEncoder* _encoder, ::std::string* arg) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(16);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(16);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, arg, 0 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, arg, 0 + sizeof(fidl_message_header_t));
    }

    fidl_trace(
        DidHLCPPEncode,
        &::test::protocols::_internal::
            test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage WithRequestWithResponse(
      ::fidl::MessageEncoder* _encoder, ::std::string* arg) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(16);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(16);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, arg, 0 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, arg, 0 + sizeof(fidl_message_header_t));
    }

    fidl_trace(
        DidHLCPPEncode,
        &::test::protocols::_internal::
            test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;

}  // namespace _internal
class WithAndWithoutRequestResponse_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage NoRequestEmptyResponse(
      ::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage NoRequestWithResponse(
      ::fidl::MessageEncoder* _encoder, ::std::string* ret) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(16);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(16);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, ret, 0 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, ret, 0 + sizeof(fidl_message_header_t));
    }

    fidl_trace(
        DidHLCPPEncode,
        &::test::protocols::_internal::
            test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage WithRequestEmptyResponse(
      ::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage WithRequestWithResponse(
      ::fidl::MessageEncoder* _encoder, ::std::string* ret) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(16);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(16);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, ret, 0 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, ret, 0 + sizeof(fidl_message_header_t));
    }

    fidl_trace(
        DidHLCPPEncode,
        &::test::protocols::_internal::
            test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage OnEmptyResponse(
      ::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage OnWithResponse(
      ::fidl::MessageEncoder* _encoder, ::std::string* ret) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(16);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(16);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, ret, 0 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, ret, 0 + sizeof(fidl_message_header_t));
    }

    fidl_trace(
        DidHLCPPEncode,
        &::test::protocols::_internal::
            test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalRequestRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalOneWayRequestTable;

}  // namespace _internal
class Transitional_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage Request(::fidl::MessageEncoder* _encoder,
                                              int64_t* x) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(8);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(8);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, x, 0 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, x, 0 + sizeof(fidl_message_header_t));
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_TransitionalRequestRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage OneWay(::fidl::MessageEncoder* _encoder,
                                             int64_t* x) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(8);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(8);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, x, 0 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, x, 0 + sizeof(fidl_message_header_t));
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_TransitionalOneWayRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalRequestTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalEventRequestTable;

}  // namespace _internal
class Transitional_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage Request(::fidl::MessageEncoder* _encoder,
                                              int64_t* y) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(8);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(8);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, y, 0 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, y, 0 + sizeof(fidl_message_header_t));
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_TransitionalRequestTopResponseTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage Event(::fidl::MessageEncoder* _encoder,
                                            int64_t* x) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(8);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(8);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, x, 0 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, x, 0 + sizeof(fidl_message_header_t));
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_TransitionalEventRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__

class TheUnion final {
 public:
  static const fidl_type_t* FidlType;

  TheUnion();
  ~TheUnion();

  TheUnion(TheUnion&&);
  TheUnion& operator=(TheUnion&&);

  static TheUnion WithV(uint32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
    kUnknown = 0,

    kV = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<TheUnion> New() {
    return ::std::make_unique<TheUnion>();
  }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, TheUnion* value, size_t offset);
  zx_status_t Clone(TheUnion* result) const;

  bool has_invalid_tag() const { return tag_ == Invalid; }

  bool is_v() const { return tag_ == ::test::protocols::TheUnion::Tag::kV; }

  uint32_t& v() {
    EnsureStorageInitialized(::test::protocols::TheUnion::Tag::kV);
    return v_;
  }

  const uint32_t& v() const {
    ZX_ASSERT(is_v());
    return v_;
  }
  TheUnion& set_v(uint32_t value);
  TheUnion& SetUnknownData(fidl_xunion_tag_t ordinal,
                           std::vector<uint8_t> bytes);

  ::test::protocols::TheUnion::Tag Which() const {
    switch (tag_) {
      case ::test::protocols::TheUnion::Tag::Invalid:
      case ::test::protocols::TheUnion::Tag::kV:
        return ::test::protocols::TheUnion::Tag(tag_);
      default:
        return ::test::protocols::TheUnion::Tag::kUnknown;
    }
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal()
  // only when you need access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const { return tag_; }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::protocols::TheUnion::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::protocols::TheUnion>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ =
      static_cast<fidl_xunion_tag_t>(::test::protocols::TheUnion::Tag::Invalid);
  union {
    uint32_t v_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::protocols::TheUnion& value,
                         ::test::protocols::TheUnion* result) {
  return value.Clone(result);
}

using TheUnionPtr = ::std::unique_ptr<TheUnion>;

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_MethodWithUnionUnionMethodRequestTable;

}  // namespace _internal
class MethodWithUnion_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage UnionMethod(
      ::fidl::MessageEncoder* _encoder, ::test::protocols::TheUnion* u) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(24);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(16);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, u, 0 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, u, 0 + sizeof(fidl_message_header_t));
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_MethodWithUnionUnionMethodRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};

class MethodWithUnion_ResponseEncoder {
 public:
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class ProtocolEnds final {
 public:
  static const fidl_type_t* FidlType;

  ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol> client{};

  ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol> server{};

  ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol> client_opt{};

  ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>
      server_opt{};

  static inline ::std::unique_ptr<ProtocolEnds> New() {
    return ::std::make_unique<ProtocolEnds>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, ProtocolEnds* value,
                     size_t _offset);
  zx_status_t Clone(ProtocolEnds* result) const;
};

inline zx_status_t Clone(const ::test::protocols::ProtocolEnds& _value,
                         ::test::protocols::ProtocolEnds* _result) {
  return _value.Clone(_result);
}

using ProtocolEndsPtr = ::std::unique_ptr<ProtocolEnds>;
#endif  // __Fuchsia__

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsRequestTable;

}  // namespace _internal
class WithProtocolEnds_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage ClientEnds(
      ::fidl::MessageEncoder* _encoder,
      ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>* in) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(4);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(4);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, in, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });

    } else {
      ::fidl::Encode(_encoder, in, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_WithProtocolEndsClientEndsRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage ServerEnds(
      ::fidl::MessageEncoder* _encoder,
      ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>* in) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(4);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(4);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, in, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });

    } else {
      ::fidl::Encode(_encoder, in, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_WithProtocolEndsServerEndsRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StructContainingEnds(
      ::fidl::MessageEncoder* _encoder, ::test::protocols::ProtocolEnds* in) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(16);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(16);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, in, 0 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, in, 0 + sizeof(fidl_message_header_t));
    }

    fidl_trace(
        DidHLCPPEncode,
        &::test::protocols::_internal::
            test_protocols_WithProtocolEndsStructContainingEndsRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;

}  // namespace _internal
class WithProtocolEnds_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage ClientEnds(
      ::fidl::MessageEncoder* _encoder,
      ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>* out) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(4);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(4);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, out, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });

    } else {
      ::fidl::Encode(_encoder, out, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_WithProtocolEndsClientEndsTopResponseTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage ServerEnds(
      ::fidl::MessageEncoder* _encoder,
      ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>* out) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(4);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(4);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, out, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });

    } else {
      ::fidl::Encode(_encoder, out, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_WithProtocolEndsServerEndsTopResponseTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StructContainingEnds(
      ::fidl::MessageEncoder* _encoder, ::test::protocols::ProtocolEnds* out) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(16);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(16);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, out, 0 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, out, 0 + sizeof(fidl_message_header_t));
    }

    fidl_trace(
        DidHLCPPEncode,
        &::test::protocols::_internal::
            test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_ManyParametersFifteenRequestTable;

}  // namespace _internal
class ManyParameters_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage Fifteen(::fidl::MessageEncoder* _encoder,
                                              bool* p1, bool* p2, bool* p3,
                                              bool* p4, bool* p5, bool* p6,
                                              bool* p7, bool* p8, bool* p9,
                                              bool* p10, bool* p11, bool* p12,
                                              bool* p13, bool* p14, bool* p15) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(15);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(15);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, p1, 0 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p2, 1 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p3, 2 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p4, 3 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p5, 4 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p6, 5 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p7, 6 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p8, 7 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p9, 8 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p10, 9 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p11, 10 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p12, 11 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p13, 12 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p14, 13 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p15, 14 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, p1, 0 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p2, 1 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p3, 2 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p4, 3 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p5, 4 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p6, 5 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p7, 6 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p8, 7 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p9, 8 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p10, 9 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p11, 10 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p12, 11 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p13, 12 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p14, 13 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, p15, 14 + sizeof(fidl_message_header_t));
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_ManyParametersFifteenRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};

class ManyParameters_ResponseEncoder {
 public:
};
#endif  // __Fuchsia__

class WithErrorSyntax_ErrorAsEnum_Result final {
 public:
  static const fidl_type_t* FidlType;

  WithErrorSyntax_ErrorAsEnum_Result();
  ~WithErrorSyntax_ErrorAsEnum_Result();

  WithErrorSyntax_ErrorAsEnum_Result(WithErrorSyntax_ErrorAsEnum_Result&&);
  WithErrorSyntax_ErrorAsEnum_Result& operator=(
      WithErrorSyntax_ErrorAsEnum_Result&&);

  static WithErrorSyntax_ErrorAsEnum_Result WithResponse(
      ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response&&);
  static WithErrorSyntax_ErrorAsEnum_Result WithErr(
      ::test::protocols::ErrorEnum&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<WithErrorSyntax_ErrorAsEnum_Result> New() {
    return ::std::make_unique<WithErrorSyntax_ErrorAsEnum_Result>();
  }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder,
                     WithErrorSyntax_ErrorAsEnum_Result* value, size_t offset);
  zx_status_t Clone(WithErrorSyntax_ErrorAsEnum_Result* result) const;

  bool has_invalid_tag() const { return tag_ == Invalid; }

  bool is_response() const {
    return tag_ == ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::
                       kResponse;
  }

  ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response& response() {
    EnsureStorageInitialized(
        ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kResponse);
    return response_;
  }

  const ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response& response()
      const {
    ZX_ASSERT(is_response());
    return response_;
  }
  WithErrorSyntax_ErrorAsEnum_Result& set_response(
      ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response value);

  bool is_err() const {
    return tag_ ==
           ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr;
  }

  ::test::protocols::ErrorEnum& err() {
    EnsureStorageInitialized(
        ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr);
    return err_;
  }

  const ::test::protocols::ErrorEnum& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  WithErrorSyntax_ErrorAsEnum_Result& set_err(
      ::test::protocols::ErrorEnum value);

  ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag Which() const {
    return ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal()
  // only when you need access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const { return tag_; }

  friend ::fidl::Equality<
      ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result>;
  WithErrorSyntax_ErrorAsEnum_Result(
      fpromise::result<void, ::test::protocols::ErrorEnum>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::protocols::WithErrorSyntax_ErrorAsEnum_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  WithErrorSyntax_ErrorAsEnum_Result(fpromise::ok_result<void>&& result)
      : WithErrorSyntax_ErrorAsEnum_Result(
            fpromise::result<void, ::test::protocols::ErrorEnum>(
                std::move(result))) {}
  WithErrorSyntax_ErrorAsEnum_Result(
      fpromise::error_result<::test::protocols::ErrorEnum>&& result)
      : WithErrorSyntax_ErrorAsEnum_Result(
            fpromise::result<void, ::test::protocols::ErrorEnum>(
                std::move(result))) {}
  operator fpromise::result<void, ::test::protocols::ErrorEnum>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(
      ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::Invalid);
  union {
    ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response response_;
    ::test::protocols::ErrorEnum err_;
  };
};

inline zx_status_t Clone(
    const ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result& value,
    ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result* result) {
  return value.Clone(result);
}

using WithErrorSyntax_ErrorAsEnum_ResultPtr =
    ::std::unique_ptr<WithErrorSyntax_ErrorAsEnum_Result>;

#ifdef __Fuchsia__

class WithErrorSyntax_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage ResponseAsStruct(
      ::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage ErrorAsPrimitive(
      ::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage ErrorAsEnum(
      ::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage HandleInResult(
      ::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
};
namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;

}  // namespace _internal
class WithErrorSyntax_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage ResponseAsStruct(
      ::fidl::MessageEncoder* _encoder,
      ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result* result) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(24);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(16);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    }

    fidl_trace(
        DidHLCPPEncode,
        &::test::protocols::_internal::
            test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage ErrorAsPrimitive(
      ::fidl::MessageEncoder* _encoder,
      ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result* result) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(24);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(16);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    }

    fidl_trace(
        DidHLCPPEncode,
        &::test::protocols::_internal::
            test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage ErrorAsEnum(
      ::fidl::MessageEncoder* _encoder,
      ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result* result) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(24);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(16);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage HandleInResult(
      ::fidl::MessageEncoder* _encoder,
      ::test::protocols::WithErrorSyntax_HandleInResult_Result* result) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(24);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(16);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_WithErrorSyntaxHandleInResultTopResponseTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class DiscoverableProtocol_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage Method(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
};

class DiscoverableProtocol_ResponseEncoder {
 public:
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodARequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodBRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolTakeHandleRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketRequestTable;

}  // namespace _internal
class ChannelProtocol_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage MethodA(::fidl::MessageEncoder* _encoder,
                                              int64_t* a, int64_t* b) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(16);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(16);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, a, 0 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, b, 8 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, a, 0 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, b, 8 + sizeof(fidl_message_header_t));
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_ChannelProtocolMethodARequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage MethodB(::fidl::MessageEncoder* _encoder,
                                              int64_t* a, int64_t* b) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(16);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(16);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, a, 0 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, b, 8 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, a, 0 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, b, 8 + sizeof(fidl_message_header_t));
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_ChannelProtocolMethodBRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TakeHandle(
      ::fidl::MessageEncoder* _encoder, ::zx::handle* h) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(4);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(4);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, h, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_NONE,
                         .rights = 0x80000000,
                     });

    } else {
      ::fidl::Encode(_encoder, h, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_NONE,
                         .rights = 0x80000000,
                     });
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_ChannelProtocolTakeHandleRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage MutateSocket(
      ::fidl::MessageEncoder* _encoder, ::zx::socket* a) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(4);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(4);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, a, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x80000000,
                     });

    } else {
      ::fidl::Encode(_encoder, a, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x80000000,
                     });
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_ChannelProtocolMutateSocketRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolEventARequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodBTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketTopResponseTable;

}  // namespace _internal
class ChannelProtocol_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage EventA(::fidl::MessageEncoder* _encoder,
                                             int64_t* a, int64_t* b) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(16);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(16);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, a, 0 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, b, 8 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, a, 0 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, b, 8 + sizeof(fidl_message_header_t));
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_ChannelProtocolEventARequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage MethodB(::fidl::MessageEncoder* _encoder,
                                              int64_t* result) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(8);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(8);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_ChannelProtocolMethodBTopResponseTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TakeHandle(
      ::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage MutateSocket(
      ::fidl::MessageEncoder* _encoder, ::zx::socket* b) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(4);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(4);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, b, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x80000000,
                     });

    } else {
      ::fidl::Encode(_encoder, b, 0 + sizeof(fidl_message_header_t),
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x80000000,
                     });
    }

    fidl_trace(DidHLCPPEncode,
               &::test::protocols::_internal::
                   test_protocols_ChannelProtocolMutateSocketTopResponseTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__

}  // namespace protocols
}  // namespace test
namespace fidl {
template <>
struct CodingTraits<::test::protocols::rights> {
  static constexpr size_t inline_size_old = sizeof(::test::protocols::rights);
  static constexpr size_t inline_size_v1_no_ee =
      sizeof(::test::protocols::rights);
  static constexpr size_t inline_size_v2 = sizeof(::test::protocols::rights);
  static void Encode(
      Encoder* encoder, ::test::protocols::rights* value, size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::protocols::rights* value,
                     size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::protocols::rights>(underlying);
  }
};

inline zx_status_t Clone(::test::protocols::rights value,
                         ::test::protocols::rights* result) {
  return ::test::protocols::Clone(value, result);
}

template <>
struct Equality<::test::protocols::rights> {
  bool operator()(const ::test::protocols::rights& _lhs,
                  const ::test::protocols::rights& _rhs) const {
    uint32_t _lhs_underlying = static_cast<uint32_t>(_lhs);
    uint32_t _rhs_underlying = static_cast<uint32_t>(_rhs);
    return ::fidl::Equals(_lhs_underlying, _rhs_underlying);
  }
};
template <>
struct CodingTraits<::test::protocols::obj_type> {
  static constexpr size_t inline_size_old = sizeof(::test::protocols::obj_type);
  static constexpr size_t inline_size_v1_no_ee =
      sizeof(::test::protocols::obj_type);
  static constexpr size_t inline_size_v2 = sizeof(::test::protocols::obj_type);
  static void Encode(
      Encoder* encoder, ::test::protocols::obj_type* value, size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::protocols::obj_type* value,
                     size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::protocols::obj_type>(underlying);
  }
};

inline zx_status_t Clone(::test::protocols::obj_type value,
                         ::test::protocols::obj_type* result) {
  return ::test::protocols::Clone(value, result);
}
template <>
struct Equality<::test::protocols::obj_type> {
  bool operator()(const ::test::protocols::obj_type& _lhs,
                  const ::test::protocols::obj_type& _rhs) const {
    return _lhs == _rhs;
  }
};

#ifdef __Fuchsia__

template <>
struct CodingTraits<::test::protocols::WithErrorSyntax_HandleInResult_Response>
    : public EncodableCodingTraits<
          ::test::protocols::WithErrorSyntax_HandleInResult_Response, 4, 4> {};

template <>
struct IsMemcpyCompatible<
    ::test::protocols::WithErrorSyntax_HandleInResult_Response>
    : public internal::BoolConstant<
          !HasPadding<::test::protocols::
                          WithErrorSyntax_HandleInResult_Response>::value &&
          IsMemcpyCompatible<::zx::handle>::value> {};

inline zx_status_t Clone(
    const ::test::protocols::WithErrorSyntax_HandleInResult_Response& value,
    ::test::protocols::WithErrorSyntax_HandleInResult_Response* result) {
  return ::test::protocols::Clone(value, result);
}

template <>
struct Equality<::test::protocols::WithErrorSyntax_HandleInResult_Response> {
  bool operator()(
      const ::test::protocols::WithErrorSyntax_HandleInResult_Response& _lhs,
      const ::test::protocols::WithErrorSyntax_HandleInResult_Response& _rhs)
      const {
    if (!::fidl::Equals(_lhs.h, _rhs.h)) {
      return false;
    }
    return true;
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct IsFidlXUnion<::test::protocols::WithErrorSyntax_HandleInResult_Result>
    : public std::true_type {};

template <>
struct CodingTraits<::test::protocols::WithErrorSyntax_HandleInResult_Result>
    : public EncodableCodingTraits<
          ::test::protocols::WithErrorSyntax_HandleInResult_Result, 24, 16> {};

template <>
struct CodingTraits<
    std::unique_ptr<::test::protocols::WithErrorSyntax_HandleInResult_Result>> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(
      Encoder* encoder,
      std::unique_ptr<::test::protocols::WithErrorSyntax_HandleInResult_Result>*
          value,
      size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(
      Decoder* _decoder,
      std::unique_ptr<::test::protocols::WithErrorSyntax_HandleInResult_Result>*
          value,
      size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::protocols::WithErrorSyntax_HandleInResult_Result);

    ::test::protocols::WithErrorSyntax_HandleInResult_Result::Decode(
        _decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(
    const ::test::protocols::WithErrorSyntax_HandleInResult_Result& value,
    ::test::protocols::WithErrorSyntax_HandleInResult_Result* result) {
  return ::test::protocols::Clone(value, result);
}

template <>
struct Equality<::test::protocols::WithErrorSyntax_HandleInResult_Result> {
  bool operator()(
      const ::test::protocols::WithErrorSyntax_HandleInResult_Result& _lhs,
      const ::test::protocols::WithErrorSyntax_HandleInResult_Result& _rhs)
      const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(
          ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::
              Invalid):
        return true;
      case ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::
          kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};
#endif  // __Fuchsia__

template <>
struct CodingTraits<
    ::test::protocols::WithErrorSyntax_ResponseAsStruct_Response>
    : public EncodableCodingTraits<
          ::test::protocols::WithErrorSyntax_ResponseAsStruct_Response, 24,
          24> {};

template <>
struct IsMemcpyCompatible<
    ::test::protocols::WithErrorSyntax_ResponseAsStruct_Response>
    : public internal::BoolConstant<
          !HasPadding<::test::protocols::
                          WithErrorSyntax_ResponseAsStruct_Response>::value &&
          IsMemcpyCompatible<int64_t>::value> {};

inline zx_status_t Clone(
    const ::test::protocols::WithErrorSyntax_ResponseAsStruct_Response& value,
    ::test::protocols::WithErrorSyntax_ResponseAsStruct_Response* result) {
  return ::test::protocols::Clone(value, result);
}

template <>
struct Equality<::test::protocols::WithErrorSyntax_ResponseAsStruct_Response> {
  bool operator()(
      const ::test::protocols::WithErrorSyntax_ResponseAsStruct_Response& _lhs,
      const ::test::protocols::WithErrorSyntax_ResponseAsStruct_Response& _rhs)
      const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.c, _rhs.c)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::protocols::WithErrorSyntax_ResponseAsStruct_Result>
    : public std::true_type {};

template <>
struct CodingTraits<::test::protocols::WithErrorSyntax_ResponseAsStruct_Result>
    : public EncodableCodingTraits<
          ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result, 24, 16> {
};

template <>
struct CodingTraits<std::unique_ptr<
    ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result>> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(
      Encoder* encoder,
      std::unique_ptr<
          ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result>* value,
      size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(
      Decoder* _decoder,
      std::unique_ptr<
          ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result>* value,
      size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(
        new ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result);

    ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Decode(
        _decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(
    const ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result& value,
    ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result* result) {
  return ::test::protocols::Clone(value, result);
}

template <>
struct Equality<::test::protocols::WithErrorSyntax_ResponseAsStruct_Result> {
  bool operator()(
      const ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result& _lhs,
      const ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result& _rhs)
      const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(
          ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
              Invalid):
        return true;
      case ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
          kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
          kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<
    ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response>
    : public EncodableCodingTraits<
          ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response, 1, 1> {
};

template <>
struct IsMemcpyCompatible<
    ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response>
    : public internal::BoolConstant<
          !HasPadding<::test::protocols::
                          WithErrorSyntax_ErrorAsPrimitive_Response>::value &&
          IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(
    const ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response& value,
    ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response* result) {
  return ::test::protocols::Clone(value, result);
}

template <>
struct Equality<::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response> {
  bool operator()(
      const ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response& _lhs,
      const ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response& _rhs)
      const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result>
    : public std::true_type {};

template <>
struct CodingTraits<::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result>
    : public EncodableCodingTraits<
          ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result, 24, 16> {
};

template <>
struct CodingTraits<std::unique_ptr<
    ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result>> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(
      Encoder* encoder,
      std::unique_ptr<
          ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result>* value,
      size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(
      Decoder* _decoder,
      std::unique_ptr<
          ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result>* value,
      size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(
        new ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result);

    ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Decode(
        _decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(
    const ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result& value,
    ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result* result) {
  return ::test::protocols::Clone(value, result);
}

template <>
struct Equality<::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result> {
  bool operator()(
      const ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result& _lhs,
      const ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result& _rhs)
      const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(
          ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
              Invalid):
        return true;
      case ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
          kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
          kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<::test::protocols::WithErrorSyntax_ErrorAsEnum_Response>
    : public EncodableCodingTraits<
          ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response, 1, 1> {};

template <>
struct IsMemcpyCompatible<
    ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response>
    : public internal::BoolConstant<
          !HasPadding<
              ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response>::value &&
          IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(
    const ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response& value,
    ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response* result) {
  return ::test::protocols::Clone(value, result);
}

template <>
struct Equality<::test::protocols::WithErrorSyntax_ErrorAsEnum_Response> {
  bool operator()(
      const ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response& _lhs,
      const ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response& _rhs)
      const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::protocols::TheUnion> : public std::true_type {};

template <>
struct CodingTraits<::test::protocols::TheUnion>
    : public EncodableCodingTraits<::test::protocols::TheUnion, 24, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::protocols::TheUnion>> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(
      Encoder* encoder, std::unique_ptr<::test::protocols::TheUnion>* value,
      size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder,
                     std::unique_ptr<::test::protocols::TheUnion>* value,
                     size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::protocols::TheUnion);

    ::test::protocols::TheUnion::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::protocols::TheUnion& value,
                         ::test::protocols::TheUnion* result) {
  return ::test::protocols::Clone(value, result);
}

template <>
struct Equality<::test::protocols::TheUnion> {
  bool operator()(const ::test::protocols::TheUnion& _lhs,
                  const ::test::protocols::TheUnion& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(
          ::test::protocols::TheUnion::Tag::Invalid):
        return true;
      case ::test::protocols::TheUnion::Tag::kV:
        return ::fidl::Equals(_lhs.v_, _rhs.v_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
    }
  }
};
#ifdef __Fuchsia__

template <>
struct CodingTraits<::test::protocols::ProtocolEnds>
    : public EncodableCodingTraits<::test::protocols::ProtocolEnds, 16, 16> {};

template <>
struct IsMemcpyCompatible<::test::protocols::ProtocolEnds>
    : public internal::BoolConstant<
          !HasPadding<::test::protocols::ProtocolEnds>::value &&
          IsMemcpyCompatible<::fidl::InterfaceHandle<
              ::test::protocols::DiscoverableProtocol>>::value &&
          IsMemcpyCompatible<::fidl::InterfaceRequest<
              ::test::protocols::DiscoverableProtocol>>::value> {};

inline zx_status_t Clone(const ::test::protocols::ProtocolEnds& value,
                         ::test::protocols::ProtocolEnds* result) {
  return ::test::protocols::Clone(value, result);
}

template <>
struct Equality<::test::protocols::ProtocolEnds> {
  bool operator()(const ::test::protocols::ProtocolEnds& _lhs,
                  const ::test::protocols::ProtocolEnds& _rhs) const {
    if (!::fidl::Equals(_lhs.client, _rhs.client)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.server, _rhs.server)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.client_opt, _rhs.client_opt)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.server_opt, _rhs.server_opt)) {
      return false;
    }
    return true;
  }
};
#endif  // __Fuchsia__

template <>
struct CodingTraits<::test::protocols::ErrorEnum> {
  static constexpr size_t inline_size_old =
      sizeof(::test::protocols::ErrorEnum);
  static constexpr size_t inline_size_v1_no_ee =
      sizeof(::test::protocols::ErrorEnum);
  static constexpr size_t inline_size_v2 = sizeof(::test::protocols::ErrorEnum);
  static void Encode(
      Encoder* encoder, ::test::protocols::ErrorEnum* value, size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::protocols::ErrorEnum* value,
                     size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::protocols::ErrorEnum>(underlying);
  }
};

inline zx_status_t Clone(::test::protocols::ErrorEnum value,
                         ::test::protocols::ErrorEnum* result) {
  return ::test::protocols::Clone(value, result);
}
template <>
struct Equality<::test::protocols::ErrorEnum> {
  bool operator()(const ::test::protocols::ErrorEnum& _lhs,
                  const ::test::protocols::ErrorEnum& _rhs) const {
    return _lhs == _rhs;
  }
};

template <>
struct IsFidlXUnion<::test::protocols::WithErrorSyntax_ErrorAsEnum_Result>
    : public std::true_type {};

template <>
struct CodingTraits<::test::protocols::WithErrorSyntax_ErrorAsEnum_Result>
    : public EncodableCodingTraits<
          ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result, 24, 16> {};

template <>
struct CodingTraits<
    std::unique_ptr<::test::protocols::WithErrorSyntax_ErrorAsEnum_Result>> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(
      Encoder* encoder,
      std::unique_ptr<::test::protocols::WithErrorSyntax_ErrorAsEnum_Result>*
          value,
      size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(
      Decoder* _decoder,
      std::unique_ptr<::test::protocols::WithErrorSyntax_ErrorAsEnum_Result>*
          value,
      size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result);

    ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Decode(
        _decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(
    const ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result& value,
    ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result* result) {
  return ::test::protocols::Clone(value, result);
}

template <>
struct Equality<::test::protocols::WithErrorSyntax_ErrorAsEnum_Result> {
  bool operator()(
      const ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result& _lhs,
      const ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(
          ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::Invalid):
        return true;
      case ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::
          kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};

//
// Proxies and stubs declarations
//
}  // namespace fidl
namespace test {
namespace protocols {
#ifdef __Fuchsia__

using HandleRightsProtocolPtr = ::fidl::InterfacePtr<HandleRightsProtocol>;
class HandleRightsProtocol_Proxy;
class HandleRightsProtocol_Stub;
class HandleRightsProtocol_EventSender;
class HandleRightsProtocol_Sync;
using HandleRightsProtocolSyncPtr =
    ::fidl::SynchronousInterfacePtr<HandleRightsProtocol>;
class HandleRightsProtocol_SyncProxy;

namespace internal {
constexpr uint64_t kHandleRightsProtocol_NoResponseMethod_Ordinal =
    0x10078afd320d2bfdlu;
constexpr uint64_t kHandleRightsProtocol_ResponseMethod_Ordinal =
    0x52a8f194ac143547lu;
constexpr uint64_t kHandleRightsProtocol_AnEvent_Ordinal = 0x69dad41418eb133lu;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

using WithAndWithoutRequestResponsePtr =
    ::fidl::InterfacePtr<WithAndWithoutRequestResponse>;
class WithAndWithoutRequestResponse_Proxy;
class WithAndWithoutRequestResponse_Stub;
class WithAndWithoutRequestResponse_EventSender;
class WithAndWithoutRequestResponse_Sync;
using WithAndWithoutRequestResponseSyncPtr =
    ::fidl::SynchronousInterfacePtr<WithAndWithoutRequestResponse>;
class WithAndWithoutRequestResponse_SyncProxy;

namespace internal {
constexpr uint64_t kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal =
    0x4b212a6c8c5f7bablu;
constexpr uint64_t
    kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal =
        0x16a329d17f458668lu;
constexpr uint64_t
    kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal =
        0x7d6b2fcf0e2a65bdlu;
constexpr uint64_t
    kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal =
        0x65ab625138c50a77lu;
constexpr uint64_t
    kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal =
        0x27ee4d2bd405df5flu;
constexpr uint64_t
    kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal =
        0x590e91945d58f5b1lu;
constexpr uint64_t kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal =
    0x4ae85a2b8d7c2e56lu;
constexpr uint64_t kWithAndWithoutRequestResponse_OnWithResponse_Ordinal =
    0x50a6f21a322f31a8lu;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

using TransitionalPtr = ::fidl::InterfacePtr<Transitional>;
class Transitional_Proxy;
class Transitional_Stub;
class Transitional_EventSender;
class Transitional_Sync;
using TransitionalSyncPtr = ::fidl::SynchronousInterfacePtr<Transitional>;
class Transitional_SyncProxy;

namespace internal {
constexpr uint64_t kTransitional_Request_Ordinal = 0x512cc1ba467fef08lu;
constexpr uint64_t kTransitional_OneWay_Ordinal = 0x3c2ee8512dc7f7e7lu;
constexpr uint64_t kTransitional_Event_Ordinal = 0x76113c4b4d484841lu;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

using MethodWithUnionPtr = ::fidl::InterfacePtr<MethodWithUnion>;
class MethodWithUnion_Proxy;
class MethodWithUnion_Stub;
class MethodWithUnion_EventSender;
class MethodWithUnion_Sync;
using MethodWithUnionSyncPtr = ::fidl::SynchronousInterfacePtr<MethodWithUnion>;
class MethodWithUnion_SyncProxy;

namespace internal {
constexpr uint64_t kMethodWithUnion_UnionMethod_Ordinal = 0x393e7f5b2b821218lu;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

using WithProtocolEndsPtr = ::fidl::InterfacePtr<WithProtocolEnds>;
class WithProtocolEnds_Proxy;
class WithProtocolEnds_Stub;
class WithProtocolEnds_EventSender;
class WithProtocolEnds_Sync;
using WithProtocolEndsSyncPtr =
    ::fidl::SynchronousInterfacePtr<WithProtocolEnds>;
class WithProtocolEnds_SyncProxy;

namespace internal {
constexpr uint64_t kWithProtocolEnds_ClientEnds_Ordinal = 0x51780563edb15042lu;
constexpr uint64_t kWithProtocolEnds_ServerEnds_Ordinal = 0x70a02c2ba2228a33lu;
constexpr uint64_t kWithProtocolEnds_StructContainingEnds_Ordinal =
    0x3893f0baad26f5d5lu;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

using ManyParametersPtr = ::fidl::InterfacePtr<ManyParameters>;
class ManyParameters_Proxy;
class ManyParameters_Stub;
class ManyParameters_EventSender;
class ManyParameters_Sync;
using ManyParametersSyncPtr = ::fidl::SynchronousInterfacePtr<ManyParameters>;
class ManyParameters_SyncProxy;

namespace internal {
constexpr uint64_t kManyParameters_Fifteen_Ordinal = 0x59233bcecd338967lu;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

using WithErrorSyntaxPtr = ::fidl::InterfacePtr<WithErrorSyntax>;
class WithErrorSyntax_Proxy;
class WithErrorSyntax_Stub;
class WithErrorSyntax_EventSender;
class WithErrorSyntax_Sync;
using WithErrorSyntaxSyncPtr = ::fidl::SynchronousInterfacePtr<WithErrorSyntax>;
class WithErrorSyntax_SyncProxy;

namespace internal {
constexpr uint64_t kWithErrorSyntax_ResponseAsStruct_Ordinal =
    0x3b902a6d8d24693lu;
constexpr uint64_t kWithErrorSyntax_ErrorAsPrimitive_Ordinal =
    0x602fd6bd920135e7lu;
constexpr uint64_t kWithErrorSyntax_ErrorAsEnum_Ordinal = 0x4c371e1673212f43lu;
constexpr uint64_t kWithErrorSyntax_HandleInResult_Ordinal =
    0x13092c5b835b0cbflu;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

using DiscoverableProtocolPtr = ::fidl::InterfacePtr<DiscoverableProtocol>;
class DiscoverableProtocol_Proxy;
class DiscoverableProtocol_Stub;
class DiscoverableProtocol_EventSender;
class DiscoverableProtocol_Sync;
using DiscoverableProtocolSyncPtr =
    ::fidl::SynchronousInterfacePtr<DiscoverableProtocol>;
class DiscoverableProtocol_SyncProxy;

namespace internal {
constexpr uint64_t kDiscoverableProtocol_Method_Ordinal = 0x2ff5ba3a2bd170eblu;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

using ChannelProtocolPtr = ::fidl::InterfacePtr<ChannelProtocol>;
class ChannelProtocol_Proxy;
class ChannelProtocol_Stub;
class ChannelProtocol_EventSender;
class ChannelProtocol_Sync;
using ChannelProtocolSyncPtr = ::fidl::SynchronousInterfacePtr<ChannelProtocol>;
class ChannelProtocol_SyncProxy;

namespace internal {
constexpr uint64_t kChannelProtocol_MethodA_Ordinal = 0x2bc8d7d32bc66ba2lu;
constexpr uint64_t kChannelProtocol_EventA_Ordinal = 0x1ed0a220297145celu;
constexpr uint64_t kChannelProtocol_MethodB_Ordinal = 0x7b8dd3d6c741c9c6lu;
constexpr uint64_t kChannelProtocol_TakeHandle_Ordinal = 0x836fa31201a0a65lu;
constexpr uint64_t kChannelProtocol_MutateSocket_Ordinal = 0x66dbcccc06f7f14flu;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class HandleRightsProtocol {
 public:
  using Proxy_ = ::test::protocols::HandleRightsProtocol_Proxy;
  using Stub_ = ::test::protocols::HandleRightsProtocol_Stub;
  using EventSender_ = ::test::protocols::HandleRightsProtocol_EventSender;
  using Sync_ = ::test::protocols::HandleRightsProtocol_Sync;
  virtual ~HandleRightsProtocol();

  virtual void NoResponseMethod(::zx::socket h) = 0;
  using ResponseMethodCallback = fit::function<void(::zx::socket)>;

  virtual void ResponseMethod(::zx::socket h,
                              ResponseMethodCallback callback) = 0;
  using AnEventCallback = fit::function<void(::zx::socket)>;
};

class HandleRightsProtocol_RequestDecoder {
 public:
  HandleRightsProtocol_RequestDecoder() = default;
  virtual ~HandleRightsProtocol_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void NoResponseMethod(::zx::socket h) = 0;
  virtual void ResponseMethod(::zx::socket h) = 0;
};

class HandleRightsProtocol_ResponseDecoder {
 public:
  HandleRightsProtocol_ResponseDecoder() = default;
  virtual ~HandleRightsProtocol_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void ResponseMethod(::zx::socket h) = 0;
  virtual void AnEvent(::zx::socket h) = 0;
};

class HandleRightsProtocol_EventSender {
 public:
  virtual ~HandleRightsProtocol_EventSender();
  virtual void AnEvent(::zx::socket h) = 0;
};

class HandleRightsProtocol_Sync {
 public:
  using Proxy_ = ::test::protocols::HandleRightsProtocol_SyncProxy;
  virtual ~HandleRightsProtocol_Sync();
  virtual zx_status_t NoResponseMethod(::zx::socket h) = 0;
  virtual zx_status_t ResponseMethod(::zx::socket h, ::zx::socket* out_h) = 0;
};

class HandleRightsProtocol_Proxy final : public ::fidl::internal::Proxy,
                                         public HandleRightsProtocol {
 public:
  explicit HandleRightsProtocol_Proxy(
      ::fidl::internal::ProxyController* controller);
  ~HandleRightsProtocol_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  // cts-coverage-fidl-name:test.protocols/HandleRightsProtocol.NoResponseMethod
  void NoResponseMethod(::zx::socket h) override;
  // cts-coverage-fidl-name:test.protocols/HandleRightsProtocol.ResponseMethod
  void ResponseMethod(::zx::socket h, ResponseMethodCallback callback) override;
  AnEventCallback AnEvent;

 private:
  HandleRightsProtocol_Proxy(
      const ::test::protocols::HandleRightsProtocol_Proxy&) = delete;
  HandleRightsProtocol_Proxy& operator=(
      const ::test::protocols::HandleRightsProtocol_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class HandleRightsProtocol_Stub final
    : public ::fidl::internal::Stub,
      public ::test::protocols::HandleRightsProtocol_EventSender {
 public:
  typedef class ::test::protocols::HandleRightsProtocol
      HandleRightsProtocol_clazz;
  explicit HandleRightsProtocol_Stub(
      ::test::protocols::HandleRightsProtocol_Stub::HandleRightsProtocol_clazz*
          impl);
  ~HandleRightsProtocol_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;
  void AnEvent(::zx::socket h) override;

 private:
  ::test::protocols::HandleRightsProtocol_Stub::HandleRightsProtocol_clazz*
      impl_;
};

class HandleRightsProtocol_SyncProxy
    : public ::test::protocols::HandleRightsProtocol_Sync {
 public:
  explicit HandleRightsProtocol_SyncProxy(::zx::channel channel);
  ~HandleRightsProtocol_SyncProxy() override;
  // cts-coverage-fidl-name:test.protocols/HandleRightsProtocol.NoResponseMethod
  zx_status_t NoResponseMethod(::zx::socket h) override;
  // cts-coverage-fidl-name:test.protocols/HandleRightsProtocol.ResponseMethod
  zx_status_t ResponseMethod(::zx::socket h, ::zx::socket* out_h) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<HandleRightsProtocol>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class WithAndWithoutRequestResponse {
 public:
  using Proxy_ = ::test::protocols::WithAndWithoutRequestResponse_Proxy;
  using Stub_ = ::test::protocols::WithAndWithoutRequestResponse_Stub;
  using EventSender_ =
      ::test::protocols::WithAndWithoutRequestResponse_EventSender;
  using Sync_ = ::test::protocols::WithAndWithoutRequestResponse_Sync;
  virtual ~WithAndWithoutRequestResponse();

  virtual void NoRequestNoResponse() = 0;
  using NoRequestEmptyResponseCallback = fit::function<void()>;

  virtual void NoRequestEmptyResponse(
      NoRequestEmptyResponseCallback callback) = 0;
  using NoRequestWithResponseCallback = fit::function<void(::std::string)>;

  virtual void NoRequestWithResponse(
      NoRequestWithResponseCallback callback) = 0;

  virtual void WithRequestNoResponse(::std::string arg) = 0;
  using WithRequestEmptyResponseCallback = fit::function<void()>;

  virtual void WithRequestEmptyResponse(
      ::std::string arg, WithRequestEmptyResponseCallback callback) = 0;
  using WithRequestWithResponseCallback = fit::function<void(::std::string)>;

  virtual void WithRequestWithResponse(
      ::std::string arg, WithRequestWithResponseCallback callback) = 0;
  using OnEmptyResponseCallback = fit::function<void()>;
  using OnWithResponseCallback = fit::function<void(::std::string)>;
};

class WithAndWithoutRequestResponse_RequestDecoder {
 public:
  WithAndWithoutRequestResponse_RequestDecoder() = default;
  virtual ~WithAndWithoutRequestResponse_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void NoRequestNoResponse() = 0;
  virtual void NoRequestEmptyResponse() = 0;
  virtual void NoRequestWithResponse() = 0;
  virtual void WithRequestNoResponse(::std::string arg) = 0;
  virtual void WithRequestEmptyResponse(::std::string arg) = 0;
  virtual void WithRequestWithResponse(::std::string arg) = 0;
};

class WithAndWithoutRequestResponse_ResponseDecoder {
 public:
  WithAndWithoutRequestResponse_ResponseDecoder() = default;
  virtual ~WithAndWithoutRequestResponse_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void NoRequestEmptyResponse() = 0;
  virtual void NoRequestWithResponse(::std::string ret) = 0;
  virtual void WithRequestEmptyResponse() = 0;
  virtual void WithRequestWithResponse(::std::string ret) = 0;
  virtual void OnEmptyResponse() = 0;
  virtual void OnWithResponse(::std::string ret) = 0;
};

class WithAndWithoutRequestResponse_EventSender {
 public:
  virtual ~WithAndWithoutRequestResponse_EventSender();
  virtual void OnEmptyResponse() = 0;
  virtual void OnWithResponse(::std::string ret) = 0;
};

class WithAndWithoutRequestResponse_Sync {
 public:
  using Proxy_ = ::test::protocols::WithAndWithoutRequestResponse_SyncProxy;
  virtual ~WithAndWithoutRequestResponse_Sync();
  virtual zx_status_t NoRequestNoResponse() = 0;
  virtual zx_status_t NoRequestEmptyResponse() = 0;
  virtual zx_status_t NoRequestWithResponse(::std::string* out_ret) = 0;
  virtual zx_status_t WithRequestNoResponse(::std::string arg) = 0;
  virtual zx_status_t WithRequestEmptyResponse(::std::string arg) = 0;
  virtual zx_status_t WithRequestWithResponse(::std::string arg,
                                              ::std::string* out_ret) = 0;
};

class WithAndWithoutRequestResponse_Proxy final
    : public ::fidl::internal::Proxy,
      public WithAndWithoutRequestResponse {
 public:
  explicit WithAndWithoutRequestResponse_Proxy(
      ::fidl::internal::ProxyController* controller);
  ~WithAndWithoutRequestResponse_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  // cts-coverage-fidl-name:test.protocols/WithAndWithoutRequestResponse.NoRequestNoResponse
  void NoRequestNoResponse() override;
  // cts-coverage-fidl-name:test.protocols/WithAndWithoutRequestResponse.NoRequestEmptyResponse
  void NoRequestEmptyResponse(NoRequestEmptyResponseCallback callback) override;
  // cts-coverage-fidl-name:test.protocols/WithAndWithoutRequestResponse.NoRequestWithResponse
  void NoRequestWithResponse(NoRequestWithResponseCallback callback) override;
  // cts-coverage-fidl-name:test.protocols/WithAndWithoutRequestResponse.WithRequestNoResponse
  void WithRequestNoResponse(::std::string arg) override;
  // cts-coverage-fidl-name:test.protocols/WithAndWithoutRequestResponse.WithRequestEmptyResponse
  void WithRequestEmptyResponse(
      ::std::string arg, WithRequestEmptyResponseCallback callback) override;
  // cts-coverage-fidl-name:test.protocols/WithAndWithoutRequestResponse.WithRequestWithResponse
  void WithRequestWithResponse(
      ::std::string arg, WithRequestWithResponseCallback callback) override;
  OnEmptyResponseCallback OnEmptyResponse;
  OnWithResponseCallback OnWithResponse;

 private:
  WithAndWithoutRequestResponse_Proxy(
      const ::test::protocols::WithAndWithoutRequestResponse_Proxy&) = delete;
  WithAndWithoutRequestResponse_Proxy& operator=(
      const ::test::protocols::WithAndWithoutRequestResponse_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class WithAndWithoutRequestResponse_Stub final
    : public ::fidl::internal::Stub,
      public ::test::protocols::WithAndWithoutRequestResponse_EventSender {
 public:
  typedef class ::test::protocols::WithAndWithoutRequestResponse
      WithAndWithoutRequestResponse_clazz;
  explicit WithAndWithoutRequestResponse_Stub(
      ::test::protocols::WithAndWithoutRequestResponse_Stub::
          WithAndWithoutRequestResponse_clazz* impl);
  ~WithAndWithoutRequestResponse_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;
  void OnEmptyResponse() override;
  void OnWithResponse(::std::string ret) override;

 private:
  ::test::protocols::WithAndWithoutRequestResponse_Stub::
      WithAndWithoutRequestResponse_clazz* impl_;
};

class WithAndWithoutRequestResponse_SyncProxy
    : public ::test::protocols::WithAndWithoutRequestResponse_Sync {
 public:
  explicit WithAndWithoutRequestResponse_SyncProxy(::zx::channel channel);
  ~WithAndWithoutRequestResponse_SyncProxy() override;
  // cts-coverage-fidl-name:test.protocols/WithAndWithoutRequestResponse.NoRequestNoResponse
  zx_status_t NoRequestNoResponse() override;
  // cts-coverage-fidl-name:test.protocols/WithAndWithoutRequestResponse.NoRequestEmptyResponse
  zx_status_t NoRequestEmptyResponse() override;
  // cts-coverage-fidl-name:test.protocols/WithAndWithoutRequestResponse.NoRequestWithResponse
  zx_status_t NoRequestWithResponse(::std::string* out_ret) override;
  // cts-coverage-fidl-name:test.protocols/WithAndWithoutRequestResponse.WithRequestNoResponse
  zx_status_t WithRequestNoResponse(::std::string arg) override;
  // cts-coverage-fidl-name:test.protocols/WithAndWithoutRequestResponse.WithRequestEmptyResponse
  zx_status_t WithRequestEmptyResponse(::std::string arg) override;
  // cts-coverage-fidl-name:test.protocols/WithAndWithoutRequestResponse.WithRequestWithResponse
  zx_status_t WithRequestWithResponse(::std::string arg,
                                      ::std::string* out_ret) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<WithAndWithoutRequestResponse>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class Transitional {
 public:
  using Proxy_ = ::test::protocols::Transitional_Proxy;
  using Stub_ = ::test::protocols::Transitional_Stub;
  using EventSender_ = ::test::protocols::Transitional_EventSender;
  using Sync_ = ::test::protocols::Transitional_Sync;
  virtual ~Transitional();
  using RequestCallback = fit::function<void(int64_t)>;

  virtual void Request(int64_t x, RequestCallback callback) {}

  virtual void OneWay(int64_t x) {}
  using EventCallback = fit::function<void(int64_t)>;
};

class Transitional_RequestDecoder {
 public:
  Transitional_RequestDecoder() = default;
  virtual ~Transitional_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void Request(int64_t x) = 0;
  virtual void OneWay(int64_t x) = 0;
};

class Transitional_ResponseDecoder {
 public:
  Transitional_ResponseDecoder() = default;
  virtual ~Transitional_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void Request(int64_t y) = 0;
  virtual void Event(int64_t x) = 0;
};

class Transitional_EventSender {
 public:
  virtual ~Transitional_EventSender();
  virtual void Event(int64_t x) = 0;
};

class Transitional_Sync {
 public:
  using Proxy_ = ::test::protocols::Transitional_SyncProxy;
  virtual ~Transitional_Sync();
  virtual zx_status_t Request(int64_t x, int64_t* out_y) = 0;
  virtual zx_status_t OneWay(int64_t x) = 0;
};

class Transitional_Proxy final : public ::fidl::internal::Proxy,
                                 public Transitional {
 public:
  explicit Transitional_Proxy(::fidl::internal::ProxyController* controller);
  ~Transitional_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  // cts-coverage-fidl-name:test.protocols/Transitional.Request
  void Request(int64_t x, RequestCallback callback) override;
  // cts-coverage-fidl-name:test.protocols/Transitional.OneWay
  void OneWay(int64_t x) override;
  EventCallback Event;

 private:
  Transitional_Proxy(const ::test::protocols::Transitional_Proxy&) = delete;
  Transitional_Proxy& operator=(const ::test::protocols::Transitional_Proxy&) =
      delete;

  ::fidl::internal::ProxyController* controller_;
};

class Transitional_Stub final
    : public ::fidl::internal::Stub,
      public ::test::protocols::Transitional_EventSender {
 public:
  typedef class ::test::protocols::Transitional Transitional_clazz;
  explicit Transitional_Stub(
      ::test::protocols::Transitional_Stub::Transitional_clazz* impl);
  ~Transitional_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;
  void Event(int64_t x) override;

 private:
  ::test::protocols::Transitional_Stub::Transitional_clazz* impl_;
};

class Transitional_SyncProxy : public ::test::protocols::Transitional_Sync {
 public:
  explicit Transitional_SyncProxy(::zx::channel channel);
  ~Transitional_SyncProxy() override;
  // cts-coverage-fidl-name:test.protocols/Transitional.Request
  zx_status_t Request(int64_t x, int64_t* out_y) override;
  // cts-coverage-fidl-name:test.protocols/Transitional.OneWay
  zx_status_t OneWay(int64_t x) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<Transitional>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class MethodWithUnion {
 public:
  using Proxy_ = ::test::protocols::MethodWithUnion_Proxy;
  using Stub_ = ::test::protocols::MethodWithUnion_Stub;
  using EventSender_ = ::test::protocols::MethodWithUnion_EventSender;
  using Sync_ = ::test::protocols::MethodWithUnion_Sync;
  virtual ~MethodWithUnion();

  virtual void UnionMethod(::test::protocols::TheUnion u) = 0;
};

class MethodWithUnion_RequestDecoder {
 public:
  MethodWithUnion_RequestDecoder() = default;
  virtual ~MethodWithUnion_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void UnionMethod(::test::protocols::TheUnion u) = 0;
};

class MethodWithUnion_ResponseDecoder {
 public:
  MethodWithUnion_ResponseDecoder() = default;
  virtual ~MethodWithUnion_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
};

class MethodWithUnion_EventSender {
 public:
  virtual ~MethodWithUnion_EventSender();
};

class MethodWithUnion_Sync {
 public:
  using Proxy_ = ::test::protocols::MethodWithUnion_SyncProxy;
  virtual ~MethodWithUnion_Sync();
  virtual zx_status_t UnionMethod(::test::protocols::TheUnion u) = 0;
};

class MethodWithUnion_Proxy final : public ::fidl::internal::Proxy,
                                    public MethodWithUnion {
 public:
  explicit MethodWithUnion_Proxy(::fidl::internal::ProxyController* controller);
  ~MethodWithUnion_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  // cts-coverage-fidl-name:test.protocols/MethodWithUnion.UnionMethod
  void UnionMethod(::test::protocols::TheUnion u) override;

 private:
  MethodWithUnion_Proxy(const ::test::protocols::MethodWithUnion_Proxy&) =
      delete;
  MethodWithUnion_Proxy& operator=(
      const ::test::protocols::MethodWithUnion_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class MethodWithUnion_Stub final
    : public ::fidl::internal::Stub,
      public ::test::protocols::MethodWithUnion_EventSender {
 public:
  typedef class ::test::protocols::MethodWithUnion MethodWithUnion_clazz;
  explicit MethodWithUnion_Stub(
      ::test::protocols::MethodWithUnion_Stub::MethodWithUnion_clazz* impl);
  ~MethodWithUnion_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;

 private:
  ::test::protocols::MethodWithUnion_Stub::MethodWithUnion_clazz* impl_;
};

class MethodWithUnion_SyncProxy
    : public ::test::protocols::MethodWithUnion_Sync {
 public:
  explicit MethodWithUnion_SyncProxy(::zx::channel channel);
  ~MethodWithUnion_SyncProxy() override;
  // cts-coverage-fidl-name:test.protocols/MethodWithUnion.UnionMethod
  zx_status_t UnionMethod(::test::protocols::TheUnion u) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<MethodWithUnion>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class WithProtocolEnds {
 public:
  using Proxy_ = ::test::protocols::WithProtocolEnds_Proxy;
  using Stub_ = ::test::protocols::WithProtocolEnds_Stub;
  using EventSender_ = ::test::protocols::WithProtocolEnds_EventSender;
  using Sync_ = ::test::protocols::WithProtocolEnds_Sync;
  virtual ~WithProtocolEnds();
  using ClientEndsCallback = fit::function<void(
      ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>)>;

  virtual void ClientEnds(
      ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol> in,
      ClientEndsCallback callback) = 0;
  using ServerEndsCallback = fit::function<void(
      ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>)>;

  virtual void ServerEnds(
      ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol> in,
      ServerEndsCallback callback) = 0;
  using StructContainingEndsCallback =
      fit::function<void(::test::protocols::ProtocolEnds)>;

  virtual void StructContainingEnds(::test::protocols::ProtocolEnds in,
                                    StructContainingEndsCallback callback) = 0;
};

class WithProtocolEnds_RequestDecoder {
 public:
  WithProtocolEnds_RequestDecoder() = default;
  virtual ~WithProtocolEnds_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void ClientEnds(
      ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol> in) = 0;
  virtual void ServerEnds(
      ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol> in) = 0;
  virtual void StructContainingEnds(::test::protocols::ProtocolEnds in) = 0;
};

class WithProtocolEnds_ResponseDecoder {
 public:
  WithProtocolEnds_ResponseDecoder() = default;
  virtual ~WithProtocolEnds_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void ClientEnds(
      ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol> out) = 0;
  virtual void ServerEnds(
      ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>
          out) = 0;
  virtual void StructContainingEnds(::test::protocols::ProtocolEnds out) = 0;
};

class WithProtocolEnds_EventSender {
 public:
  virtual ~WithProtocolEnds_EventSender();
};

class WithProtocolEnds_Sync {
 public:
  using Proxy_ = ::test::protocols::WithProtocolEnds_SyncProxy;
  virtual ~WithProtocolEnds_Sync();
  virtual zx_status_t ClientEnds(
      ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol> in,
      ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>*
          out_out) = 0;
  virtual zx_status_t ServerEnds(
      ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol> in,
      ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>*
          out_out) = 0;
  virtual zx_status_t StructContainingEnds(
      ::test::protocols::ProtocolEnds in,
      ::test::protocols::ProtocolEnds* out_out) = 0;
};

class WithProtocolEnds_Proxy final : public ::fidl::internal::Proxy,
                                     public WithProtocolEnds {
 public:
  explicit WithProtocolEnds_Proxy(
      ::fidl::internal::ProxyController* controller);
  ~WithProtocolEnds_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  // cts-coverage-fidl-name:test.protocols/WithProtocolEnds.ClientEnds
  void ClientEnds(
      ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol> in,
      ClientEndsCallback callback) override;
  // cts-coverage-fidl-name:test.protocols/WithProtocolEnds.ServerEnds
  void ServerEnds(
      ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol> in,
      ServerEndsCallback callback) override;
  // cts-coverage-fidl-name:test.protocols/WithProtocolEnds.StructContainingEnds
  void StructContainingEnds(::test::protocols::ProtocolEnds in,
                            StructContainingEndsCallback callback) override;

 private:
  WithProtocolEnds_Proxy(const ::test::protocols::WithProtocolEnds_Proxy&) =
      delete;
  WithProtocolEnds_Proxy& operator=(
      const ::test::protocols::WithProtocolEnds_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class WithProtocolEnds_Stub final
    : public ::fidl::internal::Stub,
      public ::test::protocols::WithProtocolEnds_EventSender {
 public:
  typedef class ::test::protocols::WithProtocolEnds WithProtocolEnds_clazz;
  explicit WithProtocolEnds_Stub(
      ::test::protocols::WithProtocolEnds_Stub::WithProtocolEnds_clazz* impl);
  ~WithProtocolEnds_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;

 private:
  ::test::protocols::WithProtocolEnds_Stub::WithProtocolEnds_clazz* impl_;
};

class WithProtocolEnds_SyncProxy
    : public ::test::protocols::WithProtocolEnds_Sync {
 public:
  explicit WithProtocolEnds_SyncProxy(::zx::channel channel);
  ~WithProtocolEnds_SyncProxy() override;
  // cts-coverage-fidl-name:test.protocols/WithProtocolEnds.ClientEnds
  zx_status_t ClientEnds(
      ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol> in,
      ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>* out_out)
      override;
  // cts-coverage-fidl-name:test.protocols/WithProtocolEnds.ServerEnds
  zx_status_t ServerEnds(
      ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol> in,
      ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>*
          out_out) override;
  // cts-coverage-fidl-name:test.protocols/WithProtocolEnds.StructContainingEnds
  zx_status_t StructContainingEnds(
      ::test::protocols::ProtocolEnds in,
      ::test::protocols::ProtocolEnds* out_out) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<WithProtocolEnds>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class ManyParameters {
 public:
  using Proxy_ = ::test::protocols::ManyParameters_Proxy;
  using Stub_ = ::test::protocols::ManyParameters_Stub;
  using EventSender_ = ::test::protocols::ManyParameters_EventSender;
  using Sync_ = ::test::protocols::ManyParameters_Sync;
  virtual ~ManyParameters();

  virtual void Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6,
                       bool p7, bool p8, bool p9, bool p10, bool p11, bool p12,
                       bool p13, bool p14, bool p15) = 0;
};

class ManyParameters_RequestDecoder {
 public:
  ManyParameters_RequestDecoder() = default;
  virtual ~ManyParameters_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6,
                       bool p7, bool p8, bool p9, bool p10, bool p11, bool p12,
                       bool p13, bool p14, bool p15) = 0;
};

class ManyParameters_ResponseDecoder {
 public:
  ManyParameters_ResponseDecoder() = default;
  virtual ~ManyParameters_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
};

class ManyParameters_EventSender {
 public:
  virtual ~ManyParameters_EventSender();
};

class ManyParameters_Sync {
 public:
  using Proxy_ = ::test::protocols::ManyParameters_SyncProxy;
  virtual ~ManyParameters_Sync();
  virtual zx_status_t Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5,
                              bool p6, bool p7, bool p8, bool p9, bool p10,
                              bool p11, bool p12, bool p13, bool p14,
                              bool p15) = 0;
};

class ManyParameters_Proxy final : public ::fidl::internal::Proxy,
                                   public ManyParameters {
 public:
  explicit ManyParameters_Proxy(::fidl::internal::ProxyController* controller);
  ~ManyParameters_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  // cts-coverage-fidl-name:test.protocols/ManyParameters.Fifteen
  void Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7,
               bool p8, bool p9, bool p10, bool p11, bool p12, bool p13,
               bool p14, bool p15) override;

 private:
  ManyParameters_Proxy(const ::test::protocols::ManyParameters_Proxy&) = delete;
  ManyParameters_Proxy& operator=(
      const ::test::protocols::ManyParameters_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class ManyParameters_Stub final
    : public ::fidl::internal::Stub,
      public ::test::protocols::ManyParameters_EventSender {
 public:
  typedef class ::test::protocols::ManyParameters ManyParameters_clazz;
  explicit ManyParameters_Stub(
      ::test::protocols::ManyParameters_Stub::ManyParameters_clazz* impl);
  ~ManyParameters_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;

 private:
  ::test::protocols::ManyParameters_Stub::ManyParameters_clazz* impl_;
};

class ManyParameters_SyncProxy : public ::test::protocols::ManyParameters_Sync {
 public:
  explicit ManyParameters_SyncProxy(::zx::channel channel);
  ~ManyParameters_SyncProxy() override;
  // cts-coverage-fidl-name:test.protocols/ManyParameters.Fifteen
  zx_status_t Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6,
                      bool p7, bool p8, bool p9, bool p10, bool p11, bool p12,
                      bool p13, bool p14, bool p15) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<ManyParameters>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class WithErrorSyntax {
 public:
  using Proxy_ = ::test::protocols::WithErrorSyntax_Proxy;
  using Stub_ = ::test::protocols::WithErrorSyntax_Stub;
  using EventSender_ = ::test::protocols::WithErrorSyntax_EventSender;
  using Sync_ = ::test::protocols::WithErrorSyntax_Sync;
  virtual ~WithErrorSyntax();
  using ResponseAsStructCallback = fit::function<void(
      ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result)>;

  virtual void ResponseAsStruct(ResponseAsStructCallback callback) = 0;
  using ErrorAsPrimitiveCallback = fit::function<void(
      ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result)>;

  virtual void ErrorAsPrimitive(ErrorAsPrimitiveCallback callback) = 0;
  using ErrorAsEnumCallback = fit::function<void(
      ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result)>;

  virtual void ErrorAsEnum(ErrorAsEnumCallback callback) = 0;
  using HandleInResultCallback = fit::function<void(
      ::test::protocols::WithErrorSyntax_HandleInResult_Result)>;

  virtual void HandleInResult(HandleInResultCallback callback) = 0;
};

class WithErrorSyntax_RequestDecoder {
 public:
  WithErrorSyntax_RequestDecoder() = default;
  virtual ~WithErrorSyntax_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void ResponseAsStruct() = 0;
  virtual void ErrorAsPrimitive() = 0;
  virtual void ErrorAsEnum() = 0;
  virtual void HandleInResult() = 0;
};

class WithErrorSyntax_ResponseDecoder {
 public:
  WithErrorSyntax_ResponseDecoder() = default;
  virtual ~WithErrorSyntax_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void ResponseAsStruct(
      ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result result) = 0;
  virtual void ErrorAsPrimitive(
      ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result result) = 0;
  virtual void ErrorAsEnum(
      ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result result) = 0;
  virtual void HandleInResult(
      ::test::protocols::WithErrorSyntax_HandleInResult_Result result) = 0;
};

class WithErrorSyntax_EventSender {
 public:
  virtual ~WithErrorSyntax_EventSender();
};

class WithErrorSyntax_Sync {
 public:
  using Proxy_ = ::test::protocols::WithErrorSyntax_SyncProxy;
  virtual ~WithErrorSyntax_Sync();
  virtual zx_status_t ResponseAsStruct(
      ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result*
          out_result) = 0;
  virtual zx_status_t ErrorAsPrimitive(
      ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result*
          out_result) = 0;
  virtual zx_status_t ErrorAsEnum(
      ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result* out_result) = 0;
  virtual zx_status_t HandleInResult(
      ::test::protocols::WithErrorSyntax_HandleInResult_Result* out_result) = 0;
};

class WithErrorSyntax_Proxy final : public ::fidl::internal::Proxy,
                                    public WithErrorSyntax {
 public:
  explicit WithErrorSyntax_Proxy(::fidl::internal::ProxyController* controller);
  ~WithErrorSyntax_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  // cts-coverage-fidl-name:test.protocols/WithErrorSyntax.ResponseAsStruct
  void ResponseAsStruct(ResponseAsStructCallback callback) override;
  // cts-coverage-fidl-name:test.protocols/WithErrorSyntax.ErrorAsPrimitive
  void ErrorAsPrimitive(ErrorAsPrimitiveCallback callback) override;
  // cts-coverage-fidl-name:test.protocols/WithErrorSyntax.ErrorAsEnum
  void ErrorAsEnum(ErrorAsEnumCallback callback) override;
  // cts-coverage-fidl-name:test.protocols/WithErrorSyntax.HandleInResult
  void HandleInResult(HandleInResultCallback callback) override;

 private:
  WithErrorSyntax_Proxy(const ::test::protocols::WithErrorSyntax_Proxy&) =
      delete;
  WithErrorSyntax_Proxy& operator=(
      const ::test::protocols::WithErrorSyntax_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class WithErrorSyntax_Stub final
    : public ::fidl::internal::Stub,
      public ::test::protocols::WithErrorSyntax_EventSender {
 public:
  typedef class ::test::protocols::WithErrorSyntax WithErrorSyntax_clazz;
  explicit WithErrorSyntax_Stub(
      ::test::protocols::WithErrorSyntax_Stub::WithErrorSyntax_clazz* impl);
  ~WithErrorSyntax_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;

 private:
  ::test::protocols::WithErrorSyntax_Stub::WithErrorSyntax_clazz* impl_;
};

class WithErrorSyntax_SyncProxy
    : public ::test::protocols::WithErrorSyntax_Sync {
 public:
  explicit WithErrorSyntax_SyncProxy(::zx::channel channel);
  ~WithErrorSyntax_SyncProxy() override;
  // cts-coverage-fidl-name:test.protocols/WithErrorSyntax.ResponseAsStruct
  zx_status_t ResponseAsStruct(
      ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result* out_result)
      override;
  // cts-coverage-fidl-name:test.protocols/WithErrorSyntax.ErrorAsPrimitive
  zx_status_t ErrorAsPrimitive(
      ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result* out_result)
      override;
  // cts-coverage-fidl-name:test.protocols/WithErrorSyntax.ErrorAsEnum
  zx_status_t ErrorAsEnum(::test::protocols::WithErrorSyntax_ErrorAsEnum_Result*
                              out_result) override;
  // cts-coverage-fidl-name:test.protocols/WithErrorSyntax.HandleInResult
  zx_status_t HandleInResult(
      ::test::protocols::WithErrorSyntax_HandleInResult_Result* out_result)
      override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<WithErrorSyntax>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class DiscoverableProtocol {
 public:
  using Proxy_ = ::test::protocols::DiscoverableProtocol_Proxy;
  using Stub_ = ::test::protocols::DiscoverableProtocol_Stub;
  using EventSender_ = ::test::protocols::DiscoverableProtocol_EventSender;
  using Sync_ = ::test::protocols::DiscoverableProtocol_Sync;
  static const char Name_[];
  virtual ~DiscoverableProtocol();

  virtual void Method() = 0;
};

class DiscoverableProtocol_RequestDecoder {
 public:
  DiscoverableProtocol_RequestDecoder() = default;
  virtual ~DiscoverableProtocol_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void Method() = 0;
};

class DiscoverableProtocol_ResponseDecoder {
 public:
  DiscoverableProtocol_ResponseDecoder() = default;
  virtual ~DiscoverableProtocol_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
};

class DiscoverableProtocol_EventSender {
 public:
  virtual ~DiscoverableProtocol_EventSender();
};

class DiscoverableProtocol_Sync {
 public:
  using Proxy_ = ::test::protocols::DiscoverableProtocol_SyncProxy;
  virtual ~DiscoverableProtocol_Sync();
  virtual zx_status_t Method() = 0;
};

class DiscoverableProtocol_Proxy final : public ::fidl::internal::Proxy,
                                         public DiscoverableProtocol {
 public:
  explicit DiscoverableProtocol_Proxy(
      ::fidl::internal::ProxyController* controller);
  ~DiscoverableProtocol_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  // cts-coverage-fidl-name:test.protocols/DiscoverableProtocol.Method
  void Method() override;

 private:
  DiscoverableProtocol_Proxy(
      const ::test::protocols::DiscoverableProtocol_Proxy&) = delete;
  DiscoverableProtocol_Proxy& operator=(
      const ::test::protocols::DiscoverableProtocol_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class DiscoverableProtocol_Stub final
    : public ::fidl::internal::Stub,
      public ::test::protocols::DiscoverableProtocol_EventSender {
 public:
  typedef class ::test::protocols::DiscoverableProtocol
      DiscoverableProtocol_clazz;
  explicit DiscoverableProtocol_Stub(
      ::test::protocols::DiscoverableProtocol_Stub::DiscoverableProtocol_clazz*
          impl);
  ~DiscoverableProtocol_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;

 private:
  ::test::protocols::DiscoverableProtocol_Stub::DiscoverableProtocol_clazz*
      impl_;
};

class DiscoverableProtocol_SyncProxy
    : public ::test::protocols::DiscoverableProtocol_Sync {
 public:
  explicit DiscoverableProtocol_SyncProxy(::zx::channel channel);
  ~DiscoverableProtocol_SyncProxy() override;
  // cts-coverage-fidl-name:test.protocols/DiscoverableProtocol.Method
  zx_status_t Method() override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<DiscoverableProtocol>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class ChannelProtocol {
 public:
  using Proxy_ = ::test::protocols::ChannelProtocol_Proxy;
  using Stub_ = ::test::protocols::ChannelProtocol_Stub;
  using EventSender_ = ::test::protocols::ChannelProtocol_EventSender;
  using Sync_ = ::test::protocols::ChannelProtocol_Sync;
  virtual ~ChannelProtocol();

  virtual void MethodA(int64_t a, int64_t b) = 0;
  using EventACallback = fit::function<void(int64_t, int64_t)>;
  using MethodBCallback = fit::function<void(int64_t)>;

  virtual void MethodB(int64_t a, int64_t b, MethodBCallback callback) = 0;
  using TakeHandleCallback = fit::function<void()>;

  virtual void TakeHandle(::zx::handle h, TakeHandleCallback callback) = 0;
  using MutateSocketCallback = fit::function<void(::zx::socket)>;

  virtual void MutateSocket(::zx::socket a, MutateSocketCallback callback) = 0;
};

class ChannelProtocol_RequestDecoder {
 public:
  ChannelProtocol_RequestDecoder() = default;
  virtual ~ChannelProtocol_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void MethodA(int64_t a, int64_t b) = 0;
  virtual void MethodB(int64_t a, int64_t b) = 0;
  virtual void TakeHandle(::zx::handle h) = 0;
  virtual void MutateSocket(::zx::socket a) = 0;
};

class ChannelProtocol_ResponseDecoder {
 public:
  ChannelProtocol_ResponseDecoder() = default;
  virtual ~ChannelProtocol_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void EventA(int64_t a, int64_t b) = 0;
  virtual void MethodB(int64_t result) = 0;
  virtual void TakeHandle() = 0;
  virtual void MutateSocket(::zx::socket b) = 0;
};

class ChannelProtocol_EventSender {
 public:
  virtual ~ChannelProtocol_EventSender();
  virtual void EventA(int64_t a, int64_t b) = 0;
};

class ChannelProtocol_Sync {
 public:
  using Proxy_ = ::test::protocols::ChannelProtocol_SyncProxy;
  virtual ~ChannelProtocol_Sync();
  virtual zx_status_t MethodA(int64_t a, int64_t b) = 0;
  virtual zx_status_t MethodB(int64_t a, int64_t b, int64_t* out_result) = 0;
  virtual zx_status_t TakeHandle(::zx::handle h) = 0;
  virtual zx_status_t MutateSocket(::zx::socket a, ::zx::socket* out_b) = 0;
};

class ChannelProtocol_Proxy final : public ::fidl::internal::Proxy,
                                    public ChannelProtocol {
 public:
  explicit ChannelProtocol_Proxy(::fidl::internal::ProxyController* controller);
  ~ChannelProtocol_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  // cts-coverage-fidl-name:test.protocols/ChannelProtocol.MethodA
  void MethodA(int64_t a, int64_t b) override;
  EventACallback EventA;
  // cts-coverage-fidl-name:test.protocols/ChannelProtocol.MethodB
  void MethodB(int64_t a, int64_t b, MethodBCallback callback) override;
  // cts-coverage-fidl-name:test.protocols/ChannelProtocol.TakeHandle
  void TakeHandle(::zx::handle h, TakeHandleCallback callback) override;
  // cts-coverage-fidl-name:test.protocols/ChannelProtocol.MutateSocket
  void MutateSocket(::zx::socket a, MutateSocketCallback callback) override;

 private:
  ChannelProtocol_Proxy(const ::test::protocols::ChannelProtocol_Proxy&) =
      delete;
  ChannelProtocol_Proxy& operator=(
      const ::test::protocols::ChannelProtocol_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class ChannelProtocol_Stub final
    : public ::fidl::internal::Stub,
      public ::test::protocols::ChannelProtocol_EventSender {
 public:
  typedef class ::test::protocols::ChannelProtocol ChannelProtocol_clazz;
  explicit ChannelProtocol_Stub(
      ::test::protocols::ChannelProtocol_Stub::ChannelProtocol_clazz* impl);
  ~ChannelProtocol_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;
  void EventA(int64_t a, int64_t b) override;

 private:
  ::test::protocols::ChannelProtocol_Stub::ChannelProtocol_clazz* impl_;
};

class ChannelProtocol_SyncProxy
    : public ::test::protocols::ChannelProtocol_Sync {
 public:
  explicit ChannelProtocol_SyncProxy(::zx::channel channel);
  ~ChannelProtocol_SyncProxy() override;
  // cts-coverage-fidl-name:test.protocols/ChannelProtocol.MethodA
  zx_status_t MethodA(int64_t a, int64_t b) override;
  // cts-coverage-fidl-name:test.protocols/ChannelProtocol.MethodB
  zx_status_t MethodB(int64_t a, int64_t b, int64_t* out_result) override;
  // cts-coverage-fidl-name:test.protocols/ChannelProtocol.TakeHandle
  zx_status_t TakeHandle(::zx::handle h) override;
  // cts-coverage-fidl-name:test.protocols/ChannelProtocol.MutateSocket
  zx_status_t MutateSocket(::zx::socket a, ::zx::socket* out_b) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<ChannelProtocol>;
};
#endif  // __Fuchsia__

}  // namespace protocols
}  // namespace test
