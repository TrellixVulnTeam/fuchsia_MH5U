// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
library fuchsia.sys2;

using fuchsia.mem;

/// A component is a unit of executable software.
///
/// This object provides the component's declaration, access to its package's
/// content, and relevant metadata.
type Component = resource table {
    /// The resolved URL of the component.
    /// This is the canonical URL obtained by the component resolver after
    /// following redirects and resolving relative paths.
    1: resolved_url string;

    /// Binary representation of the component's declaration (`fuchsia.sys2.ComponentDecl`).
    /// This information is typically obtained from the component's manifest
    /// or generated by the component resolver.
    2: decl fuchsia.mem.Data;

    /// The package that contains the component.
    /// By convention, the component's package is mapped to "/pkg" in its
    /// namespace at runtime.
    ///
    /// This is null if the component is not represented as a package.
    /// In that case, it is the runner's responsibility to load the component's
    /// resource from the `resolved_url`.  This mechanism is used for web
    /// applications.
    ///
    /// Most runners, including but not limited to the builtin ELF runner,
    /// require the package's directory connection to have OPEN_RIGHT_EXECUTABLE
    /// rights in order to run the resolved component.
    ///
    // TODO(fxbug.dev/4051): It might be better to return a package loader interface
    // here instead of immediately providing the package's content.
    // That would allow for finer grained pipelining of component installation
    // and launching of the component's runner.  Moreover, sometimes we only
    // need the component's declarative information.
    3: package Package;

    /// Binary representation of the component's configuration values
    /// (`fuchsia.component.config.ValuesData`).
    4: config_values fuchsia.mem.Data;
};
